---
title: "Jafari/Kassem LGMN KO/OE downstream PSI-Sigma analysis"
author: "Angel Liang"
date: "09/02/2021"
output: html_document
---

# Set the running environment

## Packages and directories

```{r message=FALSE, warning=FALSE}

library(tidyverse)
library(gtools)
library(RColorBrewer)
library(data.table)
data.table::setDTthreads(threads = 48)

# library(future.apply)
# library(furrr)
# options(future.globals.maxSize = 1500000000000, future.fork.enable = TRUE)
# plan(multiprocess)
# memory.limit(100000)

library(rtracklayer)

library(ggplot2)

source("/mnt/LTS/tools/angel_suite/source/main_source.R")

source_dir <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_LGMN_KO_OE/source/"

psisigma_results_dir <- "/mnt/scratch/jafari_kassem_LGMN_rnaseq/3_psisigma/"

R_processing_results_dir <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_LGMN_KO_OE/R_processing_results/"

if(! dir.exists(R_processing_results_dir) ) {
  dir.create(R_processing_results_dir, recursive = TRUE)}

vector_sample_names <- c("LGMN_KD_minus_ctrl", "LGMN_OE_minus_ctrl")

bam_bai_sj_sam_dir <- "/mnt/scratch/jafari_kassem_LGMN_rnaseq/2_star/"

reference_data_dir <- "/mnt/LTS/reference_data/"

psisigma_results_dir_kd <- "/mnt/scratch/jafari_kassem_LGMN_rnaseq/3_psisigma/LGMN_KD_minus_ctrl"
psisigma_results_dir_oe <- "/mnt/scratch/jafari_kassem_LGMN_rnaseq/3_psisigma/LGMN_OE_minus_ctrl"

vector_experiment_tag <- c("jafari_kassem_lgmn", "rnaseq", "psisigma")

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_NMD_classifier/results/Homo_sapiens.GRCh38.98_NMD_PTC_E4.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/PGNEXUS_kassem_MSC/Kassem_OB/analysis_NMD_classifier/results/alltimepoints_denovo_reconstructed_stringtiemerged_NMD_PTC_E4.gtf") %>% as_tibble

```

# Import and process PSI-Sigma tables

## Import the sorted.out tables, denominator tables and db tables.

```{r}

read_threshold <- 5

# load universal db file

# [which(tibble_test$value == TRUE)][1:10]
list_sorted_joined_tibbles <- round_robin_pmap_callr(
  .l = list(
    "a1" = list("kd" = read.delim(file = paste(psisigma_results_dir_kd, "/LGMN_KD_minus_ctrl_r1_ir3.sorted.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% tibble::as_tibble(),
                "oe" = read.delim(file = paste(psisigma_results_dir_oe, "/LGMN_OE_minus_ctrl_r1_ir3.sorted.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% tibble::as_tibble()
    ),
    "a2" = list("kd" = read.delim(file = paste(psisigma_results_dir_kd, "/LGMN_KD_minus_ctrl_r1_ir3.denominator.gct", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, skip = 2, na.strings = c("NA", "N/A", "na")) %>% tibble::as_tibble(),
                "oe" = read.delim(file = paste(psisigma_results_dir_oe, "/LGMN_OE_minus_ctrl_r1_ir3.denominator.gct", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, skip = 2, na.strings = c("NA", "N/A", "na")) %>% tibble::as_tibble()
    ),
    "a3" = list("kd" = data.table::fread(file = paste(psisigma_results_dir_kd, "/LGMN_KD_minus_ctrl.db", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE, na.strings = c("NA", "N/A", "na"), fill = TRUE) %>% tibble::as_tibble(),
                "oe" = data.table::fread(file = paste(psisigma_results_dir_oe, "/LGMN_OE_minus_ctrl.db", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE, na.strings = c("NA", "N/A", "na"), fill = TRUE) %>% tibble::as_tibble()
    ),
    "a4" = c("kd", "oe")
  ),
  .num_workers = 96, .no_chunks = 96,
  .f = function(a1, a2, a3, a4) {
    
    # DEBUG ###
    # a1 <- read.delim(file = paste(psisigma_results_dir_kd, "/LGMN_KD_minus_ctrl_r1_ir3.sorted.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% tibble::as_tibble()
    # a2 <- read.delim(file = paste(psisigma_results_dir_kd, "/LGMN_KD_minus_ctrl_r1_ir3.denominator.gct", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, skip = 2, na.strings = c("NA", "N/A", "na")) %>% tibble::as_tibble()
    # a3 <- "kd"
    ###########
    
    # cat(a4, "\n")
    
    # import the main result tibbles
    tibble_raw_sorted_out <- a1
    
    # extract info on the number of lanes
    number_of_replicates <- tibble_raw_sorted_out$`N Values` %>% .[1] %>% strsplit(split = "\\|") %>% unlist %>% length
    
    # post-import clean-up
    tibble_sorted_out_cleaned <- tibble_raw_sorted_out %>% 
      setNames(nm = c("event_region", "psisigma_gene_symbol", "alternative_exon_coords", "splicemode", "no_replicates_ctrl", paste(a4, "_no_replicates", sep = ""), "psisigma_nmd", "psisigma_reference_transcript", "dPSI", "t_test_pvalue", "t_test_FDR", "PSI_comparison.1", "PSI_comparison.2", "database_id")) %>%
      dplyr::select(-contains("no_replicates")) %>% 
      dplyr::relocate(database_id, .before = 1) %>%
      tibble::add_column("aes_id" = gsub(x = .$database_id, pattern = "(.*ENST.*)_(.*)", replacement = "\\1"), 
                         "exon_number" = gsub(x = .$database_id, pattern = "(.*ENST.*)_(.*)", replacement = "\\2") %>% type.convert(as.is = TRUE), .after = "database_id")
    
    # import denominator tables
    tibble_denominator_table <- a2 %>%
      tibble::add_column("aes_id" = gsub(x = .$Event, pattern = ".*\\:(.*ENST.*)_(.*)$", replacement = "\\1"), 
                         "exon_number" = gsub(x = .$Event, pattern = ".*\\:(.*ENST.*)_(.*)$", replacement = "\\2") %>% type.convert(as.is = TRUE), .after = "Event")

    colnames(tibble_denominator_table)[5:7] <- paste("denominator_ctrl_", 1:3, sep = "")
    colnames(tibble_denominator_table)[8:10] <- paste("denominator_condition_", 1:3, sep = "")
    
    tibble_joined <- dplyr::left_join(tibble_sorted_out_cleaned, tibble_denominator_table %>% dplyr::select(-Event, -Annotation), by = c("aes_id", "exon_number"))
    
    # SEPARATE absolute psi VALUES
    tibble_joined <- tibble_joined %>% 
      tidyr::separate(col = "PSI_comparison.1", into = paste("absolute.psi_ctrl_", 1:3, sep = ""), sep = "\\|") %>% type.convert(as.is = TRUE, na.strings = c("NA", "N/A", "na")) %>%
      tidyr::separate(col = "PSI_comparison.2", into = paste("absolute.psi_condition_", 1:3, sep = ""), sep = "\\|") %>% type.convert(as.is = TRUE, na.strings = c("NA", "N/A", "na")) 
    
    # create numerator
    tibble_joined <- tibble_joined %>% 
      dplyr::mutate(!!(paste("numerator_ctrl", sep = "") %>% as.name) := type.convert(as.is = TRUE, tibble_joined[, grep(x = names(tibble_joined), pattern = "absolute\\.psi\\_ctrl\\_")] %>% as.matrix %>% rowMeans(na.rm = TRUE)) * type.convert(as.is = TRUE, tibble_joined[, grep(x = names(tibble_joined), pattern = "denominator\\_ctrl\\_")] %>% as.matrix %>% rowMeans(na.rm = TRUE) ) * 0.01) %>% 
      dplyr::mutate(!!(paste("numerator_condition", sep = "") %>% as.name) := type.convert(as.is = TRUE, tibble_joined[, grep(x = names(tibble_joined), pattern = "absolute\\.psi\\_condition\\_")] %>% as.matrix %>% rowMeans(na.rm = TRUE)) * type.convert(as.is = TRUE, tibble_joined[, grep(x = names(tibble_joined), pattern = "denominator\\_condition\\_")] %>% as.matrix %>% rowMeans(na.rm = TRUE) ) * 0.01)
    
    # create logical column of whether the row is at least 5 inclusion reads in at least 3 reps.
    # vector_logical_passes_read_threshold <- tibble_joined %>% dplyr::select(contains("numerator")) %>% apply(X = ., MARGIN = 1, FUN = function(X) {all(X %>% na.omit >= read_threshold) & any(X %>% is.na) == FALSE})
    vector_logical_passes_read_threshold <- (tibble_joined %>% dplyr::select(contains("numerator")) %>% rowSums(na.rm = TRUE)) > read_threshold
    
    tibble_joined <- tibble::add_column(tibble_joined, "passes_read_threshold" = vector_logical_passes_read_threshold)
    
    tibble_joined <- tibble::add_column(tibble_joined, "condition" = a4)
    
    tibble_universal_dbfile <- a3 %>% 
  .[!is.na(.$V2), ] %>%
  setNames(nm = c("chr", "left_junc_start", "left_junc_end", "right_junc_start", "right_junc_end", "alternative_exon_start", "alternative_exon_end", "psisigma_nmd", "event_region_start", "event_region_end", "database_id", "psisigma_gene_symbol")) %>% 
  tibble::add_column("aes_id" = gsub(x = .$database_id, pattern = "(.*ENST.*)_(.*)", replacement = "\\1"), 
                     "exon_number" = gsub(x = .$database_id, pattern = "(.*ENST.*)_(.*)", replacement = "\\2") %>% type.convert(as.is = TRUE), 
                     "alternative_exon_coords" = paste(.$chr, ":", .$alternative_exon_start, "-", .$alternative_exon_end, sep = ""), .after = "database_id")
    
    tibble_aes_id_to_aes_exon_mapping <- tibble_universal_dbfile %>% 
      dplyr::arrange(alternative_exon_start) %>%
      dplyr::group_by(aes_id) %>%
      dplyr::summarise("aes_exon_coords" = alternative_exon_coords %>% paste(collapse = ";"))
    
    tibble_joined <- tibble_joined %>% 
      dplyr::left_join(., tibble_aes_id_to_aes_exon_mapping, by = "aes_id") %>%
      dplyr::relocate(aes_exon_coords, .after = "event_region")
    
    return(tibble_joined)
    
  }, .progress = TRUE) %>% set_names(nm = c("kd", "oe"))

# wide table join for master tibble
long_tibble_main <- list_sorted_joined_tibbles %>% purrr::reduce(dplyr::bind_rows)

long_tibble_main <- long_tibble_main %>% 
  dplyr::mutate_at(.vars = "splicemode", .funs = function(x) {gsub(x = x, pattern = "(IR)(.*)", replacement = "\\1") %>% return}) %>% 
  dplyr::mutate_at(.vars = "splicemode", .funs = function(x) {gsub(x = x, pattern = "TSS\\|", replacement = "") %>% return})

# fix aes exon coords for A3/5SS events. they're not meant to describe alternative exons to begin with.
long_tibble_main[long_tibble_main$splicemode %in% c("A3SS", "A5SS"), "aes_exon_coords"] <- long_tibble_main[long_tibble_main$splicemode %in% c("A3SS", "A5SS"), "alternative_exon_coords"]

long_tibble_main <- long_tibble_main %>% 
  tibble::add_column("unprocessed_id" = 1:nrow(long_tibble_main), .before = 1)

# qs::qsave(x = long_tibble_main, file = paste(R_processing_results_dir, vector_experiment_tag %>% paste(collapse = "_"), "_long_tibble_main.qs", sep = ""))

data.table::fwrite(x = long_tibble_main, file = paste(R_processing_results_dir, vector_experiment_tag %>% paste(collapse = "_"), "_long_tibble_main.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# filter for read threshold
long_tibble_filtered_for_readcount <- long_tibble_main[long_tibble_main$passes_read_threshold == TRUE, ]

# add in group and feature IDs for DEXSeq anyways
long_tibble_filtered_for_readcount_grouped_by_event_region <- long_tibble_filtered_for_readcount %>% 
  dplyr::group_by(event_region) %>% 
  dplyr::mutate("groupid" = which(group_data(.) %>% .$event_region == `event_region` %>% unique), "featureid" = 1:n()) %>% 
  dplyr::ungroup()

data.table::fwrite(x = long_tibble_filtered_for_readcount_grouped_by_event_region, file = paste(R_processing_results_dir, vector_experiment_tag %>% paste(collapse = "_"), "_long_tibble_filtered_for_readcount_grouped_by_event_region.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## test for SJ existence

PSI-Sigma has this one bug where splice reads present in the universal .db file will count in a sample even if it isn't there in the sample. 
Here, we address this once and for all. 

For splice events with no SJ existence, we set the numerator, denominator and PSI to 0.

```{r}

# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_pooled_replicates.tibble", sep = ""))

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

tibble_VSR_alt_exon_info <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% 
  dplyr::select(contains("event_region"), contains("LIV_exon_coords"), contains("splicemode")) %>% 
  dplyr::mutate("chr" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\1"),
                "VSR_start" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2"),
                "VSR_end" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3"),
                "id" = 1:nrow(.))

# split by chr
list_tibble_VSR_alt_exon_info_split_by_chr <- tibble_VSR_alt_exon_info %>%
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unique)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 24)))

# check if events exist in the SJ.out.tab files 
list_row_indices_valid_according_to_SJ_existence <- furrr::future_pmap(
  .l = list(
    "a1" = tibble_combined_mapping_info$condition_names %>% unique %>% na.omit
  ),
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- tibble_combined_mapping_info$condition_names %>% unique %>% na.omit %>% .[[1]]
    ###########
    
    cat(a1, "\n")
    
    #  import SJ.out.tab file.
    ## we only need to know whether the splice junction is there or not, so we will just take the chr start end strand of the SJ table after filtering for at least 1 unique or multimapping read.
    
    tibble_SJ.out.tab_reduced <- read.delim(file = paste(bam_bai_sj_sam_dir, a1, ".SJ.out.tab", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, row.names = NULL) %>% setNames(c("chr", "start", "end", "strand", "intron_motif", "annotated", "no_uniquely_mapping_reads", "no_multi_mapping_reads", "max_overhang")) %>% 
      as_tibble %>%
      dplyr::filter(no_uniquely_mapping_reads > 0 | no_multi_mapping_reads > 0) %>%
      dplyr::select(chr, start, end, strand) %>% 
      unique
    
    # split by chromosome for less parallel overhead
    list_tibble_SJ.out.tab_reduced_split_by_chr <- tibble_SJ.out.tab_reduced %>%
      dplyr::group_split(chr) %>%
      set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unique)
    
    # plan(list(tweak(multiprocess, workers = 3),
    #           tweak(multiprocess, workers = 8)))
    
    vector_logical_splice_event_exists_in_SJ <- furrr::future_map2(
      .x = list_tibble_SJ.out.tab_reduced_split_by_chr[intersect(names(list_tibble_SJ.out.tab_reduced_split_by_chr), 
                                                                 names(list_tibble_VSR_alt_exon_info_split_by_chr)) %>% na.omit],
      .y = list_tibble_VSR_alt_exon_info_split_by_chr[intersect(names(list_tibble_SJ.out.tab_reduced_split_by_chr), 
                                                                names(list_tibble_VSR_alt_exon_info_split_by_chr)) %>% na.omit],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_tibble_SJ.out.tab_reduced_split_by_chr[intersect(names(list_tibble_SJ.out.tab_reduced_split_by_chr),
        #       names(list_tibble_VSR_alt_exon_info_split_by_chr))] %>% .[[1]]
        # b2 <- list_tibble_VSR_alt_exon_info_split_by_chr[intersect(names(list_tibble_SJ.out.tab_reduced_split_by_chr),
        #       names(list_tibble_VSR_alt_exon_info_split_by_chr))] %>% .[[1]]
        ###########
        
        # plan(list(tweak(multiprocess, workers = 4),
        #           tweak(multiprocess, workers = 2)))
        
        # test for splice event existence
        vector_logical_splice_event_exists_in_SJ <- apply(X = b2, MARGIN = 1, FUN = function(X) {
          
          # DEBUG ###
          # X <- tibble_VSR_alt_exon_info[tibble_VSR_alt_exon_info$splicemode == "IR", ] %>% .[1, ] %>% unlist # IR
          # X <- tibble_VSR_alt_exon_info[tibble_VSR_alt_exon_info$splicemode == "SES", ] %>% .[1, ] %>% unlist # SES
          # X <- tibble_VSR_alt_exon_info[tibble_VSR_alt_exon_info$splicemode == "MES", ] %>% .[1, ] %>% unlist # MES
          # X <- tibble_VSR_alt_exon_info[tibble_VSR_alt_exon_info$splicemode == "A3SS", ] %>% .[1, ] %>% unlist # A3SS
          ###########
          
          chr <- X[names(X) == "chr"]
          VSR_start <- X[names(X) == "VSR_start"] %>% type.convert(as.is = TRUE) %>% suppressMessages() %>% suppressWarnings()
          VSR_end <- X[names(X) == "VSR_end"] %>% type.convert(as.is = TRUE) %>% suppressMessages() %>% suppressWarnings()
          
          vector_LIV_exon_starts <- X[names(X) == "LIV_exon_coords"] %>% strsplit(split = "\\;") %>% unlist %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2") %>% type.convert(as.is = TRUE) %>% suppressMessages() %>% suppressWarnings()
          
          vector_LIV_exon_ends <- X[names(X) == "LIV_exon_coords"] %>% strsplit(split = "\\;") %>% unlist %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3") %>% type.convert(as.is = TRUE) %>% suppressMessages() %>% suppressWarnings()
          
          if (X[names(X) == "splicemode"] == "IR") {
            logical_is_valid <- which(b1$chr == chr &
                                        b1$start <= vector_LIV_exon_starts + 1 &
                                        b1$start >= vector_LIV_exon_starts - 1 &
                                        b1$end <= vector_LIV_exon_ends + 1 &
                                        b1$end >= vector_LIV_exon_ends - 1) %>% length > 0
          } else if (X[names(X) == "splicemode"] == "SES") {
            logical_is_valid <- 
              (which(b1$chr == chr & # left cassette IR junction
                       b1$start <= VSR_start + 1 &
                       b1$start >= VSR_start - 1 &
                       b1$end <= vector_LIV_exon_starts &
                       b1$end >= vector_LIV_exon_starts - 2) %>% length > 0) &
              (which(b1$chr == chr & # right cassette IR junction
                       b1$start <= vector_LIV_exon_ends + 2 &
                       b1$start >= vector_LIV_exon_ends &
                       b1$end <= VSR_end + 1 &
                       b1$end >= VSR_end - 1) %>% length > 0)
          } else if (X[names(X) == "splicemode"] %in% c("SES", "MES", "MXS")) {
            logical_is_valid <- 
              (which(b1$chr == chr & # leftmost battery IR junction
                       b1$start <= VSR_start + 1 &
                       b1$start >= VSR_start - 1 &
                       b1$end <= vector_LIV_exon_starts[1] &
                       b1$end >= vector_LIV_exon_starts[1] - 2) %>% length > 0) &
              (which(b1$chr == chr & # rightmost battery IR junction
                       b1$start <= vector_LIV_exon_ends[length(vector_LIV_exon_ends)] + 2 &
                       b1$start >= vector_LIV_exon_ends[length(vector_LIV_exon_ends)] &
                       b1$end <= VSR_end + 1 &
                       b1$end >= VSR_end - 1) %>% length > 0)
          } else if (X[names(X) == "splicemode"] %in% c("A3SS", "A5SS")) {
            # intersect the VSR and LIV coords
            vector_common_coord <- intersect(c(VSR_start, VSR_end), c(vector_LIV_exon_starts, vector_LIV_exon_ends))
            
            vector_free_VSR_coord <- setdiff(c(VSR_start, VSR_end), c(vector_LIV_exon_starts, vector_LIV_exon_ends))
            vector_free_LIV_coord <- setdiff(c(vector_LIV_exon_starts, vector_LIV_exon_ends), c(VSR_start, VSR_end))
            
            # use these coords to create the short (IR) junction (not the long ER)
            # detect if the free VSR coord > free LIV coord
            vector_IR_LIV_coord_from_free_LIV_coord <- vector_free_LIV_coord + ((vector_free_VSR_coord - vector_free_LIV_coord)/abs(vector_free_VSR_coord - vector_free_LIV_coord))
            
            logical_is_valid <- 
              (which(b1$chr == chr & # IR (short) junction
                       b1$start <= min(c(vector_free_VSR_coord, vector_IR_LIV_coord_from_free_LIV_coord)) + 1 &
                       b1$start >= min(c(vector_free_VSR_coord, vector_IR_LIV_coord_from_free_LIV_coord)) - 1 &
                       b1$end <= max(c(vector_free_VSR_coord, vector_IR_LIV_coord_from_free_LIV_coord)) + 1 &
                       b1$end >= max(c(vector_free_VSR_coord, vector_IR_LIV_coord_from_free_LIV_coord)) - 1) %>% length > 0)
          }
          
          return(logical_is_valid)
          
        } )
        
        # return vector of valid SJs 
        vector_row_indices_valid_SJs <- which(vector_logical_splice_event_exists_in_SJ == TRUE)
        
        return(vector_row_indices_valid_SJs)
        
      } )
    
    return(vector_logical_splice_event_exists_in_SJ)
    
  }, .progress = TRUE )

names(list_row_indices_valid_according_to_SJ_existence) <- tibble_combined_mapping_info$condition_names %>% unique %>% na.omit

save(list_row_indices_valid_according_to_SJ_existence, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_row_indices_valid_according_to_SJ_existence.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "list_row_indices_valid_according_to_SJ_existence.Rlist", sep = ""))

# plan(list(tweak(multiprocess, workers = 4),
#           tweak(multiprocess, workers = 1),
#           tweak(multiprocess, workers = 1)))

# extract the invalid row indices from id. 
# we need invalid because we have to set the invalid row indices to 0
list_row_indices_doesnt_exist_in_SJ <- purrr::map2(
  .x = list_row_indices_valid_according_to_SJ_existence,
  .y = 1:length(list_row_indices_valid_according_to_SJ_existence),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_row_indices_valid_according_to_SJ_existence[[1]]
    ###########
    
    cat(a2, "\n")
    
    # get all the row indices across all chromosomes
    vector_valid_row_indices_for_all_chr <- purrr::map2(
      .x = a1,
      .y = list_tibble_VSR_alt_exon_info_split_by_chr[names(a1)], 
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- list_tibble_VSR_alt_exon_info_split_by_chr[names(a1)] %>% .[[1]]
        ###########
        
        vector_ids_valid_for_current_chr <- b2[b1, "id"] %>% unlist
        
        return(vector_ids_valid_for_current_chr)
        
      } ) %>% unlist
    
    vector_invalid_row_indices_for_all_chr <- setdiff(1:nrow(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids), vector_valid_row_indices_for_all_chr)
    
    return(vector_invalid_row_indices_for_all_chr)
    
  } )

# subset the wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids by condition_names
list_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_subset_by_condition_names <- purrr::map(
  .x = tibble_combined_mapping_info$condition_names %>% unique %>% na.omit,
  .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains(paste(.x, "_", sep = "")))
) %>% set_names(nm = tibble_combined_mapping_info$condition_names %>% unique %>% na.omit)

# set the PSI and numerator to 0 for ALL invalid rows
list_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_subset_by_condition_names <- purrr::pmap(
  .l = list(
    "a1" = list_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_subset_by_condition_names,
    "a2" = list_row_indices_doesnt_exist_in_SJ,
    "a3" = 1:length(list_row_indices_doesnt_exist_in_SJ)
  ),
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_subset_by_condition_names[[1]]
    # a2 <- list_row_indices_doesnt_exist_in_SJ[[1]]
    # a3 <- names(list_row_indices_doesnt_exist_in_SJ) %>% .[[1]]
    ###########
    
    cat(a3, "\n")
    
    # set numerator and absolute.psi to zero
    tibble_return <- a1
    
    tibble_return[a2, grep(x = colnames(a1), pattern = "(absolute\\.psi)|(numerator)")] <- 0
    
    return(tibble_return)
    
  } )

# reduce and write final table
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- dplyr::bind_cols(
  wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids[, colnames(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids) %>% .[!grepl(x = ., pattern = "(numerator)|(absolute)|(no\\_repliccates)|(passes\\_read)|(denominator)|(replicates)")]],
  list_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_subset_by_condition_names %>% purrr::reduce(dplyr::bind_cols)
)

data.table::fwrite(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# filter by number of zeroes
plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 1)))

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

tibble_matrix_dexseq_absolute_psi <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))

vector_rowids_with_all_zero_psi <- future_apply(tibble_matrix_dexseq_absolute_psi, MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) == length(X) } ) %>% unlist %>% which

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ[setdiff((1:nrow(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ)), vector_rowids_with_all_zero_psi), ]

data.table::fwrite(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## export info for gene name reannotation and poison exon finder

```{r}

# extract the unique LIVs for re-annotation and save. 
## because of the sheer size, we will be doing this in another instance. 
tibble_unique_LIV_info <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed %>%
  dplyr::distinct(unprocessed_id, exon_number, event_region, LIV_exon_coords, alternative_exon_coords, splicemode) %>%
  dplyr::mutate("chr" = gsub(x = event_region, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\1"),
                
                "VSR_start" = gsub(x = event_region, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\2"),
                "VSR_end" = gsub(x = event_region, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\3"),
                
                "alternative_exon_start" = gsub(x = alternative_exon_coords, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\2"),
                "alternative_exon_end" = gsub(x = alternative_exon_coords, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\3"),
                
                "LIV_exon_starts" = gsub(x = LIV_exon_coords, pattern = "([0-9]|X|Y|MT)\\:", replacement = "") %>% gsub(pattern = "\\-(\\d+)", replacement = ""),
                "LIV_exon_ends" = gsub(x = LIV_exon_coords, pattern = "([0-9]|X|Y|MT)\\:", replacement = "") %>% gsub(pattern = "(\\d+)\\-", replacement = ""))

write.table(x = tibble_unique_LIV_info, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_unique_LIV_info_pooled_replicates.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# also write in format for processing in poison exon finder
tibble_unique_LIV_info_prepare_for_poison_exon_finder <- tibble_unique_LIV_info

tibble_unique_LIV_info_prepare_for_poison_exon_finder[tibble_unique_LIV_info_prepare_for_poison_exon_finder$splicemode == "IR", "LIV_exon_coords"] <- tibble_unique_LIV_info_prepare_for_poison_exon_finder[tibble_unique_LIV_info_prepare_for_poison_exon_finder$splicemode == "IR", "alternative_exon_coords"]

tibble_unique_LIV_info_prepare_for_poison_exon_finder <- tibble_unique_LIV_info_prepare_for_poison_exon_finder %>%
  dplyr::select(-alternative_exon_coords) %>%
  tibble::add_column("strand" = "*", "gene_name" = NA, "organism" = NA, "custom_identifier" = NA) %>%
  dplyr::mutate("alternative_exon_starts" = gsub(x = LIV_exon_coords, pattern = "(\\w+)\\:", replacement = "") %>% gsub(pattern = "\\-(\\d+)", replacement = ""),
                "alternative_exon_ends" = gsub(x = LIV_exon_coords, pattern = "(\\w+)\\:", replacement = "") %>% gsub(pattern = "(\\d+)\\-", replacement = ""))

write.table(x = tibble_unique_LIV_info_prepare_for_poison_exon_finder, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_unique_LIV_info_prepare_for_poison_exon_finder_pooled_replicates.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# import and summarise the poison exon finder table
tibble_unique_LIS_info_annotated_with_poison_exon_finder <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_poison_exon_finder_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble %>% dplyr::select(-strand)

tibble_poison_exon_finder_summary <- tibble_unique_LIS_info_annotated_with_poison_exon_finder %>% 
  dplyr::group_by(chr, VSR_start, VSR_end, alternative_exon_starts, alternative_exon_ends, splicemode) %>%
  dplyr::summarise("PEF_has_poison_region" = all(PTC_exists_in_alternative_exon == TRUE),
                   "PEF_has_frameshift" = all(has_frameshift == TRUE))

tibble_poison_exon_finder_summary <- tibble_poison_exon_finder_summary %>% 
  dplyr::rename("LIV_exon_starts" = "alternative_exon_starts",
                "LIV_exon_ends" = "alternative_exon_ends")

data.table::fwrite(x = tibble_poison_exon_finder_summary, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_poison_exon_finder_summary.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## re-label gene names with reference

GOAL: re-annotation of HGNC gene symbols, strand, make room for NMD

match against the reference, this incl. gene name, strand, first/last exon

STRATEGY FOR NON-IR: take the gene/transcript with the greatest number of common vertices
STRATEGY FOR IR: keep filtering the reference GTF according to the co-ordinates of the VSR -> LIV until there's nothing left. Take the last entry 

### list-ify the reference GTF by chromosome

IMPORTANT NOTE: in order for this to work, you must restart R in between multicore runs.

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

tibble_unique_LIV_info <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_unique_LIV_info_pooled_replicates.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_ref_gtf <- rtracklayer::import("/mnt/LTS/reference_data/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMD_PTC_E4.gtf") %>% 
  as_tibble %>% 
  dplyr::mutate_if(is.factor, as.character)

list_ref_gtf_by_chr <- tibble_ref_gtf %>%
  dplyr::group_split(seqnames) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$seqnames %>% unique))

```

### non-IR LIVs

```{r}

list_unique_LIV_info_non_IR_only <- tibble_unique_LIV_info[tibble_unique_LIV_info$splicemode != "IR", ] %>%
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique)) %>%
  purrr::map(~.x %>% array_tree())

# get common chromosomes
vector_chr_in_common <- intersect(names(list_unique_LIV_info_non_IR_only), names(list_ref_gtf_by_chr))

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4)))

suppressMessages(suppressWarnings(

tibble_reannotated_LIV_info_non_IR_only <- furrr::future_pmap(
  .l = list(
    "a1" = list_unique_LIV_info_non_IR_only[vector_chr_in_common],
    "a2" = list_ref_gtf_by_chr[vector_chr_in_common],
    "a3" = vector_chr_in_common
  ), 
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_unique_LIV_info_non_IR_only[vector_chr_in_common] %>% .[[1]]
    # a2 <- list_ref_gtf_by_chr[vector_chr_in_common] %>% .[[1]]
    # a3 <- vector_chr_in_common[[1]]
    ###########
    
    cat("L2:", a3, "\n")
    
    L1_tibble_ref_gtf_exon_only <- a2 %>% dplyr::filter(type == "exon")
    
    list_L1_results <- furrr::future_imap(
      .x = a1,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[978]]
        ###########
        
        cat("L2:", b2, "\n")
        
        # get a vertex pool. 
        # firstly get rid of duplicated coordinates. this means A3/5SS. 
        # then split coords into exon starts and exon ends
        vector_vertex_pool <- c(b1$VSR_start %>% type.convert(as.is = TRUE), 
                                b1$VSR_end %>% type.convert(as.is = TRUE), 
                                b1$LIV_exon_starts %>% strsplit(split = "\\;") %>% unlist %>% type.convert(as.is = TRUE), 
                                b1$LIV_exon_ends %>% strsplit(split = "\\;") %>% unlist %>% type.convert(as.is = TRUE)) %>% sort

        # construct a diff table to check for co-ordinate proximity
        ## this is to handle tolerance between VSRs and alternative exon coords.
        tibble_vertex_diffs <- tibble("vector_vertex_pool" = vector_vertex_pool, "diff" = c(vector_vertex_pool[1:(length(vector_vertex_pool) - 1)] - vector_vertex_pool[2:length(vector_vertex_pool)], NA))
        
        # get nonduplicated vertices
        # vector_nonduplicated_vertices <- vector_vertex_pool[vector_vertex_pool == vector_vertex_pool[duplicated(vector_vertex_pool) == FALSE]]
        vector_nonduplicated_vertices <- tibble_vertex_diffs[which(tibble_vertex_diffs$diff %>% abs > 1), ] %>% .$vector_vertex_pool %>% sort
        
        # filter for nonduplicated vertices.
        # VSR start becomes LIV exon end; VSR end becomes LIV exon start.
        # these will be the coords used to match ref gtf starts/ends.
        vector_exon_starts <- c(intersect(b1$VSR_end %>% type.convert(as.is = TRUE), vector_nonduplicated_vertices) + 1, 
                                intersect(b1$LIV_exon_starts %>% strsplit(split = "\\;") %>% unlist %>% type.convert(as.is = TRUE), vector_nonduplicated_vertices))
        
        vector_exon_ends <- c(intersect(b1$VSR_start %>% type.convert(as.is = TRUE), vector_nonduplicated_vertices) - 1, 
                              intersect(b1$LIV_exon_ends %>% strsplit(split = "\\;") %>% unlist %>% type.convert(as.is = TRUE), vector_nonduplicated_vertices))
        
        # filter ref GTF coords for each vertex
        # count the number of times each ENST ID or gene appears.
        list_ref_gtf_entries_matched_to_vertices <- list(
          "LIV_exon_starts" = purrr::map(.x = c(vector_exon_starts),
                         .f = ~L1_tibble_ref_gtf_exon_only[L1_tibble_ref_gtf_exon_only$start >= ((.x %>% type.convert(as.is = TRUE)) - 1) & L1_tibble_ref_gtf_exon_only$start <= ((.x %>% type.convert(as.is = TRUE)) + 1), ]),
          "LIV_exon_ends" = purrr::map(.x = vector_exon_ends,
                         .f = ~L1_tibble_ref_gtf_exon_only[L1_tibble_ref_gtf_exon_only$end >= ((.x %>% type.convert(as.is = TRUE)) - 1) & L1_tibble_ref_gtf_exon_only$end <= ((.x %>% type.convert(as.is = TRUE)) + 1), ])
        ) 
        
        tibble_gene_name_and_ENST_summary <- list_ref_gtf_entries_matched_to_vertices %>% 
          flatten %>%
          purrr::map(~tibble("ENSG_ids" = .x$gene_id %>% unique %>% paste(collapse = ";"), "ENST_ids" = .x$transcript_id %>% unique %>% paste(collapse = ";"))) %>%
          rbindlist %>% as_tibble
        
        # get frequency tallies
        tibble_ENSG_tally <- tibble("ENSG_ids" = tibble_gene_name_and_ENST_summary$ENSG_ids %>% strsplit(split = "\\;") %>% unlist) %>%
          dplyr::group_by(ENSG_ids) %>%
          dplyr::summarise("tally" = n())
        
        # tibble_ENST_tally <- tibble("ENST_ids" = tibble_gene_name_and_ENST_summary$ENST_ids %>% strsplit(split = "\\;") %>% unlist) %>%
        #   dplyr::group_by(ENST_ids) %>%
        #   dplyr::summarise("tally" = n())
        
        ## preallocate outputs
        final_gene_name <- NA
        matched_strand <- NA
        vector_ENST_ids_perfectly_matched <- NA
        result_NMD_candidate <- NA
        result_first_last_exon <- NA
        result_poison_exon_candidate <- NA
        result_contains_PTC <- NA
        result_matched_transcript_type <- NA
        result_matched_transcript_biotype <- NA
        
        # determine the final ENSG and ENST ids
        vector_final_ENSG_ids <- tibble_ENSG_tally[tibble_ENSG_tally$tally == max(tibble_ENSG_tally$tally), ] %>% .$ENSG_ids
        # vector_final_ENST_ids <- tibble_ENST_tally[tibble_ENST_tally$tally == max(tibble_ENST_tally$tally), ] %>% .$ENST_ids
        
        if (vector_final_ENSG_ids %>% length > 0) {
        
        matched_strand <- L1_tibble_ref_gtf_exon_only[L1_tibble_ref_gtf_exon_only$gene_id %in% vector_final_ENSG_ids, ] %>% .$strand %>% unique %>% paste(collapse = ";")
        
        final_gene_name <- L1_tibble_ref_gtf_exon_only[L1_tibble_ref_gtf_exon_only$gene_id %in% vector_final_ENSG_ids, ] %>% .$gene_name %>% unique %>% mixedsort %>% paste(collapse = ";")
        
        # calculate whether all matchable vertices have been matched
        flag_all_vertices_matched <- (list_ref_gtf_entries_matched_to_vertices %>% flatten %>% purrr::discard(.p = ~nrow(.x) == 0) %>% length) == length(c(vector_exon_starts, vector_exon_ends))
        
        # if all vertices matched, then narrow down the ENST ID by matching the VSR and exon battery to the end.
        # otherwise, we stop here and we output the gene id because there is no match to the reference ENSTs
        # additionally, we have to take cases because the matching process for A3/5SS will be different.
        
        # if all vertices were matched, then it makes sense to have a matched ENST id. otherwise, the matching process is only useful for determining the gene name.
        # under these circumstances, we can also get the ENST ids, NMD status and poison exon status.
        # NMD status: per ENST id basis
        # first_or_last_exon: per ENST id basis for the whole battery
        # poison_exon_candidate: on a per ENST id basis for the whole battery
        # contains_PTC: on a per ENST id basis for the whole battery
        
        if (flag_all_vertices_matched == TRUE & !b1$splicemode %in% c("A3SS", "A5SS")) {
          
          # match VSR and exon battery.
          ## match VSR first
          list_ref_exons_matching_VSR <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = b1$VSR_start %>% type.convert(as.is = TRUE), query_end = b1$VSR_end %>% type.convert(as.is = TRUE), query_strand = "*", tibble_gtf_table = L1_tibble_ref_gtf_exon_only, tolerance_left = 1, tolerance_right = 1, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = FALSE, return_type = "exon")
          
          ## construct exon start/ends
          list_battery_coords <- purrr::map2(.x = b1$LIV_exon_starts %>% strsplit(split = "\\;") %>% unlist, .y = b1$LIV_exon_ends %>% strsplit(split = "\\;") %>% unlist, .f = ~c(.x, .y) %>% type.convert(as.is = TRUE))
          
          ## match each element to reference gtf exons
          list_ref_exons_matched_to_battery <- purrr::map(.x = list_battery_coords, .f = ~extract_matching.exons(query_chr = b1$chr, query_start = .x[1], query_end = .x[2], query_strand = "*", tibble_gtf_table = L1_tibble_ref_gtf_exon_only, tolerance_left = 1, tolerance_right = 1, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon"))
          
          ## get all the ENST_ids matched by all.
          vector_ENST_ids_perfectly_matched <- intersect(list_ref_exons_matching_VSR %>% names %>% unique, list_ref_exons_matched_to_battery %>% rbindlist %>% as_tibble %>% .$transcript_id %>% unique) %>% mixedsort
          
          if (vector_ENST_ids_perfectly_matched %>% length > 0) {
            
            ## proceed with a reduced set of transcripts
            tibble_matched_ENST_only <- a2[a2$transcript_id %in% vector_ENST_ids_perfectly_matched, ]
            
            ## get the exons matched to the battery
            tibble_ref_exons_matched_to_battery <- list_ref_exons_matched_to_battery %>% rbindlist %>% as_tibble %>% .[.$transcript_id %in% vector_ENST_ids_perfectly_matched, ]
            
            result_NMD_candidate <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~a2[a2$transcript_id == .x, ] %>% .$NMD_candidate %>% unique) %>% unlist %>% paste(collapse = ";")
            
            result_first_last_exon <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~tibble_ref_exons_matched_to_battery[tibble_ref_exons_matched_to_battery$transcript_id == .x, ] %>% .$first_or_last_exon %>% unique %>% paste(collapse = ",")) %>% unlist %>% mixedsort %>% paste(collapse = ";")
            
            result_poison_exon_candidate <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~tibble_ref_exons_matched_to_battery[tibble_ref_exons_matched_to_battery$transcript_id == .x, ] %>% .$poison_exon_candidate %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
            result_contains_PTC <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~tibble_ref_exons_matched_to_battery[tibble_ref_exons_matched_to_battery$transcript_id == .x, ] %>% .$contains_PTC %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
            result_matched_transcript_type <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~a2[a2$transcript_id == .x, ] %>% .$type %>% unique %>% sort %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
            result_matched_transcript_biotype <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~a2[a2$transcript_id == .x, ] %>% .$transcript_biotype %>% unique %>% sort %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";") %>% type.convert(as.is = TRUE)
            
          }
          
        } else if (flag_all_vertices_matched == TRUE & b1$splicemode %in% c("A3SS", "A5SS")) {
          
          # match the remaining vertex coords. provided the tolerance accounts for all possible errors, these will be the A3/5SS junction coords.
          list_ref_exons_matching_A3.5SS_junction <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = vector_nonduplicated_vertices %>% min, query_end = vector_nonduplicated_vertices %>% max, query_strand = "*", tibble_gtf_table = L1_tibble_ref_gtf_exon_only, tolerance_left = 1, tolerance_right = 1, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon")
          
          if (list_ref_exons_matching_A3.5SS_junction %>% length > 0) {
            
            vector_ENST_ids_perfectly_matched <- list_ref_exons_matching_A3.5SS_junction %>% names %>% unique %>% mixedsort
            
            ## proceed with a reduced set of transcripts
            tibble_matched_ENST_only <- a2[a2$transcript_id %in% vector_ENST_ids_perfectly_matched, ]
            
            ## get the exons matched to the junction
            tibble_ref_exons_matched_to_junction <- list_ref_exons_matching_A3.5SS_junction %>% rbindlist %>% as_tibble
            
            result_NMD_candidate <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~a2[a2$transcript_id == .x, ] %>% .$NMD_candidate %>% unique) %>% unlist %>% paste(collapse = ";")
            
            result_first_last_exon <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~tibble_ref_exons_matched_to_junction[tibble_ref_exons_matched_to_junction$transcript_id == .x, ] %>% .$first_or_last_exon %>% unique %>% paste(collapse = ",")) %>% unlist %>% mixedsort %>% paste(collapse = ";")
            
            result_poison_exon_candidate <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~tibble_ref_exons_matched_to_junction[tibble_ref_exons_matched_to_junction$transcript_id == .x, ] %>% .$poison_exon_candidate %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
            result_contains_PTC <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~tibble_ref_exons_matched_to_junction[tibble_ref_exons_matched_to_junction$transcript_id == .x, ] %>% .$contains_PTC %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
            result_matched_transcript_type <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~a2[a2$transcript_id == .x, ] %>% .$type %>% unique %>% sort %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
            result_matched_transcript_biotype <- purrr::map(.x = vector_ENST_ids_perfectly_matched, .f = ~a2[a2$transcript_id == .x, ] %>% .$transcript_biotype %>% unique %>% sort %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
            
          } 
          
        }
        
        }
        
        return(purrr::splice(b1,
                             "matched_gene_names" = final_gene_name,
                             "matched_strand" = matched_strand,
                             "matched_ENST_ids" = vector_ENST_ids_perfectly_matched %>% paste(collapse = ";"), 
                             "ENST_is_NMD_candidate" = result_NMD_candidate,
                             "battery_affects_first_last_exon" = result_first_last_exon,
                             "battery_contains_poison_exon_candidate" = result_poison_exon_candidate,
                             "battery_contains_PTC" = result_contains_PTC,
                             "matched_transcript_type" = result_matched_transcript_type,
                             "matched_transcript_biotype" = result_matched_transcript_biotype
                             ) %>% as_tibble)
        
      } ) %>% rbindlist %>% as_tibble
        
  }, .progress = TRUE) %>% rbindlist %>% as_tibble

))

save(tibble_reannotated_LIV_info_non_IR_only, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_reannotated_LIV_info_non_IR_only.tibble", sep = ""), compress = FALSE)

```

### IR LIVs

A bit more complicated. 

STRATEGY: 
1. if no match, match the IR junction to obtain the gene name AND (IMPORTANTLY) to determine 5' 3' UTR if the whole intron is found out to be a retained_intron biotype.
2. extract the GTF entries with the gene name we found
3. use reduced GTF to find exons fully encompassing the IR junction.
4. if there are transcripts with these kind of exons, then filter for the ones with the highest number of common vertices.

```{r}

list_unique_LIV_info_IR_only <- tibble_unique_LIV_info[tibble_unique_LIV_info$splicemode == "IR", ] %>%
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique)) %>%
  purrr::map(~.x %>% array_tree())

# get common chromosomes
vector_chr_in_common <- intersect(names(list_unique_LIV_info_IR_only), names(list_ref_gtf_by_chr))

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4)))

suppressMessages(suppressWarnings(
  
  tibble_reannotated_LIV_info_IR_only <- furrr::future_pmap(
    .l = list(
      "a1" = list_unique_LIV_info_IR_only[vector_chr_in_common],
      "a2" = list_ref_gtf_by_chr[vector_chr_in_common],
      "a3" = vector_chr_in_common
    ), 
    .f = function(a1, a2, a3) {
      
      # DEBUG ###
      # a1 <- list_unique_LIV_info_IR_only[vector_chr_in_common] %>% .[[1]]
      # a2 <- list_ref_gtf_by_chr[vector_chr_in_common] %>% .[[1]]
      # a3 <- vector_chr_in_common[[1]]
      ###########
      
      # cat("L2:", a3, "\n")
      
      list_L1_results <- furrr::future_imap(
        .x = a1,
        .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- a1[[30]]
          ###########
          
          # cat("L2:", b2, "\n")
          
          ## preallocate outputs
          final_gene_name <- NA
          matched_strand <- NA
          vector_final_ENSG_ids <- NA
          vector_final_ENST_ids <- NA
          result_NMD_candidate <- NA
          result_first_last_exon <- NA
          result_poison_exon_candidate <- NA
          result_contains_PTC <- NA
          result_matched_transcript_type <- NA
          result_matched_transcript_biotype <- NA
          
          # NOW WE TAKE THE MOST LIKELY OF THESE TRANSCRIPTS BASED ON THE VERTICES PROVIDED
          vector_exon_starts <- c(b1$VSR_start %>% type.convert(as.is = TRUE),
                                  b1$alternative_exon_end %>% type.convert(as.is = TRUE) + 1)
          
          vector_exon_ends <- c(b1$VSR_end %>% type.convert(as.is = TRUE), 
                                b1$alternative_exon_start %>% type.convert(as.is = TRUE) - 1)
          
          ## match the IR junction
          list_ref_gtf_matched_to_IR_junction <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = b1$alternative_exon_start %>% type.convert(as.is = TRUE), query_end = b1$alternative_exon_end %>% type.convert(as.is = TRUE), query_strand = "*", tibble_gtf_table = a2, tolerance_left = 1, tolerance_right = 1, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon")
          
          if (list_ref_gtf_matched_to_IR_junction %>% length > 0) {
            
            vector_IR_junction_matched_ENSG_ids <- list_ref_gtf_matched_to_IR_junction %>% rbindlist %>% as_tibble %>% .$gene_id %>% unique
            
            vector_final_ENSG_ids <- list_ref_gtf_matched_to_IR_junction %>% rbindlist %>% as_tibble %>% .$gene_name %>% unique
            
            matched_strand <- a2[a2$gene_id %in% vector_final_ENSG_ids, ] %>% .$strand %>% unique %>% paste(collapse = ";")
            
            final_gene_name <- a2[a2$gene_id %in% vector_final_ENSG_ids, ] %>% .$gene_name %>% unique %>% mixedsort %>% paste(collapse = ";")
            
            tibble_reduced_gtf <- a2[which(a2$gene_id %in% vector_IR_junction_matched_ENSG_ids), ]
            
            tibble_reduced_gtf_exons_encompassing_IR_junction <- tibble_reduced_gtf[tibble_reduced_gtf$start <= (b1$alternative_exon_start %>% type.convert(as.is = TRUE) + 1) & tibble_reduced_gtf$end >= (b1$alternative_exon_end %>% type.convert(as.is = TRUE) - 1) & tibble_reduced_gtf$type == "exon", ]
            
            if (tibble_reduced_gtf_exons_encompassing_IR_junction %>% nrow > 0) {
              
              # filter ref GTF coords for each vertex
              # count the number of times each ENST ID or gene appears.
              list_reduced_gtf_exons_encompassing_IR_junction_entries_matched_to_vertices <- list(
                "LIV_exon_starts" = purrr::map(.x = c(vector_exon_starts),
                                               .f = ~tibble_reduced_gtf_exons_encompassing_IR_junction[tibble_reduced_gtf_exons_encompassing_IR_junction$start >= ((.x %>% type.convert(as.is = TRUE)) - 1) & tibble_reduced_gtf_exons_encompassing_IR_junction$start <= ((.x %>% type.convert(as.is = TRUE)) + 1), ]),
                "LIV_exon_ends" = purrr::map(.x = vector_exon_ends,
                                             .f = ~tibble_reduced_gtf_exons_encompassing_IR_junction[tibble_reduced_gtf_exons_encompassing_IR_junction$end >= ((.x %>% type.convert(as.is = TRUE)) - 1) & tibble_reduced_gtf_exons_encompassing_IR_junction$end <= ((.x %>% type.convert(as.is = TRUE)) + 1), ])
              ) 
              
              tibble_gene_name_and_ENST_summary <- list_reduced_gtf_exons_encompassing_IR_junction_entries_matched_to_vertices %>% 
                flatten %>%
                purrr::map(~tibble("ENSG_ids" = .x$gene_id %>% unique %>% paste(collapse = ";"), "ENST_ids" = .x$transcript_id %>% unique %>% paste(collapse = ";"))) %>%
                rbindlist %>% as_tibble
              
              tibble_ENST_tally <- tibble("ENST_ids" = tibble_gene_name_and_ENST_summary$ENST_ids %>% strsplit(split = "\\;") %>% unlist) %>%
                dplyr::group_by(ENST_ids) %>%
                dplyr::summarise("tally" = n())
              
              # determine the final ENST ids
              vector_final_ENST_ids <- tibble_ENST_tally[tibble_ENST_tally$tally == max(tibble_ENST_tally$tally), ] %>% .$ENST_ids
              
              result_NMD_candidate <- purrr::map(.x = vector_final_ENST_ids, .f = ~a2[a2$transcript_id == .x, ] %>% .$NMD_candidate %>% unique) %>% unlist %>% paste(collapse = ";")
              
              result_first_last_exon <- purrr::map(.x = vector_final_ENST_ids, .f = ~tibble_reduced_gtf_exons_encompassing_IR_junction[tibble_reduced_gtf_exons_encompassing_IR_junction$transcript_id == .x, ] %>% .$first_or_last_exon %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
              
              result_poison_exon_candidate <- purrr::map(.x = vector_final_ENST_ids, .f = ~tibble_reduced_gtf_exons_encompassing_IR_junction[tibble_reduced_gtf_exons_encompassing_IR_junction$transcript_id == .x, ] %>% .$poison_exon_candidate %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
              
              result_contains_PTC <- purrr::map(.x = vector_final_ENST_ids, .f = ~tibble_reduced_gtf_exons_encompassing_IR_junction[tibble_reduced_gtf_exons_encompassing_IR_junction$transcript_id == .x, ] %>% .$contains_PTC %>% unique %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
              
              result_matched_transcript_type <- purrr::map(.x = vector_final_ENST_ids, .f = ~a2[a2$transcript_id == .x, ] %>% .$type %>% unique %>% sort %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
              
              result_matched_transcript_biotype <- purrr::map(.x = vector_final_ENST_ids, .f = ~a2[a2$transcript_id == .x, ] %>% .$transcript_biotype %>% unique %>% sort %>% paste(collapse = ",")) %>% unlist %>% paste(collapse = ";")
              
            }
            
          } else if (list_ref_gtf_matched_to_IR_junction %>% length == 0) {
            
            # filter ref GTF coords for each vertex
            # count the number of times each ENST ID or gene appears.
            list_ref_gtf_entries_matched_to_vertices <- list(
              "LIV_exon_starts" = purrr::map(.x = c(vector_exon_starts),
                                             .f = ~a2[a2$start >= ((.x %>% type.convert(as.is = TRUE)) - 1) & a2$start <= ((.x %>% type.convert(as.is = TRUE)) + 1), ]),
              "LIV_exon_ends" = purrr::map(.x = vector_exon_ends,
                                           .f = ~a2[a2$end >= ((.x %>% type.convert(as.is = TRUE)) - 1) & a2$end <= ((.x %>% type.convert(as.is = TRUE)) + 1), ])
            ) 
            
            tibble_gene_name_and_ENST_summary <- list_ref_gtf_entries_matched_to_vertices %>% 
              flatten %>%
              purrr::map(~tibble("ENSG_ids" = .x$gene_id %>% unique %>% paste(collapse = ";"), "ENST_ids" = .x$transcript_id %>% unique %>% paste(collapse = ";"))) %>%
              rbindlist %>% as_tibble
            
            # get frequency tallies
            tibble_ENSG_tally <- tibble("ENSG_ids" = tibble_gene_name_and_ENST_summary$ENSG_ids %>% strsplit(split = "\\;") %>% unlist) %>%
              dplyr::group_by(ENSG_ids) %>%
              dplyr::summarise("tally" = n())
            
            # determine the final ENSG ids
            vector_final_ENSG_ids <- tibble_ENSG_tally[tibble_ENSG_tally$tally == max(tibble_ENSG_tally$tally), ] %>% .$ENSG_ids
            
            matched_strand <- a2[a2$gene_id %in% vector_final_ENSG_ids, ] %>% .$strand %>% unique %>% paste(collapse = ";")
            
            final_gene_name <- a2[a2$gene_id %in% vector_final_ENSG_ids, ] %>% .$gene_name %>% unique %>% mixedsort %>% paste(collapse = ";")
            
          }
          
          return(purrr::splice(b1,
                               "matched_gene_names" = final_gene_name,
                               "matched_strand" = matched_strand,
                               "matched_ENST_ids" = vector_final_ENST_ids %>% paste(collapse = ";"), 
                               "ENST_is_NMD_candidate" = result_NMD_candidate,
                               "battery_affects_first_last_exon" = result_first_last_exon,
                               "battery_contains_poison_exon_candidate" = result_poison_exon_candidate,
                               "battery_contains_PTC" = result_contains_PTC,
                               "matched_transcript_type" = result_matched_transcript_type,
                               "matched_transcript_biotype" = result_matched_transcript_biotype
          ) %>% as_tibble)
          
        } ) %>% rbindlist %>% as_tibble
      
    }, .progress = TRUE) %>% rbindlist %>% as_tibble
  
) )

save(tibble_reannotated_LIV_info_IR_only, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_reannotated_LIV_info_IR_only.tibble", sep = ""), compress = FALSE)

```

### merge non-IR and IR tibbles

```{r}
load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_reannotated_LIV_info_IR_only.tibble", sep = ""))

load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_reannotated_LIV_info_non_IR_only.tibble", sep = ""))

tibble_merged_non_IR_and_IR_annotations <- dplyr::bind_rows(tibble_reannotated_LIV_info_non_IR_only, tibble_reannotated_LIV_info_IR_only)

write.table(x = tibble_merged_non_IR_and_IR_annotations, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_merged_non_IR_and_IR_annotations_pooled_replicates.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

tibble_merged_non_IR_and_IR_annotations <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_merged_non_IR_and_IR_annotations_pooled_replicates.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

plan(multiprocess)
options(mc.cores = 12)

# summarise the annoatations
tibble_merged_non_IR_and_IR_annotations_summarised <- tibble_merged_non_IR_and_IR_annotations %>% 
  dplyr::mutate("NMD_candidate_all_matched_transcripts" = furrr::future_map(.x = `ENST_is_NMD_candidate` %>% strsplit(split = "\\;"), .f = ~all(.x %>% na.omit == "TRUE") & .x %>% na.omit %>% length != 0, .progress = TRUE) %>% unlist,
                "first_exon_any_matched_transcript" = furrr::future_map(.x = `battery_affects_first_last_exon` %>% strsplit(split = "\\;"), .f = ~any(.x %>% na.omit == "first_exon"), .progress = TRUE) %>% unlist,
                "first_exon_all_matched_transcript" = furrr::future_map(.x = `battery_affects_first_last_exon` %>% strsplit(split = "\\;"), .f = ~all(.x %>% na.omit == "first_exon") & .x %>% na.omit %>% length != 0, .progress = TRUE) %>% unlist,
                "last_exon_any_matched_transcript" = furrr::future_map(.x = `battery_affects_first_last_exon` %>% strsplit(split = "\\;"), .f = ~any(.x %>% na.omit == "last_exon"), .progress = TRUE) %>% unlist,
                "last_exon_all_matched_transcript" = furrr::future_map(.x = `battery_affects_first_last_exon` %>% strsplit(split = "\\;"), .f = ~all(.x %>% na.omit == "last_exon") & .x %>% na.omit %>% length != 0, .progress = TRUE) %>% unlist,
                "contains_poison_exon_candidate_all_matched_transcripts" = furrr::future_map(.x = `battery_contains_poison_exon_candidate` %>% strsplit(split = "\\;"), .f = ~all(.x %>% na.omit == "TRUE") & .x %>% na.omit %>% length != 0, .progress = TRUE) %>% unlist,
                "contains_PTC_all_matched_transcripts" = furrr::future_map(.x = `battery_contains_PTC` %>% strsplit(split = "\\;"), .f = ~all(.x %>% na.omit == "TRUE") & .x %>% na.omit %>% length != 0, .progress = TRUE) %>% unlist) %>% 
  dplyr::select(-ENST_is_NMD_candidate, -battery_affects_first_last_exon, -battery_contains_poison_exon_candidate, -battery_contains_PTC)
  
data.table::fwrite(x = tibble_merged_non_IR_and_IR_annotations_summarised, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_merged_non_IR_and_IR_annotations_summarised.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

# export for 3FT

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

tibble_merged_non_IR_and_IR_annotations_summarised <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_merged_non_IR_and_IR_annotations_summarised.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_main_info_with_annotations <- dplyr::left_join(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed, tibble_merged_non_IR_and_IR_annotations_summarised)

# export for 3FT - LIS
data.table::fwrite(x = wide_tibble_main_info_with_annotations %>% dplyr::select(event_region, LIV_exon_coords, splicemode, matched_gene_names, unprocessed_id) %>% dplyr::rename("gene_name" = "matched_gene_names", "custom_identifier" = "unprocessed_id", "alternative_exon_coords" = "LIV_exon_coords") %>% dplyr::mutate("custom_identifier" = paste("atlas_totalrna_psisigma_", `custom_identifier`, sep = ""), "organism" = "homo_sapiens"), file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_LIS_export_for_3FT.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# export for 3FT - VSR
data.table::fwrite(x = wide_tibble_main_info_with_annotations %>% dplyr::select(event_region, splicemode, matched_gene_names, matched_strand, unprocessed_id) %>% dplyr::mutate("chr" = gsub(x = event_region, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\1"), "start" = gsub(x = event_region, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\2"), "end" = gsub(x = event_region, pattern = "(.*)\\:(\\d+)\\-(.*)", replacement = "\\3")) %>% dplyr::rename("gene_name" = "matched_gene_names", "custom_identifier" = "unprocessed_id", "strand" = "matched_strand") %>% dplyr::select(-event_region) %>% dplyr::mutate("custom_identifier" = paste("atlas_totalrna_psisigma_", `custom_identifier`, sep = ""), "organism" = "homo_sapiens") %>% split_delimited_column_in_table(input_table = ., target_colname = "strand", split = ";", columns_to_deduplicate = NULL), file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_VSR_junctions_export_for_3FT.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

# Dimensionality reduction

## homemade PCA, t-SNE and UMAP

```{r}

# cast tibble into a matrix tibble
# list_long_tibble_processed_sorted_tibbles_split_by_sample_name <- long_tibble_processed_sorted_tibbles %>% 
#   dplyr::select(event_region, alternative_exon_coords, LIV_exon_coords, contains("combined_absolute.psi"), contains("sample_absolute.psi"), sample_name) %>%
#   dplyr::group_split(sample_name) %>%
#   purrr::map(.x = ., .f = function(a1) {
#     tibble_output <- a1
#     
#     colnames(tibble_output) <- gsub(x = colnames(tibble_output), pattern = "sample_absolute", replacement = paste(a1$sample_name %>% unique, "_sample_absolute", sep = ""))
#     
#     colnames(tibble_output) <- gsub(x = colnames(tibble_output), pattern = "_sample_absolute.psi_", replacement = "|r")
#     
#     return(tibble_output %>% dplyr::select(-sample_name))
#     
#     } )
# 
# wide_tibble_processed_sorted_tibbles <- list_long_tibble_processed_sorted_tibbles_split_by_sample_name %>% 
#   purrr::reduce(dplyr::inner_join, by = c("event_region", "alternative_exon_coords", "LIV_exon_coords", "combined_absolute.psi_1", "combined_absolute.psi_2", "combined_absolute.psi_3", "combined_absolute.psi_4", "combined_absolute.psi_5", "combined_absolute.psi_6"))
# 
# wide_tibble_matrix_processed_sorted_tibbles <- wide_tibble_processed_sorted_tibbles %>%
#   dplyr::select(-event_region, -alternative_exon_coords, -LIV_exon_coords, -contains("combined"))
  
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as.data.frame

df_matrix_absolute_psi_in_sample_replicate_format <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed %>% dplyr::select(contains("absolute.psi"))

temp_condition_names <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed %>% dplyr::select(contains("absolute.psi")) %>% colnames %>% gsub(x = ., pattern = "_absolute.psi", replacement = "")

temp_replicate_names <- dplyr::left_join(
  wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed %>% dplyr::select(contains("absolute.psi")) %>% colnames %>% gsub(x = ., pattern = "_absolute.psi", replacement = "") %>% tibble::enframe(value = "condition_names", name = NULL), 
  tibble_combined_mapping_info %>% dplyr::arrange(RNA_number) %>% dplyr::group_by(RNA_number) %>% dplyr::mutate("replicatenumber" = 1:n())) %>% .$replicatenumber

colnames(df_matrix_absolute_psi_in_sample_replicate_format) <- paste(temp_condition_names, "|", temp_replicate_names, sep = "")

df_matrix_absolute_psi_in_sample_replicate_format_with_na <- df_matrix_absolute_psi_in_sample_replicate_format
df_matrix_absolute_psi_in_sample_replicate_format_with_na[is.na(df_matrix_absolute_psi_in_sample_replicate_format_with_na)] <- 0

# PCA
# set.seed(8)
# plot_PCA_for_timepoint_and_replicate(matrixtable = df_matrix_absolute_psi_in_sample_replicate_format %>% na.omit, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = TRUE, legend_position = "none", PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_pooled_replicates_no_na", graph_title = "Total RNA/PSI-Sigma", width = 10, height = 10)

# set.seed(8)
# plot_PCA_for_timepoint_and_replicate(matrixtable = df_matrix_absolute_psi_in_sample_replicate_format_with_na, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = TRUE, legend_position = "none", PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_pooled_replicates_with_na", graph_title = "Total RNA/PSI-Sigma", width = 10, height = 10)

# UMAP
set.seed(8)
plot_UMAP_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = FALSE, legend_position = "none", centroid_labels = TRUE, point_size = 1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_pooled_replicates_no_na", graph_title = "Total RNA/PSI-Sigma", width = 40, height = 40)

set.seed(8)
plot_UMAP_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = FALSE, legend_position = "none", centroid_labels = TRUE, point_size = 1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_pooled_replicates_with_na", graph_title = "Total RNA/PSI-Sigma", width = 40, height = 40)

# set.seed(8)
# plot_UMAP_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = TRUE, legend_position = "none", centroid_labels = TRUE, point_size = 1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_replicates_pooled_replicates_no_na", graph_title = "Total RNA/PSI-Sigma w/ replicates", width = 40, height = 40)

# set.seed(8)
# plot_UMAP_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = TRUE, legend_position = "none", centroid_labels = TRUE, point_size = 1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_replicates_pooled_replicates_with_na", graph_title = "Total RNA/PSI-Sigma w/ replicates", width = 40, height = 40)

# tSNE
set.seed(8)
plot_tSNE_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = FALSE, legend_position = "none", centroid_labels = TRUE, point_size = 0.1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_pooled_replicates_no_na", graph_title = "Total RNA/PSI-Sigma", width = 40, height = 40)

set.seed(8)
plot_tSNE_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = FALSE, legend_position = "none", centroid_labels = TRUE, point_size = 0.1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_pooled_replicates_with_na", graph_title = "Total RNA/PSI-Sigma", width = 40, height = 40)

# set.seed(8)
# plot_tSNE_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = TRUE, legend_position = "none", centroid_labels = TRUE, point_size = 0.1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_replicates_pooled_replicates_no_na", graph_title = "Total RNA/PSI-Sigma w/ replicates", width = 40, height = 40)

# set.seed(8)
# plot_tSNE_for_timepoint_and_replicate(transposed_matrixtable = df_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t, timepoint_order = temp_condition_names, replicate_order = c("r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8"), plot_shapes = TRUE, legend_position = "none", centroid_labels = TRUE, point_size = 0.1, centroid_label_size = 1, PCA_depths_y = c(2, 3, 4), PCA_depths_x = c(1, 2, 3), save_dir = R_processing_results_dir, save_name = "total_RNA_psisigma_replicates_pooled_replicates_with_na", graph_title = "Total RNA/PSI-Sigma w/ replicates", width = 40, height = 40)

# edit the cluster legend tables
# separate the -2 from the condition names and then table join onto the sample information

## UMAP
tibble_raw_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_total_RNA_psisigma_pooled_replicates_with_na_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_UMAP_cluster_legend <- tibble_raw_UMAP_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number")

write.table(x = tibble_processed_UMAP_cluster_legend, file = paste(R_processing_results_dir, "UMAP_total_RNA_psisigma_pooled_replicates_with_na_cluster_legend.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

###

tibble_raw_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_total_RNA_psisigma_pooled_replicates_no_na_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_UMAP_cluster_legend <- tibble_raw_UMAP_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number")

write.table(x = tibble_processed_UMAP_cluster_legend, file = paste(R_processing_results_dir, "UMAP_total_RNA_psisigma_pooled_replicates_no_na_cluster_legend.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

## tSNE
tibble_raw_tsne_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "tSNE_total_RNA_psisigma_pooled_replicates_with_na_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_tsne_cluster_legend <- tibble_raw_tsne_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number")

write.table(x = tibble_processed_tsne_cluster_legend, file = paste(R_processing_results_dir, "tSNE_total_RNA_psisigma_pooled_replicates_with_na_cluster_legend.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

###

tibble_raw_tsne_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "tSNE_total_RNA_psisigma_pooled_replicates_no_na_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_tsne_cluster_legend <- tibble_raw_tsne_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number")

write.table(x = tibble_processed_tsne_cluster_legend, file = paste(R_processing_results_dir, "tSNE_total_RNA_psisigma_pooled_replicates_no_na_cluster_legend.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## scPhere

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

# export the PSI tables for scPhere analysis
data.table::fwrite(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% tibble::add_column("id" = 1:nrow(.), .before = 1), file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_for_scphere.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# write down the batch effect due to source
vector_numeric_batch_flag_source <- dplyr::left_join(
  tibble("condition_names" = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% colnames %>% gsub(pattern = "\\_absolute\\.psi", replacement = "")),
  tibble_combined_mapping_info
) %>% .$Source %>% as.factor %>% as.numeric 

write.table(x = vector_numeric_batch_flag_source - 1, file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_for_scphere_batch_flag_source.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

# get column indices for each sample type in order to export a tibble of each sample type
list_vector_column_subsetting_indices <- purrr::map(
    .x = c("tissue", "cell type", "cell line"), 
    .f = ~which(gsub(x = colnames(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed %>% dplyr::select(contains("absolute.psi")) %>% tibble::add_column("id" = 1:nrow(.), .before = 1) %>% dplyr::select(contains("absolute.psi"))), pattern = "_absolute\\.psi", replacement = "") %in% (tibble_combined_mapping_info[grep(x = tibble_combined_mapping_info$Type, pattern = .x), ] %>% .$condition_names))
) %>% set_names(nm = c("tissue", "cell type", "cell line"))



# write the PSI tables 
purrr::map2(
    .x = list_vector_column_subsetting_indices,
    .y = names(list_vector_column_subsetting_indices),
    .f = function(a1, a2) {
        
        # DEBUG ###
        a1 <- list_vector_column_subsetting_indices[[1]]
        a2 <- names(list_vector_column_subsetting_indices) %>% .[[1]]
        ###########
        
        L1_sft <- WGCNA::pickSoftThreshold(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[, a1] %>% t, powerVector = a1, verbose = 5, blockSize = 10000)
        
        write.table(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% tibble::add_column("id" = 1:nrow(.), .before = 1), file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering_psimatrixonly.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
        
        write.table(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[1:100000, a1] %>% tibble::add_column("id" = 1:nrow(.), .before = 1), file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering_psimatrixonly_", a2, "_test.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
        
    } )

# PROCESS SCPHERE RESULTS

library(rgl)
library(densitycut) # https://bitbucket.org/jerry00/densitycut_dev/src/master/
library(robustbase)

PlotSphere = function(x, cluster, col, density=FALSE, legend=FALSE) {
  if (missing(col)) {
    col = distinct.col
  }
  if (density == FALSE) {
    col.point = AssignLabelColor(col, cluster, 
                                 uniq.label = sort(unique(cluster)))
  } else {
    colours = colorRampPalette((brewer.pal(7, "YlOrRd")))(10)
    FUN = colorRamp(colours)
    
    cluster = (cluster - min(cluster)) / diff(range(cluster))
    col.point = rgb(FUN(cluster), maxColorValue=256)
  }
  plot3d(x[, 1:3], col = col.point, 
         xlim=c(-1, 1), ylim=c(-1, 1), zlim=c(-1, 1), 
         box=FALSE, axes=FALSE, xlab='', ylab='', zlab='')
  
  arrow3d(c(0, -1.35, 0), c(0, 1.35, 0), 
          col = 'gray', s=0.04, type='extrusion', lit=FALSE)
  
  spheres3d(0, 0, 0, lit=FALSE, color='#dbd7d2', 
            alpha=0.6, radius=0.99)
  spheres3d(0, 0, 0, radius=0.9999, lit=FALSE, color='gray', 
            front='lines', alpha=0.6)
  
  if (density == FALSE) {
    id = !duplicated(cluster)
    col.leg = AssignLabelColor(col, cluster)[id]
    leg = cluster[id]
    names(col.leg) = leg
    
    if (legend == TRUE) {
      legend3d("topright", legend = leg, 
               pch = 16, col = col.leg, cex=1, inset=c(0.02)) 
    }
    
    cluster.srt = sort(unique(cluster))
    k.centers = sapply(cluster.srt, function(zz) {
      cat(zz, '\t')
      id = cluster == zz
      center = colMedians(as.matrix(x[id, , drop=FALSE]))
    })
    
    k.centers = t(k.centers)
    
    cluster.size = table(cluster)[as.character(cluster.srt)]
    id = which(cluster.size > 0)
    
    if (length(id) > 0) {
      k.centers = k.centers[id, , drop=FALSE]
      cluster.srt = cluster.srt[id]
    }
    
    k.centers = k.centers / sqrt(rowSums(k.centers^2)) * 1.15
    text3d(k.centers, texts=cluster.srt, col='black')
  }
}

# Data can be downloaded from single cell portal (login with a Google account):
# https://singlecell.broadinstitute.org/single_cell/study/SCP551/scphere#study-download
vector_cell_type <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute")) %>% colnames %>% gsub(pattern = "\\_absolute\\.psi", replacement = "")

df_scPhere_python_result <- read.delim("/mnt/LTS/projects/2020_RNA_atlas/results/R_processing_results_PSISigma/scPhere_result_allPSIvalues.tsv", sep = " ", header = FALSE)

PlotSphere(df_scPhere_python_result, rep(".", times = 364))

# you can save the 3d plots as png file or html file
rgl.snapshot('/Users/jding/work/scdata/UC-out/uc_epi_latent_250epoch_scphere.png',  fmt='png')

browseURL(writeWebGL(filename=paste('/Users/jding/work/scdata/UC-out/', 
                                    'uc_epi_latent_250epoch_scphere.html', sep='/'),
                     width=1000))
                     
# People may still want to show the 3D plots in 2D. 
# We can simply convert the 3D cartesian coordinates to spherical coordinates using the car2sph function.

library(sphereplot)
y = car2sph(df_scPhere_python_result)

col = AssignLabelColor(distinct.col, vector_cell_type)
NeatPlot(y[, 1:2], col=col, cex=0.25, 
         cex.axis=1, xaxt='n', yaxt='n')

```

## Seurat cluster detection

Do all/cell type/cell line/tissue type

```{r}

load(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_pooled_replicates.tibble", sep = ""))

# get unique row names 
vector_row_names <- paste("R-", wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids$groupid, "-",  wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids$featureid, sep = "")

tibble_PSI_matrix_all_samples <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% 
  dplyr::select(contains("absolute.psi")) %>% as.matrix

rownames(tibble_PSI_matrix_all_samples) <- vector_row_names

list_of_tibble_PSI_matrix_subset_by_sample_type <- purrr::map(
  .x = c("cell line", "cell type", "tissue"),
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- "cell line"
    ###########
    
    sample_type <- a1
    
    # subset for whole tissue samples only
    vector_column_subsetting_indices <- which(gsub(x = colnames(tibble_PSI_matrix_all_samples), pattern = "_absolute.psi.*", replacement = "") %in% (tibble_combined_mapping_info[grep(x = tibble_combined_mapping_info$Type, pattern = sample_type), ] %>% .$condition_names))
    
    tibble_PSI_matrix_subset <- tibble_PSI_matrix_all_samples[, vector_column_subsetting_indices]
    
    tibble_PSI_matrix_subset[is.na(tibble_PSI_matrix_subset)] <- 0
    
    tibble_PSI_matrix_subset <- tibble_PSI_matrix_subset %>% round()
    
    return(tibble_PSI_matrix_subset)
    
  } ) %>% set_names(c("cell line", "cell type", "tissue"))

list_of_tibble_PSI_matrix_subset_by_sample_type <- list(list_of_tibble_PSI_matrix_subset_by_sample_type, 
                                                             "all" = list(tibble_PSI_matrix_all_samples)
                                                             # %>% setNames(nm = gsub(x = colnames(tibble_PSI_matrix_all_samples), pattern = "_absolute.psi", replacement = ""))
                                                             ) %>% flatten

# list_of_tibble_PSI_matrix_subset_by_sample_type <- purrr::map(.x = list_of_tibble_PSI_matrix_subset_by_sample_type,
#                                                           .f = function(a1) {
# 
#                                                             df_final <- a1
# 
#                                                             rownames(df_final) <- vector_row_names
# 
#                                                             return(df_final)
# 
#                                                           } )

# df_PSI_matrix[is.na(df_PSI_matrix)] <- 0

# count the number of zeroes in each row 
# tibble_PSI_matrix <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% 
#   dplyr::select(contains("absolute.psi"))
# 
# tibble_PSI_matrix[is.na(tibble_PSI_matrix)] <- 0
# 
# options(mc.cores = 4)
# 
# vector_number_of_zeroes_each_row <- furrr::future_map(
#   .x = tibble_PSI_matrix %>% array_tree(margin = 1),
#   .f = ~which(.x == 0) %>% length,
#   .progress = TRUE)

# plan(multiprocess, workers = 4)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 16)))

list_tibble_seurat_cluster_to_annotation_mapping <- furrr::future_map2(
  .x = list_of_tibble_PSI_matrix_subset_by_sample_type,
  .y = list_of_tibble_PSI_matrix_subset_by_sample_type %>% names,
  .f = function(a1, a2) {
    
    # DEBUG ###
    a1 <- list_of_tibble_PSI_matrix_subset_by_sample_type[[1]]
    a2 <- list_of_tibble_PSI_matrix_subset_by_sample_type %>% names %>% .[[1]]
    ###########
    
    cat(a2, "\n")
    
    seurat_all_PSIs <- CreateSeuratObject(
      counts = a1, 
      min.cells = 0, min.features = 0, project = paste("PSISigma_RNA_atlas_", a2, sep = ""))
    
    # seurat_all_PSIs$orig.ident <- gsub(x = names(seurat_all_PSIs$orig.ident), pattern = "_absolute.psi.*", replacement = "") %>% as.factor
    
    # save(seurat_all_PSIs, file = paste(R_processing_results_dir, "seurat_all_PSIs.seurat", sep = ""), compress = FALSE)
    # load(file = paste(R_processing_results_dir, "seurat_all_PSIs_no_na.seurat", sep = ""))
    
    plan(multiprocess, workers = 16)
    
    # seurat_all_PSIs <- Seurat::NormalizeData(object = seurat_all_PSIs, normalization.method = "LogNormalize", scale.factor = 10000)
    # 
    # seurat_all_PSIs <- Seurat::FindVariableFeatures(object = seurat_all_PSIs, mean.function = ExpMean, dispersion.function = LogVMR)
    # 
    # seurat_all_PSIs <- ScaleData(object = seurat_all_PSIs, vars.to.regress = c("nUMI", "percent.mito"))
    
    seurat_all_PSIs <- SCTransform(seurat_all_PSIs, verbose = TRUE)
    
    seurat_all_PSIs <- RunPCA(seurat_all_PSIs, verbose = FALSE)
    seurat_all_PSIs <- RunUMAP(seurat_all_PSIs, dims = 1:30, verbose = FALSE)
    seurat_all_PSIs <- RunTSNE(seurat_all_PSIs, dims = 1:30, verbose = FALSE)
    
    seurat_all_PSIs <- FindNeighbors(seurat_all_PSIs, dims = 1:30, verbose = FALSE)
    seurat_all_PSIs <- FindClusters(seurat_all_PSIs, verbose = FALSE)
    
    DimPlot(seurat_all_PSIs, reduction = "pca", label = TRUE, pt.size = 1) +
      ggtitle("PCA") +
      labs(colour = "Cluster") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(R_processing_results_dir, "PCA_seurat_", a2, "_no_na_pooled_replicates.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
      ggsave(filename = paste(R_processing_results_dir, "PCA_seurat_", a2, "_no_na_pooled_replicates.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")
    
    DimPlot(seurat_all_PSIs, reduction = "umap", label = TRUE, pt.size = 1) +
      ggtitle("UMAP") +
      labs(colour = "Cluster") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(R_processing_results_dir, "UMAP_seurat_", a2, "_no_na_pooled_replicates.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
      ggsave(filename = paste(R_processing_results_dir, "UMAP_seurat_", a2, "_no_na_pooled_replicates.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")
    
    DimPlot(seurat_all_PSIs, reduction = "tsne", label = TRUE, pt.size = 1) +
      ggtitle("t-SNE") +
      labs(colour = "Cluster") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(R_processing_results_dir, "tSNE_seurat_", a2, "_no_na_pooled_replicates.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
      ggsave(filename = paste(R_processing_results_dir, "tSNE_seurat_", a2, "_no_na_pooled_replicates.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")
    
    # create seurat cluster to biological sample annotation mapping
    tibble_seurat_clusters_to_annotation_mapping <- dplyr::left_join(seurat_all_PSIs$seurat_clusters %>% as_tibble(rownames = "r", .name_repair = "unique") %>% setNames(nm = c("replicate_name", "seurat_cluster")) %>% tibble::add_column("condition_names" = gsub(x = .$replicate_name, pattern = "_absolute.psi_.*", replacement = "")), tibble_combined_mapping_info)
    
    write.table(x = tibble_seurat_clusters_to_annotation_mapping, file = paste(R_processing_results_dir, "tibble_seurat_clusters_to_annotation_mapping_", a2, "_no_na_pooled_replicates.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    # tibble_seurat_clusters_to_annotation_mapping <- read.delim(file = paste(R_processing_results_dir, "tibble_seurat_clusters_to_annotation_mapping_no_na.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, row.names = NULL, header = TRUE) %>% as_tibble
    
    return(list(
      "seurat_object" = seurat_all_PSIs,
      "tibble_cluster_to_annotation_mapping" = tibble_seurat_clusters_to_annotation_mapping
    ))
    
  }, .progress = TRUE )

```

## SNN using dbscan

```{r}

library(dbscan)

load(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_pooled_replicates.tibble", sep = ""))

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_matrix_absolute_psis_transposed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% 
  dplyr::select(contains("absolute.psi")) %>% 
  t %>% 
  as_tibble(.name_repair = "universal") %>% 
  setNames(nm = paste(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$groupid, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$featureid, sep = ","))

k_value <- 10
kt_value <- 3

sNN_dbscan_absolute_PSIs <- dbscan::sNN(tibble_matrix_absolute_psis_transposed %>% as.matrix, k = 100, kt = 3, sort = FALSE, jp = TRUE)

save(sNN_dbscan_absolute_PSIs, file = paste(R_processing_results_dir, "sNN_dbscan_k", k_value, "_kt", kt_value, "_absolute_PSIs_with_na_pooled_replicates.sNN", sep = ""), compress = FALSE)
load(file = paste(R_processing_results_dir, "sNN_dbscan_k", k_value, "_kt", kt_value, "_absolute_PSIs_with_na_pooled_replicates.sNN", sep = ""))

# convert to pairwise edge table
## method: tibblise, pull in vector of number of shared neighbours for each item, summarise.

vector_no_shared_nearest_neighbours <- sNN_dbscan_absolute_PSIs$shared %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1") %>% 
  as_tibble %>%
  dplyr::select(-variable) %>% 
  .$value

tibble_sNN_pairwise_edge_table <- sNN_dbscan_absolute_PSIs$id %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1") %>% 
  as_tibble %>%
  dplyr::select(-variable) %>%
  dplyr::rename("comparison_2" = "value") %>% 
  dplyr::mutate("no_shared_nearest_neighbours" = vector_no_shared_nearest_neighbours) %>%
  # check whether NA columns in comparison_2 are also the NA columns in "no_shared_nearest_neighbours"
  (function(a1) {
    
    if (purrr::map2(.x = a1$comparison_2 %>% is.na %>% which, .y = a1$no_shared_nearest_neighbours %>% is.na %>% which, .f = ~.x == .y) %>% unlist %>% all != TRUE) {
      stop("NA values are mismatched. vector_no_shared_nearest_neighbours does not match exactly to sNN_dbscan_absolute_PSIs$id.")
    } else {
      return(a1)
    }
    
  }) %>%
  na.omit %>%
  type_convert %>%
  mutate_all(as.integer) %>%
  # sort each row. comparison_1 must be less than comparison_2 because we want to get each combination, not permutation.
  (function(a1) {
    
    index_rows_that_need_to_be_flipped <- purrr::map2(.x = a1$comparison_1, .y = a1$comparison_2, .f = ~.x > .y) %>% unlist %>% which
    
    tibble_result <- a1
    
    tibble_result[index_rows_that_need_to_be_flipped, c(1, 2)] <- tibble_result[index_rows_that_need_to_be_flipped, c(2, 1)]
    
    return(tibble_result)
    
  }) %>%
  unique

write.table(x = tibble_sNN_pairwise_edge_table, file = paste(R_processing_results_dir, "sNN_dbscan_PSIsigma_with_na_pooled_replicates_edge_table.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## kNN using dbscan

```{r}

library(dbscan)

load(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_pooled_replicates.tibble", sep = ""))

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_matrix_absolute_psis_transposed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% 
  dplyr::select(contains("absolute.psi")) %>% 
  t %>% 
  as_tibble(.name_repair = "universal") %>% 
  setNames(nm = paste(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$groupid, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$featureid, sep = ","))

k_value <- 10
kt_value <- 3

sNN_dbscan_absolute_PSIs <- dbscan::sNN(tibble_matrix_absolute_psis_transposed %>% as.matrix, k = 100, kt = 3, sort = FALSE, jp = TRUE)

save(sNN_dbscan_absolute_PSIs, file = paste(R_processing_results_dir, "sNN_dbscan_k", k_value, "_kt", kt_value, "_absolute_PSIs_with_na_pooled_replicates.sNN", sep = ""), compress = FALSE)
load(file = paste(R_processing_results_dir, "sNN_dbscan_k", k_value, "_kt", kt_value, "_absolute_PSIs_with_na_pooled_replicates.sNN", sep = ""))

# convert to pairwise edge table
## method: tibblise, pull in vector of number of shared neighbours for each item, summarise.

vector_no_shared_nearest_neighbours <- sNN_dbscan_absolute_PSIs$shared %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1") %>% 
  as_tibble %>%
  dplyr::select(-variable) %>% 
  .$value

tibble_sNN_pairwise_edge_table <- sNN_dbscan_absolute_PSIs$id %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1") %>% 
  as_tibble %>%
  dplyr::select(-variable) %>%
  dplyr::rename("comparison_2" = "value") %>% 
  dplyr::mutate("no_shared_nearest_neighbours" = vector_no_shared_nearest_neighbours) %>%
  # check whether NA columns in comparison_2 are also the NA columns in "no_shared_nearest_neighbours"
  (function(a1) {
    
    if (purrr::map2(.x = a1$comparison_2 %>% is.na %>% which, .y = a1$no_shared_nearest_neighbours %>% is.na %>% which, .f = ~.x == .y) %>% unlist %>% all != TRUE) {
      stop("NA values are mismatched. vector_no_shared_nearest_neighbours does not match exactly to sNN_dbscan_absolute_PSIs$id.")
    } else {
      return(a1)
    }
    
  }) %>%
  na.omit %>%
  type_convert %>%
  mutate_all(as.integer) %>%
  # sort each row. comparison_1 must be less than comparison_2 because we want to get each combination, not permutation.
  (function(a1) {
    
    index_rows_that_need_to_be_flipped <- purrr::map2(.x = a1$comparison_1, .y = a1$comparison_2, .f = ~.x > .y) %>% unlist %>% which
    
    tibble_result <- a1
    
    tibble_result[index_rows_that_need_to_be_flipped, c(1, 2)] <- tibble_result[index_rows_that_need_to_be_flipped, c(2, 1)]
    
    return(tibble_result)
    
  }) %>%
  unique

write.table(x = tibble_sNN_pairwise_edge_table, file = paste(R_processing_results_dir, "sNN_dbscan_PSIsigma_with_na_pooled_replicates_edge_table.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## HDBSCAN using dbscan

```{r}

library(dbscan)

load(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_pooled_replicates.tibble", sep = ""))

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_matrix_absolute_psis_transposed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% 
  dplyr::select(contains("absolute.psi")) %>% 
  t %>% 
  as_tibble(.name_repair = "universal") %>% 
  setNames(nm = paste(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$groupid, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$featureid, sep = ","))

epsilon <- 0.2
minclustersize <- 3

list_consensus_dbscan_sweep <- furrr::future_map2(
  .x = seq(0.005, 0.1, 0.001),
  .y = 3,
  .f = function(a1, a2) {
    
    # DEBUG ###
    ###########
    
    dbscan_result <- dbscan::dbscan(x = tibble_matrix_absolute_psis_transposed %>% as.matrix, eps = a1, minPts = a2)

  }, .progress = TRUE)

dbscan_dbscan_absolute_PSIs <- dbscan::dbscan(x = tibble_matrix_absolute_psis_transposed %>% as.matrix, eps = epsilon, minPts = minclustersize)

save(dbscan_dbscan_absolute_PSIs, file = paste(R_processing_results_dir, "dbscan_dbscan_e", epsilon, "_minpts", minclustersize, "_absolute_PSIs_with_na_pooled_replicates.sNN", sep = ""), compress = FALSE)
load(file = paste(R_processing_results_dir, "sNN_dbscan_k", k_value, "_kt", kt_value, "_absolute_PSIs_with_na_pooled_replicates.sNN", sep = ""))

# convert to pairwise edge table
## method: tibblise, pull in vector of number of shared neighbours for each item, summarise.

vector_no_shared_nearest_neighbours <- dbscan_dbscan_absolute_PSIs$shared %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1") %>% 
  as_tibble %>%
  dplyr::select(-variable) %>% 
  .$value

tibble_sNN_pairwise_edge_table <- dbscan_dbscan_absolute_PSIs$id %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1") %>% 
  as_tibble %>%
  dplyr::select(-variable) %>%
  dplyr::rename("comparison_2" = "value") %>% 
  dplyr::mutate("no_shared_nearest_neighbours" = vector_no_shared_nearest_neighbours) %>%
  # check whether NA columns in comparison_2 are also the NA columns in "no_shared_nearest_neighbours"
  (function(a1) {
    
    if (purrr::map2(.x = a1$comparison_2 %>% is.na %>% which, .y = a1$no_shared_nearest_neighbours %>% is.na %>% which, .f = ~.x == .y) %>% unlist %>% all != TRUE) {
      stop("NA values are mismatched. vector_no_shared_nearest_neighbours does not match exactly to sNN_dbscan_absolute_PSIs$id.")
    } else {
      return(a1)
    }
    
  }) %>%
  na.omit %>%
  type_convert %>%
  mutate_all(as.integer) %>%
  # sort each row. comparison_1 must be less than comparison_2 because we want to get each combination, not permutation.
  (function(a1) {
    
    index_rows_that_need_to_be_flipped <- purrr::map2(.x = a1$comparison_1, .y = a1$comparison_2, .f = ~.x > .y) %>% unlist %>% which
    
    tibble_result <- a1
    
    tibble_result[index_rows_that_need_to_be_flipped, c(1, 2)] <- tibble_result[index_rows_that_need_to_be_flipped, c(2, 1)]
    
    return(tibble_result)
    
  }) %>%
  unique

write.table(x = tibble_sNN_pairwise_edge_table, file = paste(R_processing_results_dir, "sNN_dbscan_PSIsigma_with_na_pooled_replicates_edge_table.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED MQ RATIOS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = R_processing_results_dir, pattern = paste("sNN_dbscan_PSIsigma_with_na_pooled_replicates_min3_penalty2_haircut0.1_multi_match_overlap0.8_seedeverynode.tab", sep = ""))

tibble_cytoscape_result <- read.delim(paste(R_processing_results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# annotate the cluster identities with the annotation
tibble_cytoscape_result_annotated <- tibble_cytoscape_result %>% 
  dplyr::mutate("replicate_name" = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("absolute.psi"))  %>% colnames %>% .[`id`],
                "condition_names" = gsub(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("absolute.psi"))  %>% colnames, pattern = "_absolute.psi.*", replacement = "") %>% .[`id`]) %>% 
  dplyr::left_join(., tibble_combined_mapping_info)

save(tibble_cytoscape_result_annotated, file = paste(R_processing_results_dir, "tibble_clusterONE_annotated_sNN_dbscan_PSIsigma_with_na_pooled_replicates.tibble", sep = ""))
# load(file = paste(R_processing_results_dir, "tibble_cytoscape_result_annotated_consensus_PSIsigma_with_na.tibble", sep = ""))

```

## Our own Kohonen/ClusterONE clustering method

```{r}

sampletype <- "all_data"

if (sampletype == "all_data") {
  sampletype_grep <- ".*"
} 

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

# retrieve vector of column names corresponding to the sample type we want to do
vector_absolute_psi_column_names_of_desired_sample_type <- colnames(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering) %>% .[gsub(x = colnames(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering), pattern = "\\_absolute\\.psi", replacement = "") %in% (tibble_combined_mapping_info[grep(x = tibble_combined_mapping_info$Type, pattern = sampletype_grep), "condition_names"] %>% unlist)]

tibble_matrix_absolute_psis_transposed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, vector_absolute_psi_column_names_of_desired_sample_type] %>% 
  dplyr::select(contains("absolute.psi")) %>% 
  t %>% 
  as_tibble(.name_repair = "universal") %>% 
  setNames(nm = paste(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$groupid, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering$featureid, sep = ","))

# scale values
matrix_absolute_psis_transposed_scaled <- tibble_matrix_absolute_psis_transposed %>% genescale(m = ., axis = 1, method = "Z")

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
if (sampletype == "all_data") {
  xdim_range_combinedexpr <- c(6, 9, 19, 2, 5, 8, 6, 7, 4, 11, 23, 2, 6, 8, 2, 25, 26, 2, 6, 9)
  ydim_range_combinedexpr <- c(6, 4, 2, 19, 8, 5, 7, 6, 11, 4, 2, 23, 8, 6, 25, 2, 2, 26, 9, 6)
} else if (sampletype == "tissue") {
  xdim_range_combinedexpr <- c(3, 1, 4, 1, 5, 1, 3, 6, 7, 1, 4, 2, 9, 3, 5, 2)
  ydim_range_combinedexpr <- c(2, 6, 2, 8, 2, 10, 4, 2, 2, 14, 4, 8, 2, 6, 4, 10)
}

# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(8)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

# calculate probability of random co-occurrence

no_soms_to_do <- length(xdim_range_combinedexpr) * length(random_seed_numbers)

min_dimension <- list_seeds_and_dimensions_to_loop %>% purrr::map(.f = ~.x[[1]]*.x[[2]]) %>% unlist %>% min

no_possible_pairs <- choose(nrow(tibble_matrix_absolute_psis_transposed), 2)

# probability is all the binomial probabilities associated with co-clustering k times at the "mutual_consensus_cutoff" all the way to n times (co-clusters 100% of the time) 
# maximal probability -> we assumed that all clustering is done at the lowest dimension.
cocluster_binomial_prob <- seq(from = ceiling(mutual_consensus_cutoff*no_soms_to_do), to = no_soms_to_do, by = 1) %>% purrr::map(.f = function(k) {
  prob <- choose(no_soms_to_do, k) * (min_dimension/choose(min_dimension, 2))^(k) * (1 - (min_dimension/choose(min_dimension, 2)))^(no_soms_to_do - k); 
  return(prob)
  } ) %>% unlist %>% base::sum()

cat("maximal probability of any two pair co-clustering at random in at least ", mutual_consensus_cutoff*100, "% of runs:", cocluster_binomial_prob*100 , "%\n", sep = "")

# calculate the binomial probability of 5% or more pairs co-clustering at random
cocluster_FDR_cutoff <- 0.05

cocluster_binomial_FDR <- 1 - (setdiff(0:no_possible_pairs, seq(from = ceiling(cocluster_FDR_cutoff*no_possible_pairs), to = no_possible_pairs, by = 1)) %>% purrr::map(.f = function(k) {
  prob <- choose(no_possible_pairs, k) * (cocluster_binomial_prob)^(k) * (1 - cocluster_binomial_prob)^(no_possible_pairs - k); 
  return(prob)
  } ) %>% unlist %>% base::sum())

cat("maximal probability of at most ", cocluster_FDR_cutoff*100, "% of pairs co-clustering at random in at least ", mutual_consensus_cutoff*100, "% of runs: ", cocluster_binomial_FDR*100, "%\n", sep = "")

cat("maximal probability of at least one pair co-occurring at random after taking consensus: ", (1 - (1 - cocluster_binomial_prob)^no_possible_pairs)*100, "%\n", sep = "")

```

### execute ensemble SOM and create consensus matrix

```{r}

# library(Rsomoclu)

options(mc.cores = 96)

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(matrix_absolute_psis_transposed_scaled, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
  # test <- Rsomoclu::Rsomoclu.train(
  #   input_data = matrix_absolute_psis_transposed_scaled[, 1:100], 
  #   nEpoch = 100, 
  #   nSomX = .x[[1]], 
  #   nSomY = .x[[2]],
  #   radius0 = .x[[1]]/2,
  #   radiusN = 1,
  #   radiusCooling = "linear",
  #   scale0 = 0.05, 
  #   scaleN = 0.01,
  #   scaleCooling = "linear",
  #   kernelType = 2, 
  #   mapType = "planar", 
  #   gridType = "square",
  #   compactSupport = TRUE,
  #   neighborhood = "gaussian", 
  #   stdCoeff = 0.5, 
  #   codebook = NULL
  # )
  
}, .progress = TRUE ) %>% as.data.frame

save(wide_table_som_sweep_clusters, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_table_som_sweep_clusters_", sampletype, ".df", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_table_som_sweep_clusters_", sampletype, ".df", sep = ""))

rownames(wide_table_som_sweep_clusters) <- tibble_matrix_absolute_psis_transposed %>% rownames

options(mc.cores = 8)

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix

rownames(matrix_consensus_matrix) <- rownames(wide_table_som_sweep_clusters)

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 64)
save(matrix_consensus_matrix_dist_result, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_matrix_consensus_matrix_dist_result_", sampletype, ".dist", sep = ""), compress = FALSE)

matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_matrix_consensus_combinedexpr_matrix_dendrogram_reordered_", sampletype, ".matrix", sep = ""), compress = FALSE)

ggsave(plot = ggdendro::ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")), filename = paste(R_processing_results_dir, "atlas_totalrna_psisigma_dendrogram_som_consensus_matrix_with_na_", sampletype, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 100, height = 100, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_heatmap_som_consensus_matrix_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_consensus_matrix_reordered, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_heatmap_som_consensus_matrix_with_na_", sampletype, ".tibble", sep = ""))
load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_heatmap_som_consensus_matrix_with_na_", sampletype, ".tibble", sep = ""))

# tibble_consensus_matrix_reordered <- read.delim(file = paste(R_processing_results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_heatmap_som_consensus_matrix_with_na_long_", sampletype, ".tibble", sep = ""))

ggplot_heatmap_consensus_matrix <- ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for co-clustering by PSI values, with NA = 0", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_heatmap_consensus_matrix, filename = paste(R_processing_results_dir, "atlas_totalrna_psisigma_heatmap_som_combinedexpr_consensus_matrix_combined_with_na_", sampletype, ".tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

options(mc.cores = 16)

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_consensus_edge_table_anyintersection_consensus0.5_with_na_", sampletype, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = tibble_pairwise_edges_unfiltered[, c("comparison_1", "comparison_2", "jaccard")], file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_consensus_edge_table_anyintersection_consensus0.5_with_na_", sampletype, "_jaccardonly.txt", sep = ""), sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_pairwise_edges_with_na_filtered_", sampletype, ".tibble", sep = ""))

pdf(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_densityplot_PNC_distribution_with_na_", sampletype, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_densityplot_jaccard_distribution_with_na_", sampletype, ".pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered[, c("comparison_1", "comparison_2", "jaccard")], file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_consensus_edge_table_intersection1_consensus0.5_with_na_", sampletype, "_jaccardonly.txt", sep = ""), sep = "\t", col.names = FALSE, row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED PSI VALUES

```{r}

purrr::map(
  .x = c("plain", "csv", "genepro"),
  .f = function(a1) {

    system(command = paste("java -Xmx100G -jar ", clusterone_path, " --num-threads 24 --input-format edge_list --output-format ", a1, " --min-size 3 --haircut 0.1 --max-overlap 0.8 --merge-method single --similarity jaccard --penalty 2 --seed-method nodes --min-density auto ", R_processing_results_dir, "atlas_totalrna_psisigma_consensus_edge_table_intersection1_consensus0.5_with_na_", sampletype, "_jaccardonly.txt", " > ", R_processing_results_dir, "atlas_totalrna_psisigma_consensus_edge_table_int1_cons0.5_min3_hc0.1_mo0.8_pen2_single_jaccard_seednodes_with_na_", sampletype, ".", a1, sep = ""))

  } )

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = R_processing_results_dir, pattern = paste("atlas_totalrna_psisigma_consensus_edge_table_int1_cons0.5_min3_hc0.1_mo0.8_pen2_single_jaccard_seednodes_with_na_", sampletype, ".genepro", sep = ""))

tibble_cytoscape_result <- read.delim(paste(R_processing_results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% readr::type_convert()

# annotate the cluster identities with the annotation
tibble_cytoscape_result_annotated <- tibble_cytoscape_result %>% 
  dplyr::mutate("replicate_name" = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ %>% dplyr::select(contains("absolute.psi"))  %>% colnames %>% .[`id`],
                "condition_names" = gsub(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ %>% dplyr::select(contains("absolute.psi"))  %>% colnames, pattern = "_absolute.psi.*", replacement = "") %>% .[`id`]) %>% 
  dplyr::left_join(., tibble_combined_mapping_info)

save(tibble_cytoscape_result_annotated, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_clusterONE_annotated_consensus_som_with_na_", sampletype, ".tibble", sep = ""))
# load(file = paste(R_processing_results_dir, "tibble_cytoscape_result_annotated_consensus_PSIsigma_with_na_", sampletype, ".tibble", sep = ""))

# overlay clusters onto UMAP

# force trim the fuzziness to have 1 id for each cluster.
tibble_sharp_cluster_mapping <- tibble_cytoscape_result_annotated %>% 
  dplyr::group_by(id) %>%
  dplyr::distinct(id, .keep_all = TRUE) %>% 
  dplyr::arrange(cluster)

# wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

tibble_matrix_absolute_psi_in_sample_replicate_format <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ[, vector_absolute_psi_column_names_of_desired_sample_type] %>% dplyr::select(contains("absolute.psi"))

temp_condition_names <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ[, vector_absolute_psi_column_names_of_desired_sample_type] %>% dplyr::select(contains("absolute.psi")) %>% colnames %>% gsub(x = ., pattern = "_absolute.psi", replacement = "")

temp_replicate_names <- dplyr::left_join(
  wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ[, vector_absolute_psi_column_names_of_desired_sample_type] %>% dplyr::select(contains("absolute.psi")) %>% colnames %>% gsub(x = ., pattern = "_absolute.psi", replacement = "") %>% tibble::enframe(value = "condition_names", name = NULL), 
  tibble_combined_mapping_info %>% dplyr::arrange(RNA_number) %>% dplyr::group_by(RNA_number) %>% dplyr::mutate("replicatenumber" = 1:n())) %>% .$replicatenumber

colnames(tibble_matrix_absolute_psi_in_sample_replicate_format) <- paste(temp_condition_names, "|", temp_replicate_names, sep = "")

tibble_matrix_absolute_psi_in_sample_replicate_format_with_na <- tibble_matrix_absolute_psi_in_sample_replicate_format
tibble_matrix_absolute_psi_in_sample_replicate_format_with_na[is.na(tibble_matrix_absolute_psi_in_sample_replicate_format_with_na)] <- 0

set.seed(8)
plot_UMAP_for_timepoint_and_replicate(
  transposed_matrixtable = tibble_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t %>% .[gsub(x = rownames(.), pattern = "^(.*)\\|.*$", replacement = "\\1") %in% tibble_sharp_cluster_mapping$condition_names, ], 
  timepoint_order = temp_condition_names, 
  replicate_order = c("r1", "r2"), 
  plot_shapes = FALSE, 
  legend_position = "none", 
  centroid_labels = TRUE, 
  point_size = 1, 
  centroid_label_size = 1, 
  PCA_depths_y = c(2, 3, 4), 
  PCA_depths_x = c(1, 2, 3), 
  input_colour_limits = tibble_sharp_cluster_mapping$condition_names, 
  input_colour_value = rainbow(tibble_sharp_cluster_mapping$cluster %>% max) %>% .[tibble_sharp_cluster_mapping$cluster], 
  save_dir = R_processing_results_dir, 
  save_name = paste("atlas_totalrna_psisigma_umap_consensus_som_clusterone_total_RNA_psisigma_replicates_no_na_", sampletype, sep = ""), 
  graph_title = "Total RNA/PSI-Sigma w/ replicates, coloured by consensus SOM clusters", 
  width = 40, 
  height = 40)

# set.seed(8)
# plot_UMAP_for_timepoint_and_replicate(
#   transposed_matrixtable = tibble_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t %>% .[gsub(x = rownames(.), pattern = "^(.*)\\|.*$", replacement = "\\1") %in% tibble_sharp_cluster_mapping$condition_names, ], 
#   timepoint_order = temp_condition_names, 
#   replicate_order = c("r1", "r2"), 
#   plot_shapes = FALSE, 
#   legend_position = "none", 
#   centroid_labels = TRUE, 
#   point_size = 1, 
#   centroid_label_size = 1, 
#   PCA_depths_y = c(2, 3, 4), 
#   PCA_depths_x = c(1, 2, 3), 
#   input_colour_limits = tibble_sharp_cluster_mapping$condition_names, 
#   input_colour_value = rainbow(tibble_sharp_cluster_mapping$cluster %>% max) %>% .[tibble_sharp_cluster_mapping$cluster], 
#   save_dir = R_processing_results_dir, 
#   save_name = paste("consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_", sampletype, sep = ""), 
#   graph_title = "Total RNA/PSI-Sigma w/ replicates, coloured by consensus SOM clusters", 
#   width = 40, 
#   height = 40)

set.seed(8)
plot_UMAP_for_timepoint_and_replicate_plotly(
  transposed_matrixtable = tibble_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t %>% .[gsub(x = rownames(.), pattern = "^(.*)\\|.*$", replacement = "\\1") %in% tibble_sharp_cluster_mapping$condition_names, ], 
  timepoint_order = temp_condition_names, 
  replicate_order = c("r1", "r2"), 
  plot_shapes = FALSE, 
  legend_position = "none", 
  centroid_labels = TRUE, 
  point_size = 1, 
  centroid_label_size = 5, 
  PCA_depths_y = c(2, 3, 4), 
  PCA_depths_x = c(1, 2, 3), 
  input_colour_limits = tibble_sharp_cluster_mapping$condition_names, 
  tibble_colour_metadata = tibble_sharp_cluster_mapping %>% dplyr::ungroup() %>% dplyr::rename("som_cluster" = "cluster", "input_colour_limits" = "condition_names") %>% dplyr::select(id, som_cluster, input_colour_limits, Description, Biological_source, Type) %>% dplyr::mutate_at(.vars = c("Description", "Biological_source", "Type"), .funs = function(x) {gsub(x = x, pattern = "[^a-zA-Z0-9 -/]", replacement = "")}),
  input_colour_value = rainbow(tibble_sharp_cluster_mapping$cluster %>% max) %>% .[tibble_sharp_cluster_mapping$cluster], 
  save_dir = R_processing_results_dir, 
  save_name = paste("atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_", sampletype, sep = ""), 
  graph_title = "Total RNA/PSI-Sigma w/ replicates, coloured by consensus SOM clusters", 
  width = 40, 
  height = 40)

# tSNE
set.seed(8)
plot_tSNE_for_timepoint_and_replicate(
  transposed_matrixtable = tibble_matrix_absolute_psi_in_sample_replicate_format %>% na.omit %>% t %>% .[gsub(x = rownames(.), pattern = "^(.*)\\|.*$", replacement = "\\1") %in% tibble_sharp_cluster_mapping$condition_names, ], 
  timepoint_order = temp_condition_names, 
  replicate_order = c("r1", "r2"), 
  plot_shapes = FALSE, 
  legend_position = "none", 
  centroid_labels = TRUE, 
  point_size = 1, 
  centroid_label_size = 1, 
  PCA_depths_y = c(2, 3, 4), 
  PCA_depths_x = c(1, 2, 3), 
  input_colour_limits = tibble_sharp_cluster_mapping$condition_names, 
  input_colour_value = rainbow(tibble_sharp_cluster_mapping$cluster %>% max) %>% .[tibble_sharp_cluster_mapping$cluster], 
  save_dir = R_processing_results_dir, 
  save_name = paste("atlas_totalrna_psisigma_tsne_consensus_som_clusterone_replicates_no_na_", sampletype, sep = ""), 
  graph_title = "Total RNA/PSI-Sigma w/ replicates, coloured by consensus SOM clusters", 
  width = 40, 
  height = 40)

set.seed(8)
plot_tSNE_for_timepoint_and_replicate(
  transposed_matrixtable = tibble_matrix_absolute_psi_in_sample_replicate_format_with_na %>% t %>% .[gsub(x = rownames(.), pattern = "^(.*)\\|.*$", replacement = "\\1") %in% tibble_sharp_cluster_mapping$condition_names, ], 
  timepoint_order = temp_condition_names, 
  replicate_order = c("r1", "r2"), 
  plot_shapes = FALSE, 
  legend_position = "none", 
  centroid_labels = TRUE, 
  point_size = 1, 
  centroid_label_size = 1, 
  PCA_depths_y = c(2, 3, 4), 
  PCA_depths_x = c(1, 2, 3), 
  input_colour_limits = tibble_sharp_cluster_mapping$condition_names, 
  input_colour_value = rainbow(tibble_sharp_cluster_mapping$cluster %>% max) %>% .[tibble_sharp_cluster_mapping$cluster], 
  save_dir = R_processing_results_dir, 
  save_name = paste("atlas_totalrna_psisigma_tsne_consensus_som_clusterone_replicates_with_na_", sampletype, sep = ""), 
  graph_title = "Total RNA/PSI-Sigma w/ replicates, coloured by consensus SOM clusters", 
  width = 40, 
  height = 40)

# relabel mapping file
tibble_raw_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_total_RNA_psisigma_replicates_no_na_", sampletype, "_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_UMAP_cluster_legend <- tibble_raw_UMAP_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number") %>% 
  dplyr::left_join(., tibble_sharp_cluster_mapping[, c("condition_names", "cluster")] %>% dplyr::rename("som_cluster" = "cluster"))

write.table(x = tibble_processed_UMAP_cluster_legend, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_total_RNA_psisigma_replicates_no_na_", sampletype, "_cluster_legend_annotated.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

###

tibble_raw_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_", sampletype, "_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_UMAP_cluster_legend <- tibble_raw_UMAP_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number") %>% 
  dplyr::left_join(., tibble_sharp_cluster_mapping[, c("condition_names", "cluster")] %>% dplyr::rename("som_cluster" = "cluster"))

write.table(x = tibble_processed_UMAP_cluster_legend, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_", sampletype, "_cluster_legend_annotated.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_", sampletype, "_cluster_legend_annotated.txt", sep = ""), sep = "\t", check.names = FALSE, stringsAsFactors = FALSE) %>% as_tibble

# also write the table of chucked out items
tibble_chucked_out_items_UMAP <- dplyr::anti_join(tibble_combined_mapping_info, tibble_processed_UMAP_cluster_legend, by = "condition_names")

write.table(x = tibble_chucked_out_items_UMAP, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_", sampletype, "_chucked_out_cluster_legend_annotated.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# also write the table of chucked out items
tibble_chucked_out_items_UMAP <- dplyr::anti_join(tibble_combined_mapping_info, tibble_processed_UMAP_cluster_legend, by = "condition_names")

write.table(x = tibble_chucked_out_items_UMAP, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_UMAP_consensus_som_clusterone_tibble_chucked_out_items.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# test batch effect 
ggplot_consensus_som_batch_effect <- ggplot() +
  geom_point(data = tibble_processed_UMAP_cluster_legend, mapping = aes(x = centroid_x, y = centroid_y, colour = Source)) +
  ggtitle("Atlas/PolyA/PSI-Sigma UMAP, coloured by origin lab") +
  theme_bw()

ggsave(plot = ggplot_consensus_som_batch_effect, filename = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_coloured_by_source.pdf", sep = ""), device = "pdf", dpi = 600, width = 15, height = 10, units = "cm")

###
tibble_raw_tsne_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tsne_consensus_som_clusterone_replicates_no_na_", sampletype, "_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_tsne_cluster_legend <- tibble_raw_tsne_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number") %>% 
  dplyr::left_join(., tibble_sharp_cluster_mapping[, c("condition_names", "cluster")] %>% dplyr::rename("som_cluster" = "cluster"))

write.table(x = tibble_processed_tsne_cluster_legend, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tsne_consensus_som_clusterone_replicates_no_na_", sampletype, "_cluster_legend_annotated.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

###

tibble_raw_tsne_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tsne_consensus_som_clusterone_replicates_with_na_", sampletype, "_cluster_legend.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_tsne_cluster_legend <- tibble_raw_tsne_cluster_legend %>%
  dplyr::left_join(., tibble_folder_subfolder_mapping, by = "condition_names") %>%
  dplyr::left_join(., tibble_sample_info, by = "RNA_number") %>% 
  dplyr::left_join(., tibble_sharp_cluster_mapping[, c("condition_names", "cluster")] %>% dplyr::rename("som_cluster" = "cluster"))

write.table(x = tibble_processed_tsne_cluster_legend, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tsne_consensus_som_clusterone_replicates_with_na_", sampletype, "_cluster_legend_annotated.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## random forest using h2o4gpu

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

# wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% na.omit

# wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids[is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids)] <- 0

# options(mc.cores = 4)

# library(future.apply)

# discard the rows which dont change in all conditions.
# vector_rows_which_have_less_than_x_number_of_zeroes <- future_apply(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("absolute.psi")), MARGIN = 1, FUN = function(X) {which(X == 0) %>% length > 2000 } ) %>% unlist %>% which

# wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids[vector_rows_which_have_less_than_x_number_of_zeroes, ]

tibble_matrix_absolute_psis_transposed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% 
  dplyr::select(contains("absolute.psi")) %>% 
  t %>% 
  as_tibble(.name_repair = "universal") %>% 
  setNames(nm = paste("C", wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids$groupid, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids$featureid, sep = "_"))

library(reticulate)
library(h2o4gpu)

x <- tibble_matrix_absolute_psis_transposed[1:100, 1:100]
y <- 1:4
# y <- 1:nrow(tibble_matrix_absolute_psis_transposed)

# Initialize and train the classifier
classifier_random_forest <- h2o4gpu::h2o4gpu.random_forest_classifier() %>% 
  h2o4gpu::fit(x, y)

save(classifier_random_forest, file = paste(R_processing_results_dir, "classifier_random_forest_no_na_pooled_replicates.classifier", sep = ""), compress = FALSE)

# Make predictions
array_predict_result <- classifier_random_forest %>% h2o4gpu::predict(x)

save(array_predict_result, file = paste(R_processing_results_dir, "array_predict_result_no_na_pooled_replicates.array", sep = ""), compress = FALSE)

```

## non-negative matrix factorisation using nmfgpu4R

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

tibble_matrix_absolute_psis_transposed <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% 
  dplyr::select(contains("absolute.psi")) %>% 
  (function(x) {x[is.na(x)] <- 0; return(x)}) %>%
  t %>% 
  as_tibble(.name_repair = "universal") %>% 
  setNames(nm = paste("C", wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids$groupid, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids$featureid, sep = "_"))

save(tibble_matrix_absolute_psis_transposed, file = paste(R_processing_results_dir, "tibble_matrix_absolute_psis_transposed.tibble", sep = ""), compress = FALSE)
load(file = paste(R_processing_results_dir, "tibble_matrix_absolute_psis_transposed.tibble", sep = ""))

library(nmfgpu4R)

nmfgpu4R::nmfgpu4R.init()

nmfgpu4R::deviceMemoryInfo()

nmfgpu4R::chooseDevice(0)

r_value <- 300

nmfgpu_nmf_result <- nmfgpu4R::nmf(
  data = tibble_matrix_absolute_psis_transposed,
  r = r_value,
  algorithm = "mu",
  initMethod = "AllRandomValues",
  seed = 8,
  useSinglePrecision = TRUE,
  threshold = 0.5,
  maxiter = 100,
  verbose = TRUE)

save(nmfgpu_nmf_result, file = paste(R_processing_results_dir, "nmfgpu_nmf_result_with_na_pooled_replicates.nmfgpu", sep = ""), compress = FALSE)
load(file = paste(R_processing_results_dir, "nmfgpu_nmf_result_with_na_pooled_replicates.nmfgpu", sep = ""))

# take the W matrix, calculate pairwise distances, convert "dist" object to long table using dendextend, cytoscape.
long_tibble_NMF_W_matrix_pairwise_distances_lower_diag <- nmfgpu_nmf_result$W %>% 
  as.matrix %>%
  (function(x) {rownames(x) <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("absolute.psi")) %>% colnames; colnames(x) <- 1:ncol(x); return(x)} ) %>%
  parallelDist::parDist(method = "euclidean", threads = 64) %>%
  dendextend::dist_long() %>% 
  as_tibble

# add inverse distance metric to the table
long_tibble_NMF_W_matrix_pairwise_distances_lower_diag <- long_tibble_NMF_W_matrix_pairwise_distances_lower_diag %>% 
  dplyr::mutate("percentage_of_max_distance" = (max(long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance) - long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance) / max(long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance))

write.table(x = long_tibble_NMF_W_matrix_pairwise_distances_lower_diag %>% dplyr::filter(percentage_of_max_distance > 0.3), file = paste(R_processing_results_dir, "long_tibble_NMF_r", r_value, "_W_matrix_pairwise_distances_lower_diag_with_na_pooled_replicates.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

pdf(file = paste(R_processing_results_dir, "PSIsigma_NMF_r", r_value, "_densityplot_distances_with_na_pooled_replicates.pdf", sep = ""), width = 20, height = 15)
plot(density(long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance))
dev.off()

plot(density((max(long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance) - long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance) / max(long_tibble_NMF_W_matrix_pairwise_distances_lower_diag$distance)))

# METHOD 1: from the plot, we can see that there are multiple peaks where items are very close to each other. we take each one and cluster them.

write.table(x = long_tibble_NMF_W_matrix_pairwise_distances_lower_diag %>% dplyr::filter(distance <= 0.05) %>% dplyr::mutate_at(.vars = "distance", .funs = function(x) {1/x} ), file = paste(R_processing_results_dir, "long_tibble_NMF_r", r_value, "_W_matrix_pairwise_invdists_dist0.05_pooled_replicates.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_NMF_W_matrix_pairwise_distances_lower_diag %>% dplyr::filter(distance <= 0.23) %>% dplyr::mutate_at(.vars = "distance", .funs = function(x) {1/x} ), file = paste(R_processing_results_dir, "long_tibble_NMF_r", r_value, "_W_matrix_pairwise_invdists_dist0.23_pooled_replicates.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_NMF_W_matrix_pairwise_distances_lower_diag %>% dplyr::filter(distance <= 0.30) %>% dplyr::mutate_at(.vars = "distance", .funs = function(x) {1/x} ), file = paste(R_processing_results_dir, "long_tibble_NMF_r", r_value, "_W_matrix_pairwise_invdists_dist0.30_pooled_replicates.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# METHOD 2: we choose a maximum distance cutoff and find pairwise common neighbours.
## turn the dist object into a full matrix tibble (not just the lower diagonal)
max_dist_cutoff <- 1.1
# set an upper limit for the maximum number of neighbours any sample can have (maximum neighbourhood)
max_intersection_cutoff <- 100

long_tibble_NMF_W_matrix_pairwise_distances_full_matrix <- nmfgpu_nmf_result$W %>% 
  as.matrix %>%
  (function(x) {rownames(x) <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("absolute.psi")) %>% colnames; colnames(x) <- 1:ncol(x); return(x)} ) %>%
  parallelDist::parDist(method = "euclidean", threads = 72) %>% 
  as.matrix %>% 
  as_tibble(rownames = "comparison_1") %>% 
  reshape2::melt(id.vars = "comparison_1", value.name = "pairwise_distance", variable.name = "comparison_2") %>% 
  as_tibble 

options(mc.cores = 8)

list_neighbours_for_each_item <- future_map(.x = long_tibble_NMF_W_matrix_pairwise_distances_full_matrix$comparison_1 %>% unique, .f = ~long_tibble_NMF_W_matrix_pairwise_distances_full_matrix[long_tibble_NMF_W_matrix_pairwise_distances_full_matrix$comparison_1 == .x & long_tibble_NMF_W_matrix_pairwise_distances_full_matrix$pairwise_distance < max_dist_cutoff, "comparison_2"], .progress = TRUE) %>% set_names(nm = long_tibble_NMF_W_matrix_pairwise_distances_full_matrix$comparison_1 %>% unique)

# take pairwise intersections ###
tibble_pairwise_comparisons_between_items <- combn(names(list_neighbours_for_each_item) %>% unlist, m = 2) %>% t %>% as_tibble
colnames(tibble_pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = tibble_pairwise_comparisons_between_items$comparison_1, .y = tibble_pairwise_comparisons_between_items$comparison_2, .f = ~dplyr::intersect(list_neighbours_for_each_item[[.x]], list_neighbours_for_each_item[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_neighbours_for_each_item", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = tibble_pairwise_comparisons_between_items$comparison_1, .y = tibble_pairwise_comparisons_between_items$comparison_2, .f = ~dplyr::setdiff(list_neighbours_for_each_item[[.x]], list_neighbours_for_each_item[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_neighbours_for_each_item", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(tibble_pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(R_processing_results_dir, "PSIsigma_NMF_r", r_value, "_eucliddist_edge_table_anyintersection_dist", max_dist_cutoff, "_with_na_pooled_replicates.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0 but < the max_intersection_cutoff
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0 & tibble_pairwise_edges_unfiltered$coclustering_intersection < max_intersection_cutoff, ]

save(tibble_pairwise_edges_filtered, file = paste(R_processing_results_dir, "tibble_pairwise_edges_PSIsigma_with_na_filtered_pooled_replicates.tibble", sep = ""))

pdf(file = paste(R_processing_results_dir, "PSIsigma_NMF_r", r_value, "_eucliddist", max_dist_cutoff, "_densityplot_intersection_with_na_pooled_replicates.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(R_processing_results_dir, "PSIsigma_NMF_r", r_value, "_eucliddist", max_dist_cutoff, "_densityplot_jaccard_with_na_pooled_replicates.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(R_processing_results_dir, "PSIsigma_NMF_r", r_value, "_eucliddist_edge_table_intersection1_", max_intersection_cutoff, "_dist", max_dist_cutoff, "_with_na_pooled_replicates.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)















ggplot2::ggplot(nmfgpu_nmf_result$W %>% as_tibble) +
  geom_point(mapping = aes(x = r1 %>% log10, y = r2 %>% log10))

pdf(file = paste(R_processing_results_dir, "test.pdf", sep = ""))

test <- nmfgpu_nmf_result$W %>% as.matrix %>% parallelDist::parDist(method = "euclidean", threads = 64) 

nmfgpu_nmf_result$W %>% as.matrix %>% parallelDist::parDist(method = "euclidean", threads = 64) %>% fastcluster::hclust(method = "ward.D2") %>% plot(cex = 0.1)

dev.off()
    



```

## diceR cluster detection

```{r}

library(diceR)

# df_PSI_matrix[is.na(df_PSI_matrix)] <- 0
# "nmf", 
dicer_clustering_results <- df_PSI_matrix %>% diceR::consensus_cluster(
  nk = 25:30, p.item = 0.8, reps = 1000, algorithms = c("hc", "diana", "km", "pam", "ap", "sc", "gmm", "block", "som", "cmeans", "hdbscan"), 
  hc.method = "ward.D2",
  xdim = 5, ydim = 5,
  progress = TRUE)

`4DA_dicer_clustering_results_km` <- df_PSI_matrix %>% na.omit %>% t %>% diceR::consensus_cluster(
  nk = 25:40, p.item = 1, reps = 1, algorithms = c("km"), 
  hc.method = "ward.D2",
  xdim = 5, ydim = 5,
  progress = TRUE)

tibble_dicer_clustering_results_km <- `4DA_dicer_clustering_results_km`[,, "KM",] %>% as_tibble(rownames = "replicatename") %>% dplyr::mutate("condition_names" = gsub(x = `replicatename`, pattern = "_absolute.psi_.*", replacement = "")) %>% dplyr::left_join(., tibble_combined_mapping_info)

`4DA_dicer_clustering_results_sc` <- df_PSI_matrix[1:100, 1:20] %>% na.omit %>% t %>% diceR::consensus_cluster(
  nk = 30, p.item = 1, reps = 1, algorithms = c("sc"), 
  min.var = 2,
  progress = TRUE) 

%>% as_tibble(rownames = "f") %>% setNames(c("replicatename", "cluster")) %>% dplyr::mutate("condition_names" = gsub(x = `replicatename`, pattern = "_absolute.psi_.*", replacement = "")) %>% dplyr::left_join(., tibble_combined_mapping_info)

```

# Differential splicing detection

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

tibble_matrix_dexseq_IR <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("numerator")) %>% round()
tibble_matrix_dexseq_IR[is.na(tibble_matrix_dexseq_IR)] <- 0

tibble_matrix_dexseq_denominator <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("denominator")) %>% round()
tibble_matrix_dexseq_denominator[is.na(tibble_matrix_dexseq_denominator)] <- 0

# calculate the ER so we can fix the values where IR > denominator.
tibble_matrix_dexseq_ER <- (tibble_matrix_dexseq_denominator - tibble_matrix_dexseq_IR) %>% as_tibble 
tibble_matrix_dexseq_IR[tibble_matrix_dexseq_ER < 0] <- 0

tibble_matrix_dexseq_absolute_psi <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))

# declare comparison groups
list_sample_comparisons <- purrr::splice(
  purrr::map2(.x = tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(~.x$som_cluster %>% unique) %>% unlist, 
              .y = tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(~.x$Type %>% table %>% sort(decreasing = TRUE) %>% names %>% .[1]) %>% unlist %>% gsub(pattern = ".*cell line", replacement = "cell line"), 
              .f = ~list(
                tibble_combined_mapping_info[tibble_combined_mapping_info$condition_names %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster == .x, ] %>% .$condition_names %>% unlist), ] %>% .[.$condition_names %>% is.na != TRUE, ] %>% .$condition_names %>% unlist,
                tibble_combined_mapping_info[!(tibble_combined_mapping_info$condition_names %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster == .x, ] %>% .$condition_names %>% unlist)) & grepl(x = tibble_combined_mapping_info$Type, pattern = .y), ] %>% .[.$condition_names %>% is.na != TRUE, ] %>% .$condition_names %>% unlist)
  ) %>% set_names(nm = paste("som_cluster_", tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(~.x$som_cluster %>% unique) %>% unlist, sep = ""))
)

# list-ify the tables according to comparison
list_of_tibble_matrix_IR_by_sample_type <- purrr::map(
  .x = list_sample_comparisons, # som_cluster
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons[[1]]
    ###########
    
    tibble_comparison_IR_subset <- tibble_matrix_dexseq_IR[, gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "\\_numerator", replacement = "") %in% a1[[1]]]
    
    tibble_anticomparison_IR_subset <- tibble_matrix_dexseq_IR[, gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "\\_numerator", replacement = "") %in% a1[[2]]]
    
    return(
      list(
        "comparison" = tibble_comparison_IR_subset,
        "anticomparison" = tibble_anticomparison_IR_subset
      )
    )
    
  }) 

list_of_tibble_matrix_denominator_by_sample_type <- purrr::map(
  .x = list_sample_comparisons, # som_cluster
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons[[1]]
    ###########
    
    tibble_comparison_denominator_subset <- tibble_matrix_dexseq_denominator[, gsub(x = colnames(tibble_matrix_dexseq_denominator), pattern = "\\_denominator", replacement = "") %in% a1[[1]]]
    
    tibble_anticomparison_denominator_subset <- tibble_matrix_dexseq_denominator[, gsub(x = colnames(tibble_matrix_dexseq_denominator), pattern = "\\_denominator", replacement = "") %in% a1[[2]]]
    
    return(
      list(
        "comparison" = tibble_comparison_denominator_subset,
        "anticomparison" = tibble_anticomparison_denominator_subset
      )
    )
    
  })

list_of_tibble_matrix_absolute_psi_by_sample_type <- purrr::map(
  .x = list_sample_comparisons, # som_cluster
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons[[1]]
    ###########
    
    tibble_comparison_absolute_psi_subset <- tibble_matrix_dexseq_absolute_psi[, gsub(x = colnames(tibble_matrix_dexseq_absolute_psi), pattern = "\\_absolute\\.psi", replacement = "") %in% a1[[1]]]
    
    tibble_anticomparison_absolute_psi_subset <- tibble_matrix_dexseq_absolute_psi[, gsub(x = colnames(tibble_matrix_dexseq_absolute_psi), pattern = "\\_absolute\\.psi", replacement = "") %in% a1[[2]]]
    
    return(
      list(
        "comparison" = tibble_comparison_absolute_psi_subset,
        "anticomparison" = tibble_anticomparison_absolute_psi_subset
      )
    )
    
  })

# check if all columns are matching
vector_logical_all_columns_match <- purrr::pmap(
  .l = list(
    "a1" = list_of_tibble_matrix_IR_by_sample_type %>% purrr::map_depth(.depth = 2, .f = ~.x %>% colnames),
    "a2" = list_of_tibble_matrix_denominator_by_sample_type %>% purrr::map_depth(.depth = 2, .f = ~.x %>% colnames),
    "a3" = list_of_tibble_matrix_absolute_psi_by_sample_type %>% purrr::map_depth(.depth = 2, .f = ~.x %>% colnames)
  ), 
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_of_tibble_matrix_IR_by_sample_type %>% purrr::map_depth(.depth = 2, .f = ~.x %>% colnames) %>% .[[1]]
    # a2 <- list_of_tibble_matrix_denominator_by_sample_type %>% purrr::map_depth(.depth = 2, .f = ~.x %>% colnames) %>% .[[1]]
    # a3 <- list_of_tibble_matrix_absolute_psi_by_sample_type %>% purrr::map_depth(.depth = 2, .f = ~.x %>% colnames) %>% .[[1]]
    ###########
    
    purrr::pmap(
      .l = list(
        "b1" = a1,
        "b2" = a2, 
        "b3" = a3
      ), 
      .f = function(b1, b2, b3) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- a2[[1]]
        # b3 <- a3[[1]]
        ###########
        
        b1_ <- b1 %>% gsub(pattern = "\\_numerator", replacement = "")
        b2_ <- b2 %>% gsub(pattern = "\\_denominator", replacement = "")
        b3_ <- b3 %>% gsub(pattern = "\\_absolute\\.psi", replacement = "")
        
        purrr::pmap(
          .l = list(
            "c1" = b1_,
            "c2" = b2_,
            "c3" = b3_
          ), 
          .f = function(c1, c2, c3) {
            
            return((c(c1, c2, c3) %>% unique %>% length) == 1)
            
          } ) %>% unlist %>% return
        
      } ) %>% unlist %>% return
    
  } ) %>% unlist

if (vector_logical_all_columns_match %>% unlist %>% unique != 1) {
  
  stop("STOP. columns do not match between denominator, IR or absolute PSI")
  
}

library(DoubleExpSeq)
library(future.apply)

FDR_cutoff <- 0.01
dpsi_cutoff <- 10

plan(list(tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 8)))

list_characteristic_markers_per_cluster_DExpSeq_results <- future_pmap(
  list(
    a1 = list_of_tibble_matrix_IR_by_sample_type,
    a2 = list_of_tibble_matrix_denominator_by_sample_type,
    a3 = list_of_tibble_matrix_absolute_psi_by_sample_type,
    a4 = names(list_of_tibble_matrix_IR_by_sample_type),
    a5 = list_sample_comparisons
  ), .f = function(a1, a2, a3, a4, a5) {
    
    # DEBUG ###
    # a1 <- list_of_tibble_matrix_IR_by_sample_type[[12]]
    # a2 <- list_of_tibble_matrix_denominator_by_sample_type[[12]]
    # a3 <- list_of_tibble_matrix_absolute_psi_by_sample_type[[12]]
    # a4 <- names(list_of_tibble_matrix_IR_by_sample_type) %>% .[[12]]
    # a5 <- list_sample_comparisons[[12]]
    ###########
    
    cat(a4, "\n")
    
    plan(list(tweak(multiprocess, workers = 4),
              tweak(multiprocess, workers = 1)))
    
    vector_rows_with_NOT_all_zero_PSI <- future_apply(a3 %>% dplyr::bind_cols(), MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < length(X) } ) %>% unlist %>% which %>% sort
    
    vector_group_names_by_column <- dplyr::left_join(tibble("condition_names" = colnames(a1[[1]]) %>% gsub(pattern = "\\_numerator", replacement = "")), tibble_processed_UMAP_cluster_legend[, c("condition_names", "som_cluster")]) %>% .$som_cluster
    
    vector_dispersions_per_row <- suppressWarnings(suppressMessages(

      DoubleExpSeq::EstimateDEBDisp(y = a1 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ],
                                    m = a2 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ],
                                    groups = c(rep(1, ncol(a1[[1]])),
                                               rep(2, ncol(a1[[2]]))
                                    )
      )

    ))
    
    plan(list(tweak(multiprocess, workers = 8),
              tweak(multiprocess, workers = 1)))
    
    # differential splicing detection
    list_DExpSeq_result <- DoubleExpSeq::DBGLM1(
      y = a1 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ], 
      m = a2 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ],
      shrink.method = "WEB", 
      contrast = c(1, 2),
      groups = c( rep(1, ncol(a1[[1]])), rep(2, ncol(a1[[2]])) ),
      fdr.level = FDR_cutoff, 
      use.all.groups = TRUE
    ) %>% 
      purrr::map(~.x %>% as_tibble(rownames = "rowid_of_elements_which_are_not_all_zero") %>% type_convert %>%
                   # turn the not_all_psi-relative row indices into master table-relative row indices
                   dplyr::mutate("master_row_index" = purrr::map(.x = `rowid_of_elements_which_are_not_all_zero`, .f = ~vector_rows_with_NOT_all_zero_PSI[.x]) %>% unlist
                   )
      )
    
    # fill in the absolute PSI values
    tibble_average_PSIs <- purrr::map2(
      .x = a3,
      .y = names(a3),
      .f = ~.x %>% rowMeans %>% tibble::enframe(name = NULL, value = paste("avg_psi_", .y, sep = ""))) %>% 
      purrr::reduce(dplyr::bind_cols)
    
    # fill in the stdevs for comparison and anticomparison
    tibble_stdevs <- purrr::map2(
      .x = a3,
      .y = names(a3),
      .f = ~.x %>% apply(MARGIN = 1, FUN = function(X) {return(sd(X %>% type.convert(as.is = TRUE)))} ) %>% tibble::enframe(name = NULL, value = paste("stdev_", .y, sep = ""))) %>% 
      purrr::reduce(dplyr::bind_cols) %>%
      suppressMessages() %>%
      suppressWarnings()
    
    list_DExpSeq_result_with_absolute_PSI <- purrr::map(
      .x = list_DExpSeq_result,
      .f = ~dplyr::bind_cols(.x, tibble_average_PSIs[.x$master_row_index, ]) %>% dplyr::bind_cols(., tibble_stdevs[.x$master_row_index, ]) %>% dplyr::mutate("dpsi_comparison_minus_anticomparison" = `avg_psi_comparison` - `avg_psi_anticomparison`))
    
    # only plotting at this stage ###
    
    pdf(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_characteristic_markers_per_cluster_DExpSeq_dispersion_vs_log2_avg_PSI_", a4, ".pdf", sep = ""))
    
    # plot dispersion vs. log2(average PSI) for each row
    plot(x = list_DExpSeq_result_with_absolute_PSI$All %>% .[, c("avg_psi_comparison", "avg_psi_anticomparison")] %>% rowMeans(na.rm = TRUE) %>% log2,
         y = vector_dispersions_per_row)
    
    dev.off()
    
    pdf(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_characteristic_markers_per_cluster_DExpSeq_MA_plot_", a4, ".pdf", sep = ""))
    
    # M-A plot
    DoubleExpSeq::DB.MAPlot(
      y = a1 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ], 
      m = a2 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ],
      groups = c(rep(1, ncol(a1[[1]])), rep(2, ncol(a1[[2]]))),
      contrast = c(1, 2))
    
    dev.off()
    
    pdf(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_characteristic_markers_per_cluster_DExpSeq_WEBseq_optimplot_", a4, ".pdf", sep = ""))
    
    # plot the WEBseq maximum likelihood solution
    DoubleExpSeq::optimPlot(
      y = a1 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ], 
      m = a2 %>% dplyr::bind_cols() %>% .[vector_rows_with_NOT_all_zero_PSI, ],
      groups = c(rep(1, ncol(a1[[1]])), rep(2, ncol(a1[[2]]))),
      use.all.groups = TRUE)
    
    dev.off()
    
    return(list_DExpSeq_result_with_absolute_PSI$Sig %>% dplyr::filter(abs(dpsi_comparison_minus_anticomparison) >= dpsi_cutoff))
    
  }, .progress = TRUE ) 

save(list_characteristic_markers_per_cluster_DExpSeq_results, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_per_som_cluster_DExpSeq_results.Rlist", sep = ""), compress = FALSE)

```

## b) finding the characteristic set of LISs for each chucked out sample (z-scores)

comparisons of every cluster/chucked-out sample vs. the rest in the same sample type e.g. cell line, tissue etc...

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

tibble_chucked_out_items_UMAP <- read.delim(paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_chucked_out_cluster_legend_annotated.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% .[.$condition_names %>% is.na != TRUE, ]

list_sample_comparisons <- purrr::splice(
  purrr::map2(.x = tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$RNA_number %>% unique) %>% unlist, 
              .y = tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$Type %>% table %>% sort(decreasing = TRUE) %>% names %>% .[1]) %>% unlist %>% gsub(pattern = ".*cell line", replacement = "cell line"), 
              .f = ~list(
    tibble_combined_mapping_info[tibble_combined_mapping_info$RNA_number %in% .x, ] %>% .[.$condition_names %>% is.na != TRUE, ] %>% .$condition_names %>% unlist,
    tibble_combined_mapping_info[!(tibble_combined_mapping_info$RNA_number %in% .x) & grepl(x = tibble_combined_mapping_info$Type, pattern = .y), ] %>% .[.$condition_names %>% is.na != TRUE, ] %>% .$condition_names %>% unlist)
  ) %>% set_names(nm = paste("chucked_out_RNA_number_", tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$RNA_number %>% unique) %>% unlist, sep = ""))
)

tibble_VSR_alt_exon_info <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% 
  dplyr::select(contains("event_region"), contains("LIV_exon_coords"), contains("splicemode")) %>% 
  dplyr::mutate("chr" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\1"),
                "VSR_start" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2"),
                "VSR_end" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3"))

tibble_matrix_absolute_psi_table <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))

tibble_matrix_passes_threshold_table <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("_passes_read_threshold"))

# check for column consistency between psi and threshold tables
logical_columns_are_consistent <- purrr::map2(
  .x = gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi", replacement = ""),
  .y = gsub(x = colnames(tibble_matrix_passes_threshold_table), pattern = "\\_passes\\_read\\_threshold", replacement = ""),
  .f = ~.x == .y
) %>% unlist %>% all

if (logical_columns_are_consistent != TRUE){
  stop("inconsistent psi and threshold columns")
}

plan(list(tweak(multiprocess, workers = 48),
          tweak(multiprocess, workers = 3)))

# loop for each row: find the significant items 
delta_PSI_cutoff <- 15
maximum_range_within_sample <- 40 # has to be constitutive within the group
# minimum_range_within_antisample <- 20 # has to be relatively variable over all samples in order to stand out
# max_deviation_from_max <- 20 # less than __%

list_characteristic_markers_for_each_chucked_out_sample <- furrr::future_map2(
  .x = list_sample_comparisons,
  .y = names(list_sample_comparisons),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons[[2]]
    # a2 <- names(list_sample_comparisons) %>% .[[2]]
    ###########
    
    cat(a2, "\n")
    
    # tibble_passes_threshold_comparison_1 <- a1$tibble_passes_threshold_comparison_1
    # tibble_passes_threshold_comparison_2 <- a1$tibble_passes_threshold_comparison_2
    # 
    # tibble_absolute_psi_comparison_1 <- a1$tibble_absolute_psi_comparison_1
    # tibble_absolute_psi_comparison_2 <- a1$tibble_absolute_psi_comparison_2
    
    # fetch column indices of the groups we will be doing comparisons on.
    vector_column_subsetting_indices_comparison_1 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% a1[[1]])
    
    vector_column_subsetting_indices_comparison_2 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% a1[[2]])
    
    vector_column_names_of_tables_comparison_1 <- gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[vector_column_subsetting_indices_comparison_1]
    
    vector_column_names_of_tables_comparison_2 <- gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[vector_column_subsetting_indices_comparison_2]
    
    # fetch the logical vector indicating whether the comparison meets threshold or not
    # tibble_passes_threshold_comparison_1 <- tibble_matrix_passes_threshold_table[, vector_column_subsetting_indices_comparison_1] 
    # 
    # tibble_passes_threshold_comparison_2 <- tibble_matrix_passes_threshold_table[, vector_column_subsetting_indices_comparison_2] 
    
    tibble_absolute_psi_comparison_1 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_1]
    
    tibble_absolute_psi_comparison_2 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_2]
    
    # vector_passes_threshold_comparison_1 <- tibble_passes_threshold_comparison_1 %>% 
    #   future_apply(MARGIN = 1, FUN = function(X) {all((X %>% na.omit) == TRUE) %>% return})
    # 
    # vector_passes_threshold_comparison_2 <- tibble_passes_threshold_comparison_2 %>% 
    #   future_apply(MARGIN = 1, FUN = function(X) {all((X %>% na.omit) == TRUE) %>% return})
    
    # subset the absolute PSI table based on comparison, and average the values for every item.
    vector_average_PSI_per_item_comparison_1 <- tibble_absolute_psi_comparison_1 %>%
      rowMeans()
    
    vector_average_PSI_per_item_comparison_2 <- tibble_absolute_psi_comparison_2 %>%
      rowMeans()
    
    # also take the stdev
    vector_stdevs_per_item_comparison_1 <- tibble_absolute_psi_comparison_1 %>%
      future_apply(MARGIN = 1, FUN = function(X) {sd(X, na.rm =  TRUE) %>% return} )
    
    vector_stdevs_per_item_comparison_2 <- tibble_absolute_psi_comparison_2 %>%
      future_apply(MARGIN = 1, FUN = function(X) {sd(X, na.rm =  TRUE) %>% return} )
    
    # sum up the stdevs per row, ignoring NAs.
    vector_sum_stdevs_per_row <- furrr::future_map2(
      .x = vector_stdevs_per_item_comparison_1,
      .y = vector_stdevs_per_item_comparison_2,
      .f = function(c1, c2) {
        
        if (c1 %>% is.na == TRUE) {
          stdev_comparison_1 <- 0
        } else {
          stdev_comparison_1 <- c1
        }
        
        if (c2 %>% is.na == TRUE) {
          stdev_comparison_2 <- 0
        } else {
          stdev_comparison_2 <- c2
        }
        
        return((stdev_comparison_1^2 + stdev_comparison_2^2)^(1/2))
        
      } ) %>% unlist
    
    # also get the range
    vector_max_per_item_comparison_1 <- tibble_absolute_psi_comparison_1 %>%
      future_apply(MARGIN = 1, FUN = function(X) {max(X, na.rm =  TRUE) %>% return} )
    
    vector_min_per_item_comparison_1 <- tibble_absolute_psi_comparison_1 %>%
      future_apply(MARGIN = 1, FUN = function(X) {min(X, na.rm =  TRUE) %>% return} )
    
    vector_max_per_item_comparison_2 <- tibble_absolute_psi_comparison_2 %>%
      future_apply(MARGIN = 1, FUN = function(X) {max(X, na.rm =  TRUE) %>% return} )
    
    vector_min_per_item_comparison_2 <- tibble_absolute_psi_comparison_2 %>%
      future_apply(MARGIN = 1, FUN = function(X) {min(X, na.rm =  TRUE) %>% return} )
    
    # test for differential splicing
    vector_row_indices_positive_markers <- furrr::future_pmap(
      .l = list(
        "c1" = vector_average_PSI_per_item_comparison_1,
        "c2" = vector_average_PSI_per_item_comparison_2,
        "c3" = vector_sum_stdevs_per_row,
        "c4" = vector_max_per_item_comparison_1,
        "c5" = vector_min_per_item_comparison_1,
        "c6" = vector_max_per_item_comparison_2,
        "c7" = vector_min_per_item_comparison_2
      ),
      .f = function(c1, c2, c3, c4, c5, c6, c7) {
        
        # DEBUG ###
        # c1 <- vector_average_PSI_per_item_comparison_1[[1]]
        # c2 <- vector_average_PSI_per_item_comparison_2[[1]]
        # c3 <- vector_sum_stdevs_per_row[[1]]
        # c4 <- vector_range_per_item_comparison_1[[1]]
        # c5 <- vector_range_per_item_comparison_2[[1]]
        # c6 <- vector_max_per_item_comparison_2[[1]]
        # c7 <- vector_min_per_item_comparison_2[[1]]
        ###########
        
        return(
          (c1 - c2) >= delta_PSI_cutoff &
            # vector_passes_threshold_comparison_1 == TRUE &
            abs(c4 - c5) < maximum_range_within_sample 
          # &
          #   abs(c6 - c7) > minimum_range_within_antisample 
          # &
          #   c1 > max(c4, c6) - max_deviation_from_max
        )
        
      } ) %>% 
      unlist %>% which
    
    vector_row_indices_negative_markers <- furrr::future_pmap(
      .l = list(
        "c1" = vector_average_PSI_per_item_comparison_1,
        "c2" = vector_average_PSI_per_item_comparison_2,
        "c3" = vector_sum_stdevs_per_row,
        "c4" = vector_max_per_item_comparison_1,
        "c5" = vector_min_per_item_comparison_1,
        "c6" = vector_max_per_item_comparison_2,
        "c7" = vector_min_per_item_comparison_2
      ),
      .f = function(c1, c2, c3, c4, c5, c6, c7) {
        
        # DEBUG ###
        # c1 <- vector_average_PSI_per_item_comparison_1[[1]]
        # c2 <- vector_average_PSI_per_item_comparison_2[[1]]
        # c3 <- vector_sum_stdevs_per_row[[1]]
        # c4 <- vector_range_per_item_comparison_1[[1]]
        # c5 <- vector_range_per_item_comparison_2[[1]]
        # c6 <- vector_max_per_item_comparison_2[[1]]
        # c7 <- vector_min_per_item_comparison_2[[1]]
        ###########
        
        return(
          (c2 - c1) >= delta_PSI_cutoff &
            # vector_passes_threshold_comparison_1 == TRUE &
            abs(c4 - c5) < maximum_range_within_sample
          # &
          #   abs(c6 - c7) > minimum_range_within_antisample 
          # &
          #   c1 > max(c4, c6) - max_deviation_from_max
        )
        
      } ) %>% 
      unlist %>% which
    
    return(list(
      "vector_row_indices_positive_markers" = vector_row_indices_positive_markers,
      "vector_row_indices_negative_markers" = vector_row_indices_negative_markers
    ))
    
  }, .progress = TRUE )

save(list_characteristic_markers_for_each_chucked_out_sample, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample.Rlist", sep = ""))

# plan(list(tweak(multiprocess, workers = 33),
#           tweak(multiprocess, workers = 2),
#           tweak(multiprocess, workers = 8)))

list_characteristic_markers_for_each_chucked_out_sample_alt_exon_info <- purrr::pmap(
  .l = list(
    "a1" = list_sample_comparisons,
    "a2" = names(list_sample_comparisons),
    "a3" = list_characteristic_markers_for_each_chucked_out_sample
  ),
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons[[1]]
    # a2 <- names(list_sample_comparisons) %>% .[[1]]
    # a3 <- list_characteristic_markers_for_each_chucked_out_sample[[1]]
    ###########
    
    cat(a2, "\n")
    
    purrr::map2(
      .x = a1,
      .y = a3,
      .f = function(b1, b3) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        return(tibble_VSR_alt_exon_info[b3 %>% unlist, ])
        
      } ) %>% set_names(nm = names(a3)) %>% 
      return
    
  } )

save(list_characteristic_markers_for_each_chucked_out_sample_alt_exon_info, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_alt_exon_info.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_group_alt_exon_info.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 48),
          tweak(multiprocess, workers = 3)))

# also get the row indices that passed numerator filtering
list_characteristic_markers_for_each_chucked_out_sample_row_indices_passed_threshold <- furrr::future_map2(
  .x = list_sample_comparisons,
  .y = names(list_sample_comparisons),
  .f = function(a1, a2) { 
    
    # DEBUG ###
    # a1 <- list_sample_comparisons[[2]]
    # a2 <- names(list_sample_comparisons) %>% .[[2]]
    ###########
    
    cat(a2, "\n")
    
    # fetch column indices of the groups we will be doing comparisons on.
    vector_column_subsetting_indices_comparison_1 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% a1[[1]])
    
    vector_column_subsetting_indices_comparison_2 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% a1[[2]])
    
    vector_column_names_of_tables_comparison_1 <- gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[vector_column_subsetting_indices_comparison_1]
    
    vector_column_names_of_tables_comparison_2 <- gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[vector_column_subsetting_indices_comparison_2]
    
    # fetch the logical vector indicating whether the comparison meets threshold or not
    tibble_passes_threshold_comparison_1 <- tibble_matrix_passes_threshold_table[, vector_column_subsetting_indices_comparison_1]

    tibble_passes_threshold_comparison_2 <- tibble_matrix_passes_threshold_table[, vector_column_subsetting_indices_comparison_2]

    vector_passes_threshold_comparison_1 <- tibble_passes_threshold_comparison_1 %>%
      future_apply(MARGIN = 1, FUN = function(X) {any((X %>% na.omit) == TRUE) %>% return})

    vector_passes_threshold_comparison_2 <- tibble_passes_threshold_comparison_2 %>%
      future_apply(MARGIN = 1, FUN = function(X) {any((X %>% na.omit) == TRUE) %>% return})
    
    return(list(
      "vector_passes_threshold_cluster" = vector_passes_threshold_comparison_1,
      "vector_passes_threshold_anticluster" = vector_passes_threshold_comparison_2
    ))
    
  }, .progress = TRUE )

save(list_characteristic_markers_for_each_chucked_out_sample_row_indices_passed_threshold, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_row_indices_passed_threshold.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_row_indices_passed_threshold.Rlist", sep = ""))

# plan(list(tweak(multiprocess, workers = 4),
#           tweak(multiprocess, workers = 1)))

# filter DS results by threshold
list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold <- purrr::pmap(
  .l = list(
    "a1" = list_characteristic_markers_for_each_chucked_out_sample,
    "a2" = list_characteristic_markers_for_each_chucked_out_sample_row_indices_passed_threshold,
    "a3" = names(list_characteristic_markers_for_each_chucked_out_sample)
  ), 
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_chucked_out_sample[[1]]
    # a2 <- list_characteristic_markers_for_each_chucked_out_sample_row_indices_passed_threshold[[1]]
    # a3 <- names(list_characteristic_markers_for_each_chucked_out_sample) %>% .[[1]]
    # a4 <- list_characteristic_markers_for_each_group_filtered_by_SJ_existence[[1]]
    ###########
    
    cat(a3, "\n")
    
    vector_passes_threshold_cluster <- a2$vector_passes_threshold_cluster %>% which
    vector_passes_threshold_anticluster <- a2$vector_passes_threshold_anticluster %>% which
    
    vector_row_indices_positive_markers_passing_threshold <- intersect(a1$vector_row_indices_positive_markers, vector_passes_threshold_cluster)
    vector_row_indices_negative_markers_passing_threshold <- intersect(a1$vector_row_indices_negative_markers, vector_passes_threshold_anticluster)
    
    return(list(
      "vector_row_indices_positive_markers_passing_threshold" = vector_row_indices_positive_markers_passing_threshold,
      "vector_row_indices_negative_markers_passing_threshold" = vector_row_indices_negative_markers_passing_threshold
    ))
    
  } )

save(list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold.Rlist", sep = ""), compress = FALSE)

```

## NOT USED: c) comparisons of distinct cell types within clusters (z-scores)

```{r eval=FALSE, include=FALSE}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

# cryptic function to create a list where .[[1]] = comparison 1, .[[2]] = comparison 2
create_comparison_from_sample_number_and_cluster <- function(vector_cluster_1, vector_cluster_2, cluster_number, tibble_mapping_file, comparison_1_vs_rest = NULL) {
  
  if (comparison_1_vs_rest == TRUE) {
    
    return(
      list(
        vector_cluster_1, tibble_mapping_file[tibble_mapping_file$som_cluster == cluster_number & !tibble_mapping_file$cluster_number %in% vector_cluster_1, ] %>% .$cluster_number
      )
    )
    
  } else if (comparison_1_vs_rest == FALSE) {
    
    return(
      list(
        vector_cluster_1, vector_cluster_2
      )
    )
    
  }
  
}

list_sample_comparisons_intra_cluster <- list(
  "1" = list(
    "fetal keratinocyte vs. ECs" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(9, 10), cluster_number = "1", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "2" = list(
    "muscle cells vs. fibroblast/msc" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(17, 18, 43, 44, 63, 65, 179), vector_cluster_2 = c(66, 69, 174, 204, 206, 207), comparison_1_vs_rest = FALSE),
    "muscle cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(17, 18, 43, 44, 63, 65, 179), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "adrenal cortical cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(21, 22), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "choroid plexus epithelial vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(35), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "pancreatic stellate vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(49), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "epidermal melanocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(56), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "fibroblast/msc vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(66, 69, 174, 204, 206, 207), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "dermal papilla cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(175), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "femoral OB vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(186), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "synoviocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(188), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "nucleus pulposus vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(189), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "annulus fibrosus vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(190), cluster_number = "2", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "3" = list(
    "muscle cells vs. fibroblast/msc" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(15, 16, 25, 26, 182, 184), vector_cluster_2 = c(47, 57, 64, 177, 178, 225), comparison_1_vs_rest = FALSE),
    "muscle cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(15, 16, 25, 26, 182, 184), cluster_number = "3", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "schwann cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(3, 4), cluster_number = "3", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "brain vasc. pericyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(34), cluster_number = "3", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "astrocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(37, 54), cluster_number = "3", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "fibroblast/msc vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(47, 57, 64, 177, 178, 225), cluster_number = "3", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "hepatic stellate vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(209), cluster_number = "3", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "4" = list(
    "mesodermal vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(194, 197, 230, 233, 237, 238, 254, 255, 262, 263), cluster_number = "4", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "5" = list(
    "esoph. smooth muscle vs. fibroblast/msc" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(13, 14), vector_cluster_2 = c(52, 229, 240, 272, 273), comparison_1_vs_rest = FALSE),
    "perineural cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(5, 6), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "esoph. smooth muscle cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(13, 14), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "astrocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(36, 55, 170), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "melanocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(39), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "fibroblast vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(52, 229, 240, 272, 273), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "meningeal cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(53), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "trabecular meshwork cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(222), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "epithelial cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(280, 281), cluster_number = "5", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "6" = list(
    "keratinocytes vs. rest epithelial cells" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(40, 176), cluster_number = "6", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "8" = list(
    "T-ALL vs. rest B-ALL" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(157:159, 292), cluster_number = "8", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "9" = list(
    "T-ALL vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(136, 137, 140, 151, 155), cluster_number = "9", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "CML vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(154, 296), cluster_number = "9", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "multiple myeloma vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(152), cluster_number = "9", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "B-cell lines vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(141, 142), cluster_number = "9", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "10" = list(
    "colon cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(83, 84, 293, 294), cluster_number = "10", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "prostate cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(79, 80), cluster_number = "10", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "nsc lung cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(81, 82, 91, 92), cluster_number = "10", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "ovarian cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(131), cluster_number = "10", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "11" = list(
    "normal neuron, oligodend. precursor vs. rest neuroblastoma" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(168, 169), cluster_number = "11", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "12" = list(
    "skeletal muscle vs. rest heart tissue" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(217), cluster_number = "12", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "13" = list(
    "foll. inner root sheath cell vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(11, 12), cluster_number = "13", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "fibroblast vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(33, 42, 51, 199, 245), cluster_number = "13", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "smooth muscle vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(278, 279, 286), cluster_number = "13", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "14" = list(
    "neuroblastoma vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(77, 78), cluster_number = "14", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "melanoma vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(87, 88), cluster_number = "14", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "CNS cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(94, 95, 101), cluster_number = "14", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "breast cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(128, 147), cluster_number = "14", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "nsc lung cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(148, 297), cluster_number = "14", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "15" = list(
    "fibroblast/msc vs. epithelial cell" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(58, 203, 205, 208, 228, 276, 282, 283), vector_cluster_2 = c(200, 202), comparison_1_vs_rest = FALSE)
  ),
  "16" = list(
    "NK cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(71, 72), cluster_number = "16", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "B cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(73, 74), cluster_number = "16", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "monocytes vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(139, 288), cluster_number = "16", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "T cells vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(287), cluster_number = "16", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "17" = list(
    "CNS cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(100, 153, 300, 301), cluster_number = "17", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "ovarian cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(133, 295), cluster_number = "17", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "renal cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(134), cluster_number = "17", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "neuroblastoma vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(143, 289), cluster_number = "17", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "nsc lung cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(145), cluster_number = "17", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "melanoma vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(149), cluster_number = "17", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "19" = list(
    "breast cancer vs. rest colon cancer" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(127, 150), cluster_number = "19", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "20" = list(
    "endodermal vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(215, 218, 236, 260, 261, 267), cluster_number = "20", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "21" = list(
    "neon. epidermal keratinocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(7, 8), cluster_number = "21", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "alv. M0 vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(31, 32), cluster_number = "21", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "stomach vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(266), cluster_number = "21", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "renal cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(299), cluster_number = "21", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "22" = list(
    "iDCs vs. mDCs" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(112, 113), vector_cluster_2 = c(114, 115), comparison_1_vs_rest = FALSE),
    "alv. M0 vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(187), cluster_number = "22", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "23" = list(
    "smooth muscle vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(1, 2), cluster_number = "23", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "fibroblast vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(48, 221), cluster_number = "23", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "lens epithelial vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(201), cluster_number = "23", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "24" = list(
    "OVCAR vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(93, 129, 130), cluster_number = "24", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "nsc lung cancer vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(298), cluster_number = "24", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "BRCAR vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(303), cluster_number = "24", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "25" = list(
    "neuroblastoma vs. rest melanoma" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(29, 30), cluster_number = "25", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "27" = list(
    "aortic smooth muscle vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(198), cluster_number = "27", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "cardiomyocyte vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(219), cluster_number = "27", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE),
    "cardiac fibroblast vs. rest" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(220, 239), cluster_number = "27", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "28" = list(
    "spinal cord astrocyte vs. rest fibroblast/MSC" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(38), cluster_number = "28", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE)
  ),
  "29" = list(
    "jejunum vs. distal colon" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(248, 249), vector_cluster_2 = c(193), comparison_1_vs_rest = FALSE)
  ),
  "30" = list(
    "adrenal gland vs. liver" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(264, 265), vector_cluster_2 = c(234), comparison_1_vs_rest = FALSE)
  ),
  "31" = list(
    "CD10+ vs. CD14-CD15+" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(75, 76), vector_cluster_2 = c(118), comparison_1_vs_rest = FALSE)
  ),
  "32" = list(
    "LGL leukemia vs. APL" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(116, 117), vector_cluster_2 = c(125), comparison_1_vs_rest = FALSE)
  )
)

tibble_matrix_absolute_psi_table <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))

tibble_matrix_passes_threshold_table <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("_passes_read_threshold"))

# check for column consistency between psi and threshold tables
logical_columns_are_consistent <- purrr::map2(
  .x = gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi", replacement = ""),
  .y = gsub(x = colnames(tibble_matrix_passes_threshold_table), pattern = "\\_passes\\_read\\_threshold", replacement = ""),
  .f = ~.x == .y
) %>% unlist %>% all

if (logical_columns_are_consistent != TRUE){
  stop("inconsistent psi and threshold columns")
}

# loop for each row: find the significant items 
delta_PSI_cutoff <- 15
# maximum_total_stdev <- 20 # less than 20%
maximum_range_per_comparison <- 30

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 10),
          tweak(multiprocess, workers = 2)))

list_differential_comparisons_within_clusters <- furrr::future_map2(
  .x = list_sample_comparisons_intra_cluster,
  .y = names(list_sample_comparisons_intra_cluster),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons_intra_cluster[[2]]
    # a2 <- names(list_sample_comparisons_intra_cluster) %>% .[[2]]
    ###########
    
    cat(a2, "\n")
    
    list_differential_comparison <- furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # fetch column indices of the groups we will be doing comparisons on.
        vector_column_subsetting_indices_comparison_1 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$cluster_number %in% b1[[1]], ] %>% .$condition_names))
        
        vector_column_subsetting_indices_comparison_2 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$cluster_number %in% b1[[2]], ] %>% .$condition_names))
        
        vector_column_names_of_tables_comparison_1 <- gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[vector_column_subsetting_indices_comparison_1]
        
        vector_column_names_of_tables_comparison_2 <- gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[vector_column_subsetting_indices_comparison_2]
        
        vector_condition_names_comparison_1 <- vector_column_names_of_tables_comparison_1
        
        vector_condition_names_comparison_2 <- vector_column_names_of_tables_comparison_2
        
        # subset the absolute PSI table based on comparison, and average the values for every item.
        vector_average_PSI_per_item_comparison_1 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_1] %>%
          rowMeans()
        
        vector_average_PSI_per_item_comparison_2 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_2] %>%
          rowMeans()
        
        plan(list(tweak(multiprocess, workers = 2)))
        
        # also take the stdev
        vector_stdevs_per_item_comparison_1 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_1] %>%
          future_apply(MARGIN = 1, FUN = function(X) {sd(X) %>% return} )
        
        vector_stdevs_per_item_comparison_2 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_2] %>%
          future_apply(MARGIN = 1, FUN = function(X) {sd(X) %>% return} )
        
        # sum up the stdevs per row, ignoring NAs.
        vector_sum_stdevs_per_row <- furrr::future_map2(
          .x = vector_stdevs_per_item_comparison_1,
          .y = vector_stdevs_per_item_comparison_2,
          .f = function(c1, c2) {
            
            if (c1 %>% is.na == TRUE) {
              stdev_comparison_1 <- 0
            } else {
              stdev_comparison_1 <- c1
            }
            
            if (c2 %>% is.na == TRUE) {
              stdev_comparison_2 <- 0
            } else {
              stdev_comparison_2 <- c2
            }
            
            return((stdev_comparison_1^2 + stdev_comparison_2^2)^(1/2))
            
          } ) %>% unlist
        
        # also get the range
        vector_range_per_item_comparison_1 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_1] %>%
          future_apply(MARGIN = 1, FUN = function(X) {(max(X) - min(X)) %>% return} )
        
        vector_range_per_item_comparison_2 <- tibble_matrix_absolute_psi_table[, vector_column_subsetting_indices_comparison_2] %>%
          future_apply(MARGIN = 1, FUN = function(X) {(max(X) - min(X)) %>% return} )
        
        # test for differential splicing
        vector_column_indices_differential_comparison_1_greater <- furrr::future_pmap(
          .l = list(
            "c1" = vector_average_PSI_per_item_comparison_1,
            "c2" = vector_average_PSI_per_item_comparison_2,
            "c3" = vector_sum_stdevs_per_row,
            "c4" = vector_range_per_item_comparison_1,
            "c5" = vector_range_per_item_comparison_2
          ),
          .f = function(c1, c2, c3, c4, c5) {
            
            # DEBUG ###
            # c1 <- vector_average_PSI_per_item_comparison_1[[1]]
            # c2 <- vector_average_PSI_per_item_comparison_2[[1]]
            # c3 <- vector_sum_stdevs_per_row[[1]]
            # c4 <- vector_range_per_item_comparison_1[[1]]
            # c5 <- vector_range_per_item_comparison_2[[1]]
            ###########
            
            return(
              c1 - c2 >= delta_PSI_cutoff &
                # c3 < maximum_total_stdev &
                c4 < maximum_range_per_comparison &
                c5 < maximum_range_per_comparison
            )
            
          } ) %>% 
          unlist %>% which
        
        vector_column_indices_differential_comparison_2_greater <- furrr::future_pmap(
          .l = list(
            "c1" = vector_average_PSI_per_item_comparison_1,
            "c2" = vector_average_PSI_per_item_comparison_2,
            "c3" = vector_sum_stdevs_per_row,
            "c4" = vector_range_per_item_comparison_1,
            "c5" = vector_range_per_item_comparison_2
          ),
          .f = function(c1, c2, c3, c4, c5) {
            
            # DEBUG ###
            # c1 <- vector_average_PSI_per_item_comparison_1[[1]]
            # c2 <- vector_average_PSI_per_item_comparison_2[[1]]
            # c3 <- vector_sum_stdevs_per_row[[1]]
            # c4 <- vector_range_per_item_comparison_1[[1]]
            # c5 <- vector_range_per_item_comparison_2[[1]]
            ###########
            
            return(
              c2 - c1 >= delta_PSI_cutoff &
                # c3 < maximum_total_stdev &
                c4 < maximum_range_per_comparison &
                c5 < maximum_range_per_comparison
            )
            
          } ) %>% 
          unlist %>% which
        
        return(list(
          "vector_column_indices_differential_comparison_1_greater" = vector_column_indices_differential_comparison_1_greater,
          "vector_column_indices_differential_comparison_2_greater" = vector_column_indices_differential_comparison_2_greater
        ))
        
      } )
    
    return(list_differential_comparison)
    
  }, .progress = TRUE )

# prune
list_differential_comparisons_within_clusters_pruned <- purrr::map(.x = list_differential_comparisons_within_clusters, .f = ~.x %>% purrr::discard(.p = ~.x %>% unlist %>% length == 0)) %>% purrr::discard(.p = ~.x %>% unlist %>% length == 0)

save(list_differential_comparisons_within_clusters_pruned, file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_pruned.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_pruned.Rlist", sep = ""))

list_sample_comparisons_intra_cluster_pruned <- purrr::map2(
  .x = list_differential_comparisons_within_clusters_pruned, 
  .y = list_sample_comparisons_intra_cluster[names(list_differential_comparisons_within_clusters_pruned)], 
  .f = function(aa1, aa2) {
    
    # DEBUG ###
    # aa1 <- list_differential_comparisons_within_clusters_pruned[[1]]
    # aa2 <- list_sample_comparisons_intra_cluster[names(list_differential_comparisons_within_clusters_pruned)] %>% .[[1]]
    ###########
    
    aa2[names(aa1)] %>% return
    
  } )

plan(list(tweak(multiprocess, workers = 35),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 3)))

# compute thresholds
list_differential_comparisons_within_clusters_pruned_threshold <- furrr::future_map2(
  .x = list_sample_comparisons_intra_cluster_pruned,
  .y = names(list_sample_comparisons_intra_cluster_pruned),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_sample_comparisons_intra_cluster_pruned[[1]]
    # a2 <- names(list_sample_comparisons_intra_cluster_pruned) %>% .[[1]]
    ###########
    
    cat(a2, "\n")
    
    furrr::future_map(
      .x = a1,
      .f = function(a1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # fetch column indices of the groups we will be doing comparisons on.
        vector_column_subsetting_indices_comparison_1 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$cluster_number %in% b1[[1]], ] %>% .$condition_names))
        
        vector_column_subsetting_indices_comparison_2 <- which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$cluster_number %in% b1[[2]], ] %>% .$condition_names))
        
        return(
          list(
            "comparison_1_passes_threshold" = tibble_matrix_passes_threshold_table[, vector_column_subsetting_indices_comparison_1] %>% future_apply(MARGIN = 1, FUN = function(X) {all((X %>% na.omit) == TRUE) %>% return}),
            "comparison_2_passes_threshold" = tibble_matrix_passes_threshold_table[, vector_column_subsetting_indices_comparison_2] %>% future_apply(MARGIN = 1, FUN = function(X) {all((X %>% na.omit) == TRUE) %>% return})
          )
        )
        
      } ) %>% return
    
  }, .progress = TRUE )

save(list_differential_comparisons_within_clusters_pruned_threshold, file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_pruned_threshold.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_pruned_threshold.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 16)))

# filter by row indices passing threshold 
list_differential_comparisons_within_clusters_filtered_by_threshold <- purrr::map2(
  .x = list_differential_comparisons_within_clusters_pruned, 
  .y = list_differential_comparisons_within_clusters_pruned_threshold,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_differential_comparisons_within_clusters_pruned[[1]]
    # a2 <- list_differential_comparisons_within_clusters_pruned_threshold[[1]]
    ###########
    
    purrr::map2(
      .x = a1,
      .y = a2,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- a2[[1]]
        ###########
        
        return(
          list(
            "vector_column_indices_differential_comparison_1_greater_filtered" = intersect(b1$vector_column_indices_differential_comparison_1_greater, b2$comparison_1_passes_threshold %>% which),
            "vector_column_indices_differential_comparison_2_greater_filtered" = intersect(b1$vector_column_indices_differential_comparison_2_greater, b2$comparison_2_passes_threshold %>% which) 
          )
        )
        
      } ) %>% return
    
  } )

list_differential_comparisons_within_clusters_filtered_by_threshold <- purrr::map(.x = list_differential_comparisons_within_clusters_filtered_by_threshold, .f = ~.x %>% purrr::discard(.p = ~.x %>% unlist %>% length == 0)) %>% purrr::discard(.p = ~.x %>% unlist %>% length == 0)

save(list_differential_comparisons_within_clusters_filtered_by_threshold, file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_filtered_by_threshold.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_filtered_by_threshold.Rlist", sep = ""))

```

## d) comparison within cell/tissue types of different clusters (z-scores)

i.e. deconvolution of subtypes

```{r eval=FALSE, include=FALSE}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

list_condition_names_of_cell_or_tissue_types_in_multiple_clusters <- list(
  "fibroblasts" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "fibroblast", ignore.case = TRUE, useBytes = TRUE), ],
  "MSCs" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "mesenchymal", ignore.case = TRUE, useBytes = TRUE), ],
  "smooth_muscle" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "smooth muscle", ignore.case = TRUE, useBytes = TRUE), ],
  "epithelial_cells" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "epithelial", ignore.case = TRUE, useBytes = TRUE), ],
  "T-ALL" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "T\\-ALL", ignore.case = TRUE, useBytes = TRUE), ],
  "neuroblastoma" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "neuroblastoma", ignore.case = TRUE, useBytes = TRUE), ],
  "ovarian_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "ovarian cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "breast_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "breast cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "cns_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "CNS cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "NSC_lung_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "non\\-small cell", ignore.case = TRUE, useBytes = TRUE), ],
  "prostate_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "prostate cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "renal_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "renal cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "keratinocyte" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "keratinocyte", ignore.case = TRUE, useBytes = TRUE), ],
  "astrocyte" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "astrocyte", ignore.case = TRUE, useBytes = TRUE), ],
  "macrophage" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "macrophage", ignore.case = TRUE, useBytes = TRUE), ]
) %>% 
  purrr::map(.f = ~.x %>% dplyr::group_split(som_cluster))

tibble_VSR_alt_exon_info <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% 
  dplyr::select(contains("event_region"), contains("LIV_exon_coords"), contains("splicemode")) %>% 
  dplyr::mutate("chr" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\1"),
                "VSR_start" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2"),
                "VSR_end" = `event_region` %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3"))

tibble_matrix_absolute_psi_table <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))

tibble_matrix_passes_threshold_table <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("_passes_read_threshold"))

# we have to now subset the correct columns of absolute PSI for each comparison, then we will take the average PSI. this will be the PSI for each comparison group.
# the result is a list of tibbles for each comparison class. Each column of the tibble represents the average PSI of one comparison group within the class.
list_of_average_psi_tibbles_for_each_comparison_class <- purrr::map(
  .x = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_condition_names_of_cell_or_tissue_types_in_multiple_clusters[[1]]
    ###########
    
    # each L2 element will be a comparison group. we extract the condition names for each comparison group in order to get a vector of average PSI values, then cbind into a tibble.
    tibble_average_psi_for_each_comparison_group <- purrr::map2(
      .x = a1,
      .y = a1 %>% purrr::map(~.x$som_cluster %>% unique) %>% unlist %>% as.character,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- a1 %>% purrr::map(~.x$som_cluster %>% unique) %>% unlist %>% as.character %>% .[[1]]
        ###########
        
        # subset the absolute PSi table 
        vector_col_indices_of_columns_to_subset <- which(gsub(x = tibble_matrix_absolute_psi_table %>% colnames, pattern = "\\_absolute\\.psi", replacement = "") %in% b1$condition_names)
        
        tibble_subset_absolute_psi_table <- tibble_matrix_absolute_psi_table[, vector_col_indices_of_columns_to_subset]
        
        # take average by row
        vector_average_psi_per_row <- tibble_subset_absolute_psi_table %>% rowMeans()
        
        return(vector_average_psi_per_row)
        
      } ) %>%
      set_names(nm = a1 %>% purrr::map(~.x$som_cluster %>% unique) %>% unlist %>% as.character %>% paste("som_cluster_", ., sep = "")) %>%
      as_tibble
    
    # tibblise
    return(tibble_average_psi_for_each_comparison_group)
    
  } )

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 4)))

# get the mean, standard deviation and min/max of LISs in each row
list_vector_mean_each_LIS_per_row <- furrr::future_map(.x = list_of_average_psi_tibbles_for_each_comparison_class, .f = ~future.apply::future_apply(
  X = .x,
  MARGIN = 1,
  FUN = function(X) {base::mean(X, na.rm = TRUE)} ), .progress = TRUE)
  
list_vector_stdevs_each_LIS_per_row <- furrr::future_map(.x = list_of_average_psi_tibbles_for_each_comparison_class, .f = ~future.apply::future_apply(
  X = .x,
  MARGIN = 1,
  FUN = function(X) {stats::sd(X, na.rm = TRUE)} ), .progress = TRUE)

list_vector_min_each_LIS_per_row <- furrr::future_map(.x = list_of_average_psi_tibbles_for_each_comparison_class, .f = ~future.apply::future_apply(
  X = .x,
  MARGIN = 1,
  FUN = function(X) {base::min(X, na.rm = TRUE)} ), .progress = TRUE)

list_vector_max_each_LIS_per_row <- furrr::future_map(.x = list_of_average_psi_tibbles_for_each_comparison_class, .f = ~future.apply::future_apply(
  X = .x,
  MARGIN = 1,
  FUN = function(X) {base::max(X, na.rm = TRUE)} ), .progress = TRUE)

list_of_scaled_average_psi_tibbles_for_each_comparison_class <- furrr::future_map(.x = list_of_average_psi_tibbles_for_each_comparison_class, .f = ~.x %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble, .progress = TRUE)

# loop for each row: find the significant items
# z_score_cutoff <- 1.645 # higher than 90%
# z_score_cutoff <- 1.282 # higher than 80%
minimum_range_between_clusters <- 30
max_deviation_from_min_or_max <- 5

list_of_average_psi_tibbles_for_each_comparison_class_array_tree <- list_of_average_psi_tibbles_for_each_comparison_class %>% 
  furrr::future_map(.f = ~.x %>% array_tree(margin = 1), .progress = TRUE)

list_of_scaled_average_psi_tibbles_for_each_comparison_class_array_tree <- list_of_scaled_average_psi_tibbles_for_each_comparison_class %>% 
  furrr::future_map(.f = ~.x %>% array_tree(margin = 1), .progress = TRUE)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8)))

list_differential_result_sample_subtypes_between_clusters <- furrr::future_pmap(
  .l = list(
    "a1" = list_vector_min_each_LIS_per_row,
    "a2" = list_vector_max_each_LIS_per_row,
    "a3" = list_of_average_psi_tibbles_for_each_comparison_class_array_tree,
    "a4" = list_of_scaled_average_psi_tibbles_for_each_comparison_class_array_tree,
    "a5" = list_of_average_psi_tibbles_for_each_comparison_class
  ),
  .f = function(a1, a2, a3, a4, a5) {
    
    # DEBUG ###
    # a1 <- list_vector_min_each_LIS_per_row[[1]]
    # a2 <- list_vector_max_each_LIS_per_row[[1]]
    # a3 <- list_of_average_psi_tibbles_for_each_comparison_class_array_tree[[1]]
    # a4 <- list_of_scaled_average_psi_tibbles_for_each_comparison_class_array_tree[[1]]
    # a5 <- list_of_average_psi_tibbles_for_each_comparison_class[[1]]
    ###########
    
    list_items_differentially_spliced_high <- furrr::future_pmap(
      .l = list(
        "b1" = a1,
        "b2" = a2,
        "b3" = a3,
        "b4" = a4
      ),
      .f = function(b1, b2, b3, b4) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- a2[[1]]
        # b3 <- a3[[1]]
        # b4 <- a4[[1]]
        ###########
        
        vector_row_in_psi <- b3 %>% unlist
        vector_row_in_zscore <- b4 %>% unlist
        
        vector_column_indices_differential <- which(
          abs(b1 - b2) > minimum_range_between_clusters &
            vector_row_in_psi > abs(b2 - max_deviation_from_min_or_max)
          # &
          #   vector_row_in_zscore %>% unlist >= z_score_cutoff
        )
        
        return(vector_column_indices_differential)
        
      }, .progress = TRUE )
    
    list_items_differentially_spliced_low <- furrr::future_pmap(
      .l = list(
        "b1" = a1,
        "b2" = a2,
        "b3" = a3,
        "b4" = a4
      ),
      .f = function(b1, b2, b3, b4) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- a2[[1]]
        # b3 <- a3[[1]]
        # b4 <- a4[[1]]
        ###########
        
        vector_row_in_psi <- b3 %>% unlist
        vector_row_in_zscore <- b4 %>% unlist
        
        vector_column_indices_differential <- which(
          abs(b1 - b2) > minimum_range_between_clusters &
            vector_row_in_psi < abs(b1 + max_deviation_from_min_or_max)
          # &
          #   vector_row_in_zscore %>% unlist >= z_score_cutoff
        )
        
        return(vector_column_indices_differential)
        
      }, .progress = TRUE )
    
    list_LIV_row_indices_positive_markers_for_each_sample <- furrr::future_map(
      .x = 1:ncol(a5),
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- 1
        ###########
        
        vector_row_indices_of_differentially_spliced_LIVs <- furrr::future_map(
          .x = list_items_differentially_spliced_high,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_items_differentially_spliced_high[[1]]
            ###########
            
            return(b1 %in% c1)
            
          } ) %>% unlist %>% which
        
        return(vector_row_indices_of_differentially_spliced_LIVs)
        
      }, .progress = TRUE) %>%
      set_names(nm = colnames(a5))
    
    list_LIV_row_indices_negative_markers_for_each_sample <- furrr::future_map(
      .x = 1:ncol(a5),
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- 1
        ###########
        
        vector_row_indices_of_differentially_spliced_LIVs <- furrr::future_map(
          .x = list_items_differentially_spliced_low,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_items_differentially_spliced_high[[1]]
            ###########
            
            return(b1 %in% c1)
            
          } ) %>% unlist %>% which
        
        return(vector_row_indices_of_differentially_spliced_LIVs)
        
      }, .progress = TRUE) %>%
      set_names(nm = colnames(a5))
    
    return(list("list_items_differentially_spliced_high" = list_items_differentially_spliced_high,
                "list_items_differentially_spliced_low" = list_items_differentially_spliced_low,
                "list_LIV_row_indices_positive_markers_for_each_sample" = list_LIV_row_indices_positive_markers_for_each_sample,
                "list_LIV_row_indices_negative_markers_for_each_sample" = list_LIV_row_indices_negative_markers_for_each_sample))
    
  }, .progress = TRUE ) %>% 
  set_names(nm = list_of_average_psi_tibbles_for_each_comparison_class %>% names)

save(list_differential_result_sample_subtypes_between_clusters, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_differential_result_sample_subtypes_between_clusters.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_differential_result_sample_subtypes_between_clusters.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 10),
          tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 2)))

# also get the row indices that passed numerator filtering
list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold <- furrr::future_pmap(
  .l = list(
    "a1" = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters,
    "a2" = names(list_condition_names_of_cell_or_tissue_types_in_multiple_clusters),
    "a3" = list_differential_result_sample_subtypes_between_clusters
  ),
  .f = function(a1, a2, a3) { 
    
    # DEBUG ###
    # a1 <- list_condition_names_of_cell_or_tissue_types_in_multiple_clusters[[1]]
    # a2 <- names(list_condition_names_of_cell_or_tissue_types_in_multiple_clusters) %>% .[[1]]
    # a3 <- list_differential_result_sample_subtypes_between_clusters[[1]]
    ###########
    
    cat(a2, "\n")
    
    # fetch column indices of the groups we will be doing comparisons on.
    list_of_vector_column_subsetting_indices <- purrr::map(.x = a1, .f = ~which(gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "") %in% (.x$condition_names %>% unique) ) ) %>% set_names(nm = purrr::map(.x = a1, .f = ~paste("som_cluster_", .x$som_cluster %>% unique, sep = "")) %>% unlist)
    
    list_of_vector_column_names_of_tables <- purrr::map(.x = list_of_vector_column_subsetting_indices, .f = ~gsub(x = colnames(tibble_matrix_absolute_psi_table), pattern = "\\_absolute\\.psi.*", replacement = "")[.x])
    
    # fetch the logical vector indicating whether the comparison meets threshold or not
    list_of_tibble_passes_threshold <- purrr::map(.x = list_of_vector_column_subsetting_indices, .f = ~tibble_matrix_passes_threshold_table[, .x] )

    list_of_vector_row_indices_passes_threshold <- furrr::future_map(.x = list_of_tibble_passes_threshold, .f = ~.x %>%
      future_apply(MARGIN = 1, FUN = function(X) {any((X %>% na.omit) == TRUE) %>% return}) )

    return(
      a3 %>%
        purrr::modify_at(.at = c("list_LIV_row_indices_positive_markers_for_each_sample", "list_LIV_row_indices_negative_markers_for_each_sample"), .f = ~purrr::map2(.x = .x[names(list_of_vector_row_indices_passes_threshold)], .y = list_of_vector_row_indices_passes_threshold, .f = ~intersect(.x, which(.y))))
    )
    
  }, .progress = TRUE )

save(list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold.Rlist", sep = ""))

```

## NOT USED: DoubleExpSeq - intercluster comparisons between non-mixed cell

Unlike DEXSeq, DExpSeq needs IR and *DENOMINATOR* counts, which actually makes our pipeline much more straightforward.

### prep the tables and run DExpSeq

```{r eval=FALSE, include=FALSE}

load(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_pooled_replicates.tibble", sep = ""))

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

tibble_matrix_dexseq_IR <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("numerator")) %>% round()
tibble_matrix_dexseq_IR[is.na(tibble_matrix_dexseq_IR)] <- 0

tibble_matrix_dexseq_denominator <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("denominator")) %>% round()
tibble_matrix_dexseq_denominator[is.na(tibble_matrix_dexseq_denominator)] <- 0

# calculate the ER so we can fix the values where IR > denominator.
tibble_matrix_dexseq_ER <- (tibble_matrix_dexseq_denominator - tibble_matrix_dexseq_IR) %>% as_tibble 
tibble_matrix_dexseq_IR[tibble_matrix_dexseq_ER < 0] <- 0

# declare groups and sample exclusions
list_group_comparisons <- list(
  "cell type" = c(1, 12, 14, 16, 20, 25, 29, 30, 31, 35, 36, 37, 39),
  "cell line" = c(3, 5, 7, 11, 15, 19, 27, 32, 33, 38),
  "tissue" = c(8, 10, 26)
)

list_sample_exclusions <- list(
  "cell type" = c(11, 12, 182, 276, 277, 278),
  "cell line" = c(117, 118, 138, 139, 152, 155),
  "tissue" = c(266)
)

# list-ify the tables according to sample type
list_of_tibble_matrix_IR_by_sample_type <- purrr::map2(
  .x = list_group_comparisons, # som_cluster
  .y = list_sample_exclusions, # group numbers to exclude
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_group_comparisons[[1]]
    # a2 <- list_sample_exclusions[[1]]
    ###########
    
    vector_column_subsetting_indices <- which(gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "_numerator.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster %in% a1, ] %>% .[!.$cluster_number %in% a2, ] %>% .$condition_names))
    
    vector_column_names_of_tables <- gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "_numerator", replacement = "")[vector_column_subsetting_indices]
    
    vector_condition_names <- gsub(x = vector_column_names_of_tables, pattern = "_[0-9]$", replacement = "")

    ### ### ### ### 
    
    tibble_matrix_dexseq_IR[, vector_column_subsetting_indices] %>% return
    
  }) %>% set_names(c("cell type", "cell line", "tissue"))

list_of_tibble_matrix_denominator_by_sample_type <- purrr::map2(
  .x = list_group_comparisons, # som_cluster
  .y = list_sample_exclusions, # group numbers to exclude
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_group_comparisons[[1]]
    # a2 <- list_sample_exclusions[[1]]
    ###########
    
    vector_column_subsetting_indices <- which(gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "_numerator.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster %in% a1, ] %>% .[!.$cluster_number %in% a2, ] %>% .$condition_names))
    
    vector_column_names_of_tables <- gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "_numerator", replacement = "")[vector_column_subsetting_indices]
    
    vector_condition_names <- gsub(x = vector_column_names_of_tables, pattern = "_[0-9]$", replacement = "")

    ### ### ### ### 
    
    tibble_matrix_dexseq_denominator[, vector_column_subsetting_indices] %>% return
    
  }) %>% set_names(c("cell type", "cell line", "tissue"))

list_of_tibble_matrix_absolute_psi_by_sample_type <- purrr::map2(
  .x = list_group_comparisons, # som_cluster
  .y = list_sample_exclusions, # group numbers to exclude
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_group_comparisons[[1]]
    # a2 <- list_sample_exclusions[[1]]
    ###########
    
    vector_column_subsetting_indices <- which(gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "_numerator.*", replacement = "") %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster %in% a1, ] %>% .[!.$cluster_number %in% a2, ] %>% .$condition_names))
    
    vector_column_names_of_tables <- gsub(x = colnames(tibble_matrix_dexseq_IR), pattern = "_numerator", replacement = "")[vector_column_subsetting_indices]
    
    vector_condition_names <- gsub(x = vector_column_names_of_tables, pattern = "_[0-9]$", replacement = "")

    ### ### ### ### 
    
    wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>% dplyr::select(contains("absolute.psi")) %>% .[, vector_column_subsetting_indices] %>% return
    
  }) %>% set_names(c("cell type", "cell line", "tissue"))

# check if all columns are matching
logical_all_columns_match <- purrr::pmap(
  .l = list(
    "a1" = list_of_tibble_matrix_IR_by_sample_type %>% purrr::map(~.x %>% colnames),
    "a2" = list_of_tibble_matrix_denominator_by_sample_type %>% purrr::map(~.x %>% colnames),
    "a3" = list_of_tibble_matrix_absolute_psi_by_sample_type %>% purrr::map(~.x %>% colnames)
  ), 
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_of_tibble_matrix_IR_by_sample_type %>% purrr::map(~.x %>% colnames) %>% .[[1]]
    # a2 <- list_of_tibble_matrix_denominator_by_sample_type %>% purrr::map(~.x %>% colnames) %>% .[[1]]
    # a3 <- list_of_tibble_matrix_absolute_psi_by_sample_type %>% purrr::map(~.x %>% colnames) %>% .[[1]]
    ###########
    
    purrr::pmap(
      .l = list(
        "b1" = a1 %>% gsub(pattern = "\\_numerator", replacement = ""),
        "b2" = a2 %>% gsub(pattern = "\\_denominator", replacement = ""), 
        "b3" = a3 %>% gsub(pattern = "\\_absolute\\.psi", replacement = "")
      ), 
      .f = ~c(...) %>% unique %>% length == 1
    ) %>% unlist %>% unique %>% length %>% return
    
  } )

if (logical_all_columns_match %>% unlist %>% unique != 1) {
  
  stop("STOP. columns do not match between denominator, IR or absolute PSI")
  
}

library(DoubleExpSeq)
library(future.apply)

plan(list(tweak(multiprocess, workers = 3),
          tweak(multiprocess, workers = 48)))

list_DExpSeq_results_intercluster_comparisons <- future_pmap(
  list(
    a1 = list_of_tibble_matrix_IR_by_sample_type,
    a2 = list_of_tibble_matrix_denominator_by_sample_type,
    a3 = list_of_tibble_matrix_absolute_psi_by_sample_type,
    a4 = names(list_of_tibble_matrix_IR_by_sample_type),
    a5 = list_group_comparisons
  ), .f = function(a1, a2, a3, a4, a5) {
    
    # DEBUG ###
    # a1 <- list_of_tibble_matrix_IR_by_sample_type[[1]]
    # a2 <- list_of_tibble_matrix_denominator_by_sample_type[[1]]
    # a3 <- list_of_tibble_matrix_absolute_psi_by_sample_type[[1]]
    # a4 <- names(list_of_tibble_matrix_IR_by_sample_type) %>% .[[1]]
    # a5 <- list_group_comparisons[[1]]
    ###########
    
    cat(a4, "\n")
    
    # get the rows which are all valid splice events, that is, no zero values in the denominator.
    ## i think that you can have up to 15% NAs before the algorithm conks out. therefore filter for less than 80% zeroes in each row.
    # temp_x <- (((ncol(a1)/5) / 2) %>% ceiling()) * 2
    
    # vector_rows_which_have_less_than_x_number_of_zeroes <- intersect(
    #   future_apply(a1, MARGIN = 1, FUN = function(X) {which(X != 0) %>% length > temp_x } ) %>% unlist %>% which,
    #   future_apply(a2, MARGIN = 1, FUN = function(X) {which(X != 0) %>% length > temp_x } ) %>% unlist %>% which
    # )
    
    plan(list(tweak(multiprocess, workers = 4),
              tweak(multiprocess, workers = 1)))
    
    # plan(multiprocess)
    # options(mc.cores = 4)
    
    # vector_rows_which_have_less_than_x_number_of_zeroes <- intersect(
    #   future_apply(a1, MARGIN = 1, FUN = function(X) {which(X != 0) %>% length == ncol(a1) } ) %>% unlist %>% which,
    #   future_apply(a2, MARGIN = 1, FUN = function(X) {which(X != 0) %>% length == ncol(a1) } ) %>% unlist %>% which
    # )
    
    vector_rows_which_have_less_than_x_number_of_zeroes <- future_apply(a2, MARGIN = 1, FUN = function(X) {which(X != 0) %>% length == ncol(a1) } ) %>% unlist %>% which
    
    vector_rows_which_have_less_than_x_number_of_zeroes <- vector_rows_which_have_less_than_x_number_of_zeroes[vector_rows_which_have_less_than_x_number_of_zeroes < a1 %>% nrow] %>% na.omit
    
    vector_group_names_by_column <- dplyr::left_join(tibble("condition_names" = colnames(a1) %>% gsub(pattern = "\\_numerator", replacement = "")), tibble_processed_UMAP_cluster_legend[, c("condition_names", "som_cluster")]) %>% .$som_cluster
    
    vector_dispersions_per_row <- suppressWarnings(suppressMessages(
      
      DoubleExpSeq::EstimateDEBDisp(y = a1[vector_rows_which_have_less_than_x_number_of_zeroes, ], 
                                    m = a2[vector_rows_which_have_less_than_x_number_of_zeroes, ],
                                    groups = vector_group_names_by_column
      ) 
      
    )) 

    plan(list(tweak(multiprocess, workers = 24),
              tweak(multiprocess, workers = 1)))
        
    # plan(multiprocess)
    # options(mc.cores = 72)

    # differential splicing detection
    list_DExpSeq_pairwise_comparisons <- furrr::future_map2(
      .x = combn(x = 1:length(a5), m = 2) %>% t %>% as_tibble(.name_repair = "unique") %>% .[, 1] %>% unlist,
      .y = combn(x = 1:length(a5), m = 2) %>% t %>% as_tibble (.name_repair = "unique") %>% .[, 2] %>% unlist,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- combn(x = 1:length(a5), m = 2) %>% t %>% as_tibble %>% .$V1 %>% .[[1]]
        # b2 <- combn(x = 1:length(a5), m = 2) %>% t %>% as_tibble %>% .$V2 %>% .[[1]]
        ###########
        
        cat(b1, ",", b2)
        
        DoubleExpSeq::DBGLM1(
          y = a1[vector_rows_which_have_less_than_x_number_of_zeroes, ], 
          m = a2[vector_rows_which_have_less_than_x_number_of_zeroes, ],
          shrink.method = "WEB", 
          contrast = c(b1, b2),
          groups = vector_group_names_by_column %>% as.factor,
          fdr.level = 0.01, 
          use.all.groups = TRUE
        ) %>% 
          purrr::map(~.x %>% as_tibble(rownames = "rowid_of_5_in_any_table")) %>% 
          return
        
      } )
    
    # get the comparison names straight from the column names of the sig matrix
    ## NOTE: we can now see that DExpSeq sets names based on the "combn" of unique-ified factor numbers (NOT the order of the levels)
    names(list_DExpSeq_pairwise_comparisons) <- paste(list_DExpSeq_pairwise_comparisons %>% purrr::map(~.x$Sig %>% colnames %>% .[2] %>% gsub(pattern = "MLE\\_", replacement = "")) %>% unlist, "_vs_", list_DExpSeq_pairwise_comparisons %>% purrr::map(~.x$Sig %>% colnames %>% .[3] %>% gsub(pattern = "MLE\\_", replacement = "")) %>% unlist, sep = "")
    
    pdf(file = paste(R_processing_results_dir, "DExpSeq_dispersion_vs_log2_average_PSI_cluster_comparisons_", a4, ".pdf", sep = ""))
    
    # plot dispersion vs. log2(average PSI) for each row
    plot(x = a3[vector_rows_which_have_less_than_x_number_of_zeroes, ] %>% rowMeans(na.rm = TRUE) %>% log2,
         y = vector_dispersions_per_row)
    
    dev.off()
    
    pdf(file = paste(R_processing_results_dir, "DExpSeq_MA_plot_cluster_comparisons_", a4, ".pdf", sep = ""))
    
    # M-A plot
    DoubleExpSeq::DB.MAPlot(
      y = a1[vector_rows_which_have_less_than_x_number_of_zeroes, ], 
      m = a2[vector_rows_which_have_less_than_x_number_of_zeroes, ],
      groups = vector_group_names_by_column,
      contrast = c(1, 2))
    
    dev.off()
    
    pdf(file = paste(R_processing_results_dir, "DExpSeq_WEBseq_optimplot_cluster_comparisons_", a4, ".pdf", sep = ""))
    
    # plot the WEBseq maximum likelihood solution
    DoubleExpSeq::optimPlot(
      y = a1[vector_rows_which_have_less_than_x_number_of_zeroes, ], 
      m = a2[vector_rows_which_have_less_than_x_number_of_zeroes, ],
      groups = vector_group_names_by_column,
      use.all.groups = TRUE)
    
    dev.off()
    
    return(list(
      "list_DExpSeq_pairwise_comparisons" = list_DExpSeq_pairwise_comparisons,
      "vector_group_names_by_column" = vector_group_names_by_column,
      "vector_rows_which_have_less_than_x_number_of_zeroes" = vector_rows_which_have_less_than_x_number_of_zeroes
    ))
    
  }, .progress = TRUE)

save(list_DExpSeq_results_intercluster_comparisons, file = paste(R_processing_results_dir, "list_DExpSeq_results_intercluster_comparisons.Rlist", sep = ""), compress = FALSE)

```

### Extract differentially spliced LISs

NOTE: filtered already by p-value. now filter again by dpsi.

```{r eval=FALSE, include=FALSE}

load(file = paste(R_processing_results_dir, "list_DExpSeq_results_intercluster_comparisons.Rlist", sep = ""))

dpsi_cutoff <- 15

plan(list(tweak(multiprocess, workers = 3),
          tweak(multiprocess, workers = 4)))

list_DExpSeq_intercluster_comparisons_differentially_spliced_LISs <- furrr::future_pmap(
  .l = list(
    "a1" = list_DExpSeq_results_intercluster_comparisons,
    "a2" = list_of_tibble_matrix_absolute_psi_by_sample_type,
    "a3" = list_DExpSeq_results_intercluster_comparisons %>% names
  ),
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_DExpSeq_results_intercluster_comparisons[[1]]
    # a2 <- list_of_tibble_matrix_absolute_psi_by_sample_type[[1]]
    # a3 <- list_DExpSeq_results_intercluster_comparisons %>% names %>% .[[1]]
    ###########
    
    cat(a3, "\n")
    
    list_DS_results_with_dpsi <- furrr::future_map2(
      .x = a1$list_DExpSeq_pairwise_comparisons,
      .y = a1$list_DExpSeq_pairwise_comparisons %>% names,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1$list_DExpSeq_pairwise_comparisons %>% .[[1]]
        # b2 <- a1$list_DExpSeq_pairwise_comparisons %>% names %>% .[[1]]
        ###########
        
        tibble_significant_items_raw <- b1$Sig
        
        # get the average PSIs for each comparison
        vector_average_PSI_comparison_1 <- a2[tibble_significant_items_raw$rowid_of_5_in_any_table, which(a1$vector_group_names_by_column == b2 %>% gsub(pattern = "\\_vs\\_.*", replacement = ""))] %>% 
          rowMeans(na.rm = TRUE)
        
        vector_average_PSI_comparison_2 <- a2[tibble_significant_items_raw$rowid_of_5_in_any_table, which(a1$vector_group_names_by_column == b2 %>% gsub(pattern = ".*\\_vs\\_", replacement = ""))] %>% 
          rowMeans(na.rm = TRUE)
        
        # note: to deal with NA values, we set as Inf or -Inf depending on which comparison was NA.
        # +Inf means comparison 2 splicing exists but comparison 1 splicing isnt even there to begin with or the gene was not even expressed to begin with. 
        # same thing vice versa.
        vector_dpsi_2_minus_1 <- purrr::map2(
          .x = vector_average_PSI_comparison_1,
          .y = vector_average_PSI_comparison_2,
          .f = function(c1, c2) {
            
            if (is.na(c1) == FALSE & is.na(c2) == FALSE) {
              result <- c2 - c1
            } else if (is.na(c1) == TRUE & is.na(c2) == FALSE) {
              result <- Inf
            } else if (is.na(c1) == FALSE & is.na(c2) == TRUE) {
              result <- -Inf
            } else if (is.na(c1) == TRUE & is.na(c2) == TRUE) {
              result <- NA
            } 
            
            return(result)
            
          } ) %>% unlist
        
        # note: because of the GLM feature, sometimes significance is called when both dpsi values are NA (due to previous forcing of 0 values).
        # we will get rid of those in this step.
        tibble_significant_items_with_dpsi <- tibble_significant_items_raw %>%
          dplyr::mutate("average_PSI_comparison_1" = vector_average_PSI_comparison_1,
                        "average_PSI_comparison_2" = vector_average_PSI_comparison_2,
                        "dpsi_2_minus_1" = vector_dpsi_2_minus_1) %>% 
          .[which(.$dpsi_2_minus_1 %>% is.na == FALSE), ]
        
        # finally filter for significant items based on dpsi.
        tibble_significant_items_with_dpsi_filtered <- tibble_significant_items_with_dpsi %>% 
          dplyr::filter(abs(dpsi_2_minus_1) >= dpsi_cutoff)
        
        # rename the column names to be non-unique for each comparison
        colnames(tibble_significant_items_with_dpsi_filtered)[2] <- "MLE_comparison_1"
        colnames(tibble_significant_items_with_dpsi_filtered)[3] <- "MLE_comparison_2"
        
        colnames(tibble_significant_items_with_dpsi_filtered)[7] <- "MeanTotCt_comparison_1"
        colnames(tibble_significant_items_with_dpsi_filtered)[8] <- "MeanTotCt_comparison_2"
        
        # add comparison and sample_type columns
        tibble_significant_items_with_dpsi_filtered <- tibble_significant_items_with_dpsi_filtered %>% 
          dplyr::mutate("comparison" = b2,
                        "sample_type" = a3) 
        
        return(tibble_significant_items_with_dpsi_filtered)
        
      } ) 
    
  }, .progress = TRUE )

# rbind and tibblise
tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs <- list_DExpSeq_intercluster_comparisons_differentially_spliced_LISs %>% flatten %>% rbindlist %>% as_tibble

save(tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs, file = paste(R_processing_results_dir, "tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs.tibble", sep = ""), compress = FALSE)

```

### Analyse differentially spliced LISs 

```{r}

load(file = paste(R_processing_results_dir, "tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs.tibble", sep = ""))

# since we have to pick out the genes that are the highest 10% PSI or lowest 10% PSI in order to constitute a characteristic marker, we have to get the min/max PSIs, range and stdev of each item in the 5_in_any table
suppressMessages(suppressWarnings(
  
  tibble_min_max_stdev_per_LIS <- tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs %>% 
  dplyr::group_by(rowid_of_5_in_any_table) %>% 
  dplyr::summarise("max_psi" = max(c(average_PSI_comparison_1 %>% na.omit, average_PSI_comparison_2 %>% na.omit)),
                   "min_psi" = min(c(average_PSI_comparison_1 %>% na.omit, average_PSI_comparison_2 %>% na.omit)),
                   "mean" = c(average_PSI_comparison_1 %>% na.omit, average_PSI_comparison_2 %>% na.omit) %>% unique %>% base::mean(na.rm = TRUE),
                   "stdev" = c(average_PSI_comparison_1 %>% na.omit, average_PSI_comparison_2 %>% na.omit) %>% unique %>% stats::sd(na.rm = TRUE))
  
)) 

plan(list(tweak(multiprocess, workers = 3),
          tweak(multiprocess, workers = 4)))

list_positive_markers_per_cluster <- furrr::future_map2(
  .x = list_group_comparisons,
  .y = names(list_group_comparisons),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_group_comparisons[[1]]
    # a2 <- names(list_group_comparisons) %>% .[[1]]
    ###########
    
    list_per_sample_type <- furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # get the LISs which are high only in each cluster
        ## we have to consider two cases because the desired cluster is sometimes comparison 1 but sometimes comparison 2.
        tibble_target_is_comparison_2 <- tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$comparison %in% (tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% .[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% strsplit(split = "_vs_") %>% purrr::map(~.x[2] == b1) %>% unlist %>% which]), ] %>% 
          dplyr::filter(sample_type == a2 & dpsi_2_minus_1 > 15) %>% 
          dplyr::select(-average_PSI_comparison_1, -comparison, -dpsi_2_minus_1) %>%
          dplyr::rename("average_PSI_cluster" = "average_PSI_comparison_2")
        
        tibble_target_is_comparison_1 <- tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$comparison %in% (tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% .[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% strsplit(split = "_vs_") %>% purrr::map(~.x[1] == b1) %>% unlist %>% which]), ] %>% 
          dplyr::filter(sample_type == a2 & dpsi_2_minus_1 < -15) %>% 
          dplyr::select(-average_PSI_comparison_2, -comparison, -dpsi_2_minus_1) %>%
          dplyr::rename("average_PSI_cluster" = "average_PSI_comparison_1")
        
        # combine both cases
        tibble_all_positive_markers_for_cluster <- dplyr::bind_rows(tibble_target_is_comparison_2, tibble_target_is_comparison_1) %>%
          tibble::add_column("cluster" = b1)
        
        # table join the min/max/stdev table to identify characteristic biomarkers
        tibble_all_positive_markers_for_cluster_with_global_min_max_stdev <- dplyr::left_join(tibble_all_positive_markers_for_cluster, tibble_min_max_stdev_per_LIS, by = "rowid_of_5_in_any_table")
        
        # keep only those which are within 10% of the top (for positive marker)
        tibble_all_positive_markers_for_cluster_with_global_min_max_stdev_filtered <- tibble_all_positive_markers_for_cluster_with_global_min_max_stdev %>%
          dplyr::filter(average_PSI_cluster >= (max_psi - 10) & average_PSI_cluster >= (min_psi + 30))
        
        # extract only the rowid, average PSI for the cluster, and the cluster number
        tibble_all_positive_markers_for_cluster_shortened <- suppressMessages(suppressWarnings(
          tibble_all_positive_markers_for_cluster_with_global_min_max_stdev_filtered[, c("rowid_of_5_in_any_table", "average_PSI_cluster", "cluster")] %>% dplyr::distinct() %>% type_convert %>% dplyr::arrange(rowid_of_5_in_any_table)
        )) 
        
        return(tibble_all_positive_markers_for_cluster_shortened)
        
      }, .options = furrr_options(seed = 8) ) %>% set_names(nm = a1)
    
    return(list_per_sample_type)
    
  }, .progress = TRUE, .options = furrr_options(seed = 8))

list_negative_markers_per_cluster <- furrr::future_map2(
  .x = list_group_comparisons,
  .y = names(list_group_comparisons),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_group_comparisons[[2]]
    # a2 <- names(list_group_comparisons) %>% .[[2]]
    ###########
    
    list_per_sample_type <- furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # get the LISs which are high only in each cluster
        ## we have to consider two cases because the desired cluster is sometimes comparison 1 but sometimes comparison 2.
        tibble_target_is_comparison_2 <- tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$comparison %in% (tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% .[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% strsplit(split = "_vs_") %>% purrr::map(~.x[2] == b1) %>% unlist %>% which]), ] %>% 
          dplyr::filter(sample_type == a2 & dpsi_2_minus_1 < -15) %>% 
          dplyr::select(-average_PSI_comparison_1, -comparison, -dpsi_2_minus_1) %>%
          dplyr::rename("average_PSI_cluster" = "average_PSI_comparison_2")
        
        tibble_target_is_comparison_1 <- tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$comparison %in% (tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% .[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs[tibble_DExpSeq_intercluster_comparisons_differentially_spliced_LISs$sample_type == a2, "comparison"] %>% unlist %>% unique %>% strsplit(split = "_vs_") %>% purrr::map(~.x[1] == b1) %>% unlist %>% which]), ] %>% 
          dplyr::filter(sample_type == a2 & dpsi_2_minus_1 > 15) %>% 
          dplyr::select(-average_PSI_comparison_2, -comparison, -dpsi_2_minus_1) %>%
          dplyr::rename("average_PSI_cluster" = "average_PSI_comparison_1")
        
        # combine both cases
        tibble_all_negative_markers_for_cluster <- dplyr::bind_rows(tibble_target_is_comparison_2, tibble_target_is_comparison_1) %>%
          tibble::add_column("cluster" = b1)
        
        # table join the min/max/stdev table to identify characteristic biomarkers
        tibble_all_negative_markers_for_cluster_with_global_min_max_stdev <- dplyr::left_join(tibble_all_negative_markers_for_cluster, tibble_min_max_stdev_per_LIS, by = "rowid_of_5_in_any_table")
        
        # keep only those which are within 10% of the top (for negative marker)
        tibble_all_negative_markers_for_cluster_with_global_min_max_stdev_filtered <- tibble_all_negative_markers_for_cluster_with_global_min_max_stdev %>%
          dplyr::filter(average_PSI_cluster <= (min_psi + 10) & average_PSI_cluster <= (max_psi - 30))
        
        # extract only the rowid, average PSI for the cluster, and the cluster number
        tibble_all_negative_markers_for_cluster_shortened <- suppressMessages(suppressWarnings(
          tibble_all_negative_markers_for_cluster_with_global_min_max_stdev_filtered[, c("rowid_of_5_in_any_table", "average_PSI_cluster", "cluster")] %>% dplyr::distinct() %>% type_convert %>% dplyr::arrange(rowid_of_5_in_any_table)
        )) 
        
        return(tibble_all_negative_markers_for_cluster_shortened)
        
      }, .options = furrr_options(seed = 8) ) %>% set_names(nm = a1)
    
    return(list_per_sample_type)
    
  }, .progress = TRUE, .options = furrr_options(seed = 8))

# splice positive and negative marker lists into a single list
list_DExpSeq_intercluster_comparisons_differential_biomarkers <- purrr::splice(
  "positive_markers" = list_positive_markers_per_cluster %>% list, 
  "negative_markers" = list_negative_markers_per_cluster %>% list)

save(list_DExpSeq_intercluster_comparisons_differential_biomarkers, file = paste(R_processing_results_dir, "list_DExpSeq_intercluster_comparisons_differential_biomarkers.tibble", sep = ""), compress = FALSE)

```

# Consequences of differential splicing

The usual... gene-level GO analysis, transcript ontology - NMD/poison exons etc., predicted protein ontology - interpro domains etc..

## annotate the comparison results and save 

### load the LIS reannotation and results of poison exon finder

```{r}

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

# fetch the LIS data
# tibble_LIS_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, c("database_id", "aes_id", "exon_number", "event_region", "LIV_exon_coords", "psisigma_gene_symbol", "alternative_exon_coords", "splicemode", "psisigma_nmd", "psisigma_reference_transcript")]

tibble_merged_non_IR_and_IR_annotations_summarised <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_merged_non_IR_and_IR_annotations_summarised.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_poison_exon_finder_summary <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_poison_exon_finder_summary.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_processed_UMAP_cluster_legend <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% 
  as_tibble

tibble_chucked_out_items_UMAP <- data.table::fread(paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_chucked_out_cluster_legend_annotated.txt", sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% .[.$condition_names %>% is.na != TRUE, ]

# test: subset the PSI table for just samples in a particular cluster
## characteristic markers for each cluster
# tibble_test <- dplyr::bind_cols(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>%
#   dplyr::select(-contains("numerator"), -contains("denominator"), -contains("no_replicates"), -contains("absolute.psi")) %>%
#   dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
#   dplyr::left_join(., tibble_poison_exon_finder_summary),
#   wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>%
#     dplyr::select(contains("absolute.psi")) %>%
#   .[, (gsub(x = colnames(.), pattern = "\\_absolute\\.psi", replacement = "")) %in% (list_sample_comparisons$som_cluster_12 %>% .[[1]])]
#   )

## intracluster comparisons
# tibble_test <- dplyr::bind_cols(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>%
#   dplyr::select(-contains("numerator"), -contains("denominator"), -contains("no_replicates"), -contains("absolute.psi"), -contains("_passes_read_threshold")) %>%
#   dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
#   dplyr::left_join(., tibble_poison_exon_finder_summary),
#   wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids %>%
#     dplyr::select(contains("absolute.psi"), contains("numerator"), contains("denominator")) %>%
#   .[, (colnames(.) %>% gsub(pattern = "\\_absolute\\.psi", replacement = "") %>% gsub(pattern = "\\_numerator", replacement = "") %>% gsub(pattern = "\\_denominator", replacement = "")) %in% (tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$cluster_number %in% (list_sample_comparisons$`11`$`T-ALL vs. B-ALL` %>% unlist), "condition_names"] %>% unlist )]
#   )

# make tibble which maps RNA number and condition_names to their som number
vector_chucked_out_sample_names <- paste("chucked_out_RNA_number_", tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$RNA_number %>% unique) %>% unlist, sep = "")

tibble_mapping_condition_names_RNA_number_to_cluster_name <- dplyr::bind_rows(
  # chucked out items
  tibble("cluster_name" = vector_chucked_out_sample_names, 
         "RNA_number" = vector_chucked_out_sample_names %>% gsub(pattern = "chucked\\_out\\_RNA\\_number\\_", replacement = "") ) %>% mutate_all(as.character) %>% dplyr::left_join(., tibble_chucked_out_items_UMAP[, c("RNA_number", "condition_names")] %>% mutate_all(as.character)) %>% (function(x) {x[x$cluster_name %>% duplicated, "cluster_name"] <- paste(x[x$cluster_name %>% duplicated, ] %>% .$cluster_name, "_2", sep = "") ; return(x)} ) %>% mutate_all(as.character),
  tibble_processed_UMAP_cluster_legend[, c("cluster_number", "RNA_number", "condition_names")] %>% dplyr::mutate("cluster_name" = paste("no_", `cluster_number`, sep = "")) %>% mutate_all(as.character)
  ) %>% type_convert
                                         
```

### DExpSeq: characteristic markers for each som cluster

```{r}

load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_per_som_cluster_DExpSeq_results.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 2)))

list_characteristic_markers_for_each_som_cluster_annotated <- furrr::future_map2(
  .x = list_characteristic_markers_per_cluster_DExpSeq_results,
  .y = names(list_characteristic_markers_per_cluster_DExpSeq_results),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_per_cluster_DExpSeq_results[[12]]
    # a2 <- names(list_characteristic_markers_per_cluster_DExpSeq_results) %>% .[[12]]
    ###########
    
    cat(a2, "\n")
    
    # add on the LIS information
    tibble_annotated_result <- dplyr::bind_cols(a1, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[a1$master_row_index, ]) %>% 
      # use sample numbers in the UMAP instead of condition_names
      # (function(x) {
      #   
      #   # DEBUG ###
      #   # x <- dplyr::bind_cols(a1, wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[a1$master_row_index, ])
      #   ###########
      #   
      #   tibble_result <- x
      #   
      #   vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
      #   vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\2")
      #   
      #   colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
      #   
      #   return(tibble_result)
      #   
      # } ) %>% 
      dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
      dplyr::left_join(., tibble_poison_exon_finder_summary) %>%
      dplyr::mutate("positive_or_negative_marker" = `dpsi_comparison_minus_anticomparison` %>% purrr::map(.f = function(.x) {if (.x > 0) {return("positive_marker")} else {return("negative_marker")}} ) %>% unlist  )
    
    if (a1 %>% nrow > 0) {
      
      tibble_annotated_result %>% 
        dplyr::group_split(positive_or_negative_marker) %>%
        set_names(nm = purrr::map(.x = ., .f = ~.x$positive_or_negative_marker %>% unique) %>% unlist) %>%
        return
      
    } else {
      
      list() %>% return
      
    }
    
  }, .progress = TRUE )

# prune

list_characteristic_markers_for_each_som_cluster_annotated_pruned <- list_characteristic_markers_for_each_som_cluster_annotated %>% purrr::discard(.p = ~.x %>% length == 0)

save(list_characteristic_markers_for_each_som_cluster_annotated_pruned, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_annotated_pruned.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_annotated_pruned.Rlist", sep = ""))

# write table
tibble_characteristic_markers_for_each_som_cluster_annotated0 <- purrr::map2(
  .x = list_characteristic_markers_for_each_som_cluster_annotated_pruned,
  .y = names(list_characteristic_markers_for_each_som_cluster_annotated_pruned),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_som_cluster_annotated_pruned[[1]]
    # a2 <- names(list_characteristic_markers_for_each_som_cluster_annotated_pruned) %>% .[[1]]
    ###########
    
    a1 %>% 
      rbindlist %>%
      tibble::add_column("som_cluster" = a2) %>%
      return
    
  } ) %>% rbindlist %>% as_tibble

# add in average, stdev and z scores
tibble_characteristic_markers_for_each_som_cluster_annotated1 <- tibble_characteristic_markers_for_each_som_cluster_annotated0 %>% 
  dplyr::mutate("avg_psi" = tibble_characteristic_markers_for_each_som_cluster_annotated0 %>% dplyr::select(contains("absolute.psi")) %>% rowMeans(),
                "stdev" = tibble_characteristic_markers_for_each_som_cluster_annotated0 %>% dplyr::select(contains("absolute.psi")) %>% apply(MARGIN = 1, FUN = function(X) {return(sd(X %>% type.convert(as.is = TRUE)))} )) %>%
  suppressMessages() %>%
  suppressWarnings()

tibble_characteristic_markers_for_each_som_cluster_annotated0 <- dplyr::bind_cols(
  tibble_characteristic_markers_for_each_som_cluster_annotated1,
  ( ((tibble_characteristic_markers_for_each_som_cluster_annotated1 %>% dplyr::select(contains("absolute.psi"))) - (matrix(ncol = ncol(tibble_characteristic_markers_for_each_som_cluster_annotated1 %>% dplyr::select(contains("absolute.psi"))), nrow = nrow(tibble_characteristic_markers_for_each_som_cluster_annotated1 %>% dplyr::select(contains("absolute.psi"))), data = tibble_characteristic_markers_for_each_som_cluster_annotated1$avg_psi) %>% as_tibble)) / (matrix(ncol = ncol(tibble_characteristic_markers_for_each_som_cluster_annotated1 %>% dplyr::select(contains("absolute.psi"))), nrow = nrow(tibble_characteristic_markers_for_each_som_cluster_annotated1 %>% dplyr::select(contains("absolute.psi"))), data = tibble_characteristic_markers_for_each_som_cluster_annotated1$stdev) %>% as_tibble) ) %>% as_tibble %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "absolute\\.psi", replacement = "zscore"); return(x)} )
  )

data.table::fwrite(x = tibble_characteristic_markers_for_each_som_cluster_annotated0, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_characteristic_markers_for_each_som_cluster_annotated.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

### Z-scores: finding the characteristic set of LISs for each chucked out sample

```{r}

load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 32),
          tweak(multiprocess, workers = 2)))

list_characteristic_markers_for_each_chucked_out_sample_annotated <- furrr::future_map2(
  .x = list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold,
  .y = names(list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold[[2]]
    # a2 <- names(list_characteristic_markers_for_each_chucked_out_sample_filtered_for_threshold) %>% .[[2]]
    ###########
    
    # cat(a2, "\n")
    
    # loop positive/negative markers
    furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # subset the absolute PSI table according to those which met the filtering condition for each comparison
        tibble_items_of_interest <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[b1, ] %>%
          (function(x) {
            
            tibble_result <- x
            
            vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
            vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\2")
            
            colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
            
            return(tibble_result)
            
          } ) %>%
          dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
          dplyr::left_join(., tibble_poison_exon_finder_summary)
        
        tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "matched_gene_names"] <- tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "psisigma_gene_symbol"]
        
        tibble_items_of_interest[tibble_items_of_interest$PEF_has_poison_region %>% is.na == TRUE, "PEF_has_poison_region"] <- FALSE
        tibble_items_of_interest[tibble_items_of_interest$PEF_has_frameshift %>% is.na == TRUE, "PEF_has_frameshift"] <- FALSE
        
        return(tibble_items_of_interest)
        
      } ) %>% return
    
  }, .progress = TRUE )

save(list_characteristic_markers_for_each_chucked_out_sample_annotated, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_annotated.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_annotated.Rlist", sep = ""))

# write table
tibble_characteristic_markers_for_each_chucked_out_sample_annotated <- purrr::map2(
  .x = list_characteristic_markers_for_each_chucked_out_sample_annotated,
  .y = names(list_characteristic_markers_for_each_chucked_out_sample_annotated),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_chucked_out_sample_annotated[[1]]
    # a2 <- names(list_characteristic_markers_for_each_chucked_out_sample_annotated) %>% .[[1]]
    ###########
    
    purrr::map2(
      .x = a1,
      .y = names(a1) %>% gsub(pattern = "vector_row_indices_(.*)s_passing_threshold", replacement = "\\1"),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% .[[1]]
        ###########
        
        b1 %>%
          tibble::add_column("positive_or_negative_marker" = b2) %>% return
        
      } ) %>% rbindlist %>% tibble::add_column("group_name" = a2) %>% 
      return
    
  } ) %>% rbindlist %>% as_tibble

data.table::fwrite(x = tibble_characteristic_markers_for_each_chucked_out_sample_annotated, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_characteristic_markers_for_each_chucked_out_sample_annotated.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

### [DExpSeq] inter-cluster comparisons of relatively homogenous subtypes

```{r}

load(file = paste(R_processing_results_dir, "list_DExpSeq_intercluster_comparisons_differential_biomarkers.tibble", sep = ""))

plan(list(tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 2)))

list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated <- furrr::future_map(
  .x = list_DExpSeq_intercluster_comparisons_differential_biomarkers,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_DExpSeq_intercluster_comparisons_differential_biomarkers[[1]]
    ###########
    
    L1_result <- furrr::future_map2(
      .x = a1,
      .y = list_DExpSeq_results_intercluster_comparisons,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- list_DExpSeq_results_intercluster_comparisons[[1]]
        ###########
        
        # fetch the row indices which are repeated in more than one cluster
        # this will be used to make the unique positive/negative markers.
        # to do this, we first make a tally of how many times each row index appeared
        tibble_rowid_tally <- b1 %>% 
          purrr::map(.f = ~.x$rowid_of_5_in_any_table) %>% 
          unlist %>%
          tibble::enframe(name = NULL, value = "rowid") %>% 
          dplyr::group_by(rowid) %>%
          dplyr::summarise("tally" = n())
        
        vector_rowids_appearing_only_once <- tibble_rowid_tally[tibble_rowid_tally$tally == 1, "rowid"] %>% unlist
        
        # splice in the unique biomarker rows for each cluster
        b1_edited <- purrr::map(
          .x = b1,
          .f = ~purrr::splice(.x %>% array_tree(margin = 2), "rowid_of_5_in_any_table_unique" = intersect(.x$rowid_of_5_in_any_table, vector_rowids_appearing_only_once)))
        
        L2_result <- furrr::future_map(
          .x = b1_edited,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- b1_edited[[1]]
            ###########
            
            L3_result <- furrr::future_map(
              
              .x = c1[c("rowid_of_5_in_any_table", "rowid_of_5_in_any_table_unique")],
              .f = function(d1) {
                
                # DEBUG ###
                # d1 <- c1[[1]]
                ###########
                
                # subset the absolute PSI table according to those which met the filtering condition for each comparison
                tibble_items_of_interest <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[b2$vector_rows_which_have_less_than_x_number_of_zeroes, ] %>%
          (function(x) {
            
            tibble_result <- x
            
            vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
            vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\2")
            
            colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
            
            return(tibble_result)
            
          } ) %>% .[d1, ] %>%
                  dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
                  dplyr::left_join(., tibble_poison_exon_finder_summary)
                
                tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "matched_gene_names"] <- tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "psisigma_gene_symbol"]
                
                tibble_items_of_interest[tibble_items_of_interest$PEF_has_poison_region %>% is.na == TRUE, "PEF_has_poison_region"] <- FALSE
                tibble_items_of_interest[tibble_items_of_interest$PEF_has_frameshift %>% is.na == TRUE, "PEF_has_frameshift"] <- FALSE
                
                return(tibble_items_of_interest)
                
              } ) %>% set_names(c("non_unique", "unique"))
            
          } )
        
      } )
    
  }, .progress = TRUE )

# reorganise 
list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated <- purrr::splice(
  list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated %>% purrr::map_depth(.depth = 3, .f = ~.x$non_unique),
  list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated %>% purrr::map_depth(.depth = 3, .f = ~.x$unique) %>% set_names(nm = paste(names(.), "_unique", sep = ""))
)

save(list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated, file = paste(R_processing_results_dir, "list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated.Rlist", sep = ""), compress = FALSE)

```

### [zscore/maxmin] comparisons of distinct cell types within clusters

```{r}

load(file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_filtered_by_threshold.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 2)))

# annotate the comparison results here and save it.
list_annotated_result_differential_comparisons_within_clusters <- furrr::future_map(
  .x = list_differential_comparisons_within_clusters_filtered_by_threshold,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_differential_comparisons_within_clusters_filtered_by_threshold[[1]]
    ###########
    
    list_complete_LIS_info_for_one_cluster <- furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # NOTE: b1 is a vector of differential items for a particular pairwise comparison within a som cluster
        
        # loop positive/negative markers
        furrr::future_map(
          .x = b1,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            ###########
            
            # subset the absolute PSI table according to those which met the filtering condition for each comparison
            tibble_items_of_interest <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[c1, ] %>%
          (function(x) {
            
            tibble_result <- x
            
            vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
            vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\2")
            
            colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
            
            return(tibble_result)
            
          } ) %>%
              dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
              dplyr::left_join(., tibble_poison_exon_finder_summary)
            
            tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "matched_gene_names"] <- tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "psisigma_gene_symbol"]
            
            tibble_items_of_interest[tibble_items_of_interest$PEF_has_poison_region %>% is.na == TRUE, "PEF_has_poison_region"] <- FALSE
            tibble_items_of_interest[tibble_items_of_interest$PEF_has_frameshift %>% is.na == TRUE, "PEF_has_frameshift"] <- FALSE
            
            return(tibble_items_of_interest)
            
          } ) %>% return
        
      } )
    
  }, .progress = TRUE )

save(list_annotated_result_differential_comparisons_within_clusters, file = paste(R_processing_results_dir, "list_annotated_result_differential_comparisons_within_clusters.Rlist", sep = ""), compress = FALSE)

# write the whole thing as a long table
## rbind and tibblise 
long_table_annotated_result_differential_comparisons_within_clusters <- purrr::map2(
  .x = list_annotated_result_differential_comparisons_within_clusters,
  .y = names(list_annotated_result_differential_comparisons_within_clusters),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_differential_comparisons_within_clusters[[1]]
    # a2 <- names(list_annotated_result_differential_comparisons_within_clusters) %>% .[[1]]
    ###########
    
    purrr::map2(
      .x = a1,
      .y = names(a1),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% .[[1]]
        ###########
        
        purrr::map2(
          .x = b1,
          .y = b1 %>% names %>% gsub(pattern = ".*(comparison_._greater).*", replacement = "\\1"),
          .f = function(c1, c2) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            # c2 <- b1 %>% names %>% gsub(pattern = ".*(comparison_._greater).*", replacement = "\\1") %>% .[[1]]
            ###########
            
            c1 %>% 
              tibble::add_column(
                "greater_in_which_comparison" = c2,
                "comparison" = b2,
                "som_cluster" = a2
              ) %>%
              return
            
          } ) %>% rbindlist(fill = TRUE) %>% return
        
      } ) %>% rbindlist(fill = TRUE) %>% return
    
  } ) %>% rbindlist(fill = TRUE) %>% as_tibble

data.table::fwrite(x = long_table_annotated_result_differential_comparisons_within_clusters, file = paste(R_processing_results_dir, "long_table_annotated_result_differential_comparisons_within_clusters.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

### [zscore/maxmin] comparisons of different subtypes of samples between clusters

```{r}

# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 2)))

# annotate the comparison results here and save it.
list_annotated_result_sample_subtypes_between_clusters <- furrr::future_map(
  .x = list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_differential_result_sample_subtypes_between_clusters_row_indices_passed_threshold[[1]]
    ###########
    
    # loop positive/negative markers
    list_L2 <- furrr::future_map(
      .x = a1[c("list_LIV_row_indices_positive_markers_for_each_sample", "list_LIV_row_indices_negative_markers_for_each_sample")],
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[c("list_LIV_row_indices_positive_markers_for_each_sample", "list_LIV_row_indices_negative_markers_for_each_sample")] %>% .[[1]]
        ###########
        
        # NOTE: b1 is a vector of differential items for a particular pairwise comparison within a som cluster
        
        # loop each cluster
        furrr::future_map(
          .x = b1,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            ###########
            
            # subset the absolute PSI table according to those which met the filtering condition for each comparison
            # ALSO rename the columns to match the sample number in the UMAP
            tibble_items_of_interest <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[c1, ] %>%
          (function(x) {
            
            tibble_result <- x
            
            vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
            vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\2")
            
            colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
            
            return(tibble_result)
            
          } ) %>%
              dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
              dplyr::left_join(., tibble_poison_exon_finder_summary)
            
            tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "matched_gene_names"] <- tibble_items_of_interest[which(tibble_items_of_interest$matched_gene_names == ""), "psisigma_gene_symbol"]
            
            tibble_items_of_interest[tibble_items_of_interest$PEF_has_poison_region %>% is.na == TRUE, "PEF_has_poison_region"] <- FALSE
            tibble_items_of_interest[tibble_items_of_interest$PEF_has_frameshift %>% is.na == TRUE, "PEF_has_frameshift"] <- FALSE
            
            return(tibble_items_of_interest)
            
          } ) %>% return
        
      } )
    
  }, .progress = TRUE )

save(list_annotated_result_sample_subtypes_between_clusters, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_annotated_result_sample_subtypes_between_clusters.Rlist", sep = ""), compress = FALSE)

# write the whole thing as a long table
## rbind and tibblise 
long_table_annotated_result_sample_subtypes_between_clusters <- purrr::map2(
  .x = list_annotated_result_sample_subtypes_between_clusters,
  .y = names(list_annotated_result_sample_subtypes_between_clusters),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_sample_subtypes_between_clusters[[1]]
    # a2 <- names(list_annotated_result_sample_subtypes_between_clusters) %>% .[[1]]
    ###########
    
    purrr::map2(
      .x = a1,
      .y = names(a1) %>% gsub(pattern = "list_LIV_row_indices_(.*)s_for_each_sample", replacement = "\\1"),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% gsub(pattern = "list_LIV_row_indices_(.*)_for_each_sample", replacement = "\\1") %>% .[[1]]
        ###########
        
        purrr::map2(
          .x = b1,
          .y = names(b1),
          .f = function(c1, c2) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            # c2 <- names(b1) %>% .[[1]]
            ###########
            
            c1 %>% 
              tibble::add_column(
                "positive_or_negative_marker" = b2,
                "sample_name" = a2,
                "som_cluster" = c2
              ) %>%
              return
            
          } ) %>% rbindlist(fill = TRUE) %>% return
        
      } ) %>% rbindlist(fill = TRUE) %>% return
    
  } ) %>% rbindlist(fill = TRUE) %>% as_tibble

data.table::fwrite(x = long_table_annotated_result_sample_subtypes_between_clusters, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_long_table_annotated_result_sample_subtypes_between_clusters.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## gene ontology

```{r}

# library(rrvgo)
# library(org.Hs.eg.db)

# load catdb
load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

### DExpSeq: characteristic markers for each som cluster

NOTE: we are just going to do GO enrichment on both positive and negative markers.

```{r}

load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_annotated_pruned.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 3)))

list_characteristic_markers_for_each_som_cluster_hypergo <- furrr::future_map2(
  .x = list_characteristic_markers_for_each_som_cluster_annotated_pruned,
  .y = names(list_characteristic_markers_for_each_som_cluster_annotated_pruned),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_som_cluster_annotated_pruned[[2]]
    # a2 <- names(list_characteristic_markers_for_each_som_cluster_annotated_pruned) %>% .[[2]]
    ###########
    
    # cat(a2, "\n")
    
    tibble_hypergo_result <- furrr::future_map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = a1 %>% rbindlist %>% .$matched_gene_names %>% unique) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% as_tibble
    
    return(tibble_hypergo_result)
    
  }, .progress = TRUE )

list_characteristic_markers_for_each_som_cluster_hypergo_pruned <- list_characteristic_markers_for_each_som_cluster_hypergo %>% purrr::discard(.p = ~.x %>% length == 0)

save(list_characteristic_markers_for_each_som_cluster_hypergo_pruned, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_pruned.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_pruned.Rlist", sep = ""))

# write table
tibble_characteristic_markers_for_each_som_cluster_hypergo <- purrr::map2(
  .x = list_characteristic_markers_for_each_som_cluster_hypergo_pruned,
  .y = names(list_characteristic_markers_for_each_som_cluster_hypergo_pruned),
  .f = ~.x %>% tibble::add_column("som_cluster" = .y)
) %>% rbindlist %>% as_tibble

write.table(x = tibble_characteristic_markers_for_each_som_cluster_hypergo, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_characteristic_markers_for_each_som_cluster_hypergo.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# # prepare list of GOSemSim objects for each GO node
# list_GOSemSimDATA <- furrr::future_map(.x = c("BP" = "BP", "MF" = "MF", "CC" = "CC"), .f = ~GOSemSim::godata(org.Hs.eg.db, ont = .x), .progress = TRUE)
# 
# # plan(list(tweak(multiprocess, workers = 3),
# #           tweak(multiprocess, workers = 3)))
# 
# # NOTE: we can't fucking use furrr for L1 because of the fucking database queries
# 
# list_characteristic_markers_for_each_som_cluster_hypergo_reduced <- purrr::map2(
#   .x = list_characteristic_markers_for_each_som_cluster_hypergo_pruned,
#   .y = names(list_characteristic_markers_for_each_som_cluster_hypergo_pruned),
#   .f = function(a1, a2) {
#     
#     # DEBUG ###
#     # a1 <- list_characteristic_markers_for_each_som_cluster_hypergo_pruned$chucked_out_RNA_number_6774
#     # a2 <- names(list_characteristic_markers_for_each_som_cluster_hypergo_pruned %>% .["chucked_out_RNA_number_6774"]) 
#     ###########
#     
#     cat(a2, "\n")
#     
#     # filter the hypergo table 
#     tibble_hypergo_filtered <- a1 %>% dplyr::filter(Padj < 0.05 & NodeSize < 1000)
#     
#     purrr::map2(
#       .x = list_GOSemSimDATA,
#       .y = names(list_GOSemSimDATA),
#       possibly(.f = function(b1, b2) {
#         
#         # DEBUG ###
#         # b1 <- list_GOSemSimDATA[[1]]
#         # b2 <- names(list_GOSemSimDATA) %>% .[[1]]
#         ###########
#         
#         # reduce GO terms
#         matrix_rrvgo_simmatrix <- rrvgo::calculateSimMatrix(
#           x =  tibble_hypergo_filtered$GOID,
#           orgdb = org.Hs.eg.db,
#           semdata = b1,
#           ont = b2)
#         
#         df_reduced_goterms <- rrvgo::reduceSimMatrix(
#           simMatrix = matrix_rrvgo_simmatrix,
#           scores = tibble_hypergo_filtered$Padj %>% -log10(.) %>% as.vector %>% (function(x) {names(x) <- tibble_hypergo_filtered$GOID; return(x)}),
#           threshold = 0.7,
#           orgdb = org.Hs.eg.db)
#         
#         # filter the reduced goterms table
#         df_reduced_goterms_filtered <- df_reduced_goterms %>% 
#           dplyr::filter(size != 0) %>%
#           dplyr::mutate("Ont" = b2)
#         
#         return(df_reduced_goterms_filtered)
#         
#       }, otherwise = NA) ) %>% 
#       purrr::discard(.p = ~.x %>% is.na %>% .[1] == TRUE) %>% rbindlist %>% as_tibble %>% return
#     
#   } )
# 
# list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned <- list_characteristic_markers_for_each_som_cluster_hypergo_reduced %>% purrr::discard(.p = ~.x %>% length == 0) 
# 
# save(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned.Rlist", sep = ""), compress = FALSE)
# # load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned.Rlist", sep = ""))
# 
# # add in the hypergo padj values for both child and parent terms
# list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval <- purrr::pmap(
#   .l = list(
#     "a1" = list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned[intersect(names(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned), names(list_characteristic_markers_for_each_som_cluster_hypergo_pruned))],
#     "a2" = list_characteristic_markers_for_each_som_cluster_hypergo_pruned[intersect(names(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned), names(list_characteristic_markers_for_each_som_cluster_hypergo_pruned))],
#     "a3" = intersect(names(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_pruned), names(list_characteristic_markers_for_each_som_cluster_hypergo_pruned))
#   ),
#   .f = function(a1, a2, a3) {
#     
#     # DEBUG ###
#     # a1 <- list_characteristic_markers_for_each_som_cluster_hypergo_reduced[[1]]
#     # a2 <- list_characteristic_markers_for_each_som_cluster_hypergo_pruned[[1]]
#     ###########
#     
#     cat(a3, "\n")
# 
#     # if (a1 %>% nrow > 0) {
# 
#       a1 %>% 
#       dplyr::rename("child_term" = "term", "parent_term" = "parentTerm") %>%
#       dplyr::left_join(., a2[c("Term", "Padj")] %>% dplyr::rename("child_term" = "Term", "child_Padj" = "Padj")) %>% 
#       dplyr::left_join(., a2[c("Term", "Padj")] %>% dplyr::rename("parent_term" = "Term", "parent_Padj" = "Padj")) %>%
#       return
#       
#     # } else {
#     #   return(tibble())
#     # }
#     
#   } )
# 
# save(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval.Rlist", sep = ""), compress = FALSE)
# # load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval.Rlist", sep = ""))

# plot full GO terms
## because there are so few GO terms in common, we have to split by sample type

# grep names
list_som_cluster_groupings_for_plot <- list(
  "fibroblast_msc" = "som\\_cluster\\_(2$|3$|5|13|15|23|27|28)",
  "endothelial" = "som\\_cluster\\_(1$)",
  "T-ALL_B-ALL_LGL_APL" = "som\\_cluster\\_(8|9|32)",
  "neuroblastoma_CNS_nsclung_melanoma_prostate_renal_OV_BR_cancer" = "som\\_cluster\\_(10|11|14|17|18|19|24|25|26)",
  "keratinocyte" = "som\\_cluster\\_(6|21)",
  "DCs_macrophages_granulocytes" = "som\\_cluster\\_(16|22|31)",
  "all_tissues" = "som\\_cluster\\_(4|7|12|20|29|30)"
)

# re-plot with cherry-picked GO terms ####
list_cherrypicked_goterms <- list(
  "fibroblast_msc" = "som\\_cluster\\_(2$|3$|5|13|15|23|27|28)",
  "endothelial" = "som\\_cluster\\_(1$)",
  "T-ALL_B-ALL_LGL_APL" = "som\\_cluster\\_(8|9|32)",
  "neuroblastoma_CNS_nsclung_melanoma_prostate_renal_OV_BR_cancer" = "som\\_cluster\\_(10|11|14|17|18|19|24|25|26)",
  "keratinocyte" = "som\\_cluster\\_(6|21)",
  "DCs_macrophages_granulocytes" = "som\\_cluster\\_(16|22|31)",
  "all_tissues" = "som\\_cluster\\_(4|7|12|20|29|30)"
)
# ####

plan(multiprocess)
options(mc.cores = 4)

logical_replot <- FALSE

furrr::future_pmap(
  .l = list(
    "a1" = list_som_cluster_groupings_for_plot,
    "a2" = names(list_som_cluster_groupings_for_plot),
    "a3" = list_cherrypicked_goterms
  ),
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_som_cluster_groupings_for_plot[[2]]
    # a2 <- names(list_som_cluster_groupings_for_plot) %>% .[[2]]
    # a3 <- list_cherrypicked_goterms[[2]]
    ###########
    
    cat(a2, "\n")
    
    ## rbind and tibblise the gene ontology results (it's only ~80 tables)
    ## these will be used to ggplot. 
    long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot <- tibble_characteristic_markers_for_each_som_cluster_hypergo %>% 
      dplyr::filter(`NodeSize` < 1000 & `Padj` < 0.05) %>% 
      .[grep(x = .$som_cluster, pattern = a1), ] 
    
    if (logical_replot == TRUE) {
      
      long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot <- long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot[long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot$Term %in% a3, ]
      
    }
    
    # melt the table of GOterms per timepoint into separate columns for timepoints
    wide_tibble_hyperGO_per_timepoint <- reshape2::dcast(data = long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot,
                                                         formula = Term ~ som_cluster, value.var = "Padj") %>% as_tibble
    
    wide_tibble_hyperGO_per_timepoint[is.na(wide_tibble_hyperGO_per_timepoint)] <- 1
    
    if (wide_tibble_hyperGO_per_timepoint %>% ncol > 2) {
      
      # remove GO Terms which are not sig in at least one timepoint.
      ## vector of row indices where it's significant in at least one timepoint.
      # vec_row_indices_anysig <- wide_tibble_hyperGO_per_timepoint[, colnames(wide_tibble_hyperGO_per_timepoint) %>% .[colnames(wide_tibble_hyperGO_per_timepoint) != "Term"]] %>% array_tree %>% purrr::map(.f = ~any(.x <= 0.05)) %>% unlist %>% which(. == TRUE)
      # wide_tibble_hyperGO_per_timepoint <- wide_tibble_hyperGO_per_timepoint[vec_row_indices_anysig, ]
      
      # sort the GO terms (y-axis)
      y_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% as.matrix, method = "euclidean", threads = 32)
      y_hclust_result <- fastcluster::hclust(y_dist_result, method = "ward.D2")
      y_dendrogram <- as.dendrogram(y_hclust_result)
      
      y_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% t) %>% .[["rotation"]] %>% .[, 1]
      y_dendrogram_reordered <- reorder(y_dendrogram, y_matrix_PCA1_rowwise)
      
      # sort the group_names (x-axis)
      x_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% as.matrix %>% t, method = "euclidean", threads = 32)
      x_hclust_result <- fastcluster::hclust(x_dist_result, method = "ward.D2")
      x_dendrogram <- as.dendrogram(x_hclust_result)
      
      x_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% t) %>% .[["rotation"]] %>% .[, 1]
      x_dendrogram_reordered <- reorder(x_dendrogram, x_matrix_PCA1_rowwise)
      
      tibble_reordered <- wide_tibble_hyperGO_per_timepoint[y_dendrogram_reordered %>% unlist, c("Term", colnames(wide_tibble_hyperGO_per_timepoint) %>% .[(x_dendrogram_reordered %>% unlist + 1)])]
      
      # get the order due to the clustering
      vector_y_ordered <- tibble_reordered$Term
      vector_x_ordered <- tibble_reordered %>% dplyr::select(-Term) %>% colnames
      
    } else {
      
      vector_y_ordered <- wide_tibble_hyperGO_per_timepoint$Term
      vector_x_ordered <- wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% colnames
      
    }
    
    # melt for ggplot 
    # long_tibble_reordered <- reshape2::melt(tibble_reordered, variable.name = "group_name", value.name = "Padj", id.vars = c("Term")) %>% as_tibble
    
    # plot the main bulk RNA-Seq heatmap
    ggplot(long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot, aes(fill = -log10(Padj))) +
      geom_tile(aes(x = som_cluster, y = Term)) +
      ggtitle(paste("Heatmap of any significant GOterms per cluster/chucked out group ", a2, sep = "")) +
      scale_x_discrete(breaks = vector_x_ordered, labels = vector_x_ordered, limits = vector_x_ordered) +
      scale_y_discrete(breaks = vector_y_ordered[seq(from = 1, to = length(vector_y_ordered), by = 1)], labels = vector_y_ordered[seq(from = 1, to = length(vector_y_ordered), by = 1)] %>% str_trunc(width = 50, side = "center", ellipsis = "..."), limits = vector_y_ordered) +
      scale_fill_gradient2(low = "orange", mid = "brown", high = "black", na.value = "grey", midpoint = mean(max(-log10(long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot$Padj)), min(-log10(long_tibble_characteristic_markers_for_each_som_cluster_hypergo_plot$Padj)))) +
      # scale_fill_gradientn(colours = c(yellow", "red", "black"), values = c(1.3, 0.6, 0.5, 0), na.value = "grey") + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = if (logical_replot == TRUE) {10} else {12}, lineheight = 0.75, colour = "black", margin = margin(r = 10)), legend.title.align = 0.5, axis.text.y = element_text(size = if (logical_replot == TRUE) {10} else {0.5}, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 10)), text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_som_cluster_hypergo_heatmap_", a2, if (logical_replot == TRUE) {"_replot"}, ".pdf", sep = ""), device = "pdf", dpi = 600, width = if (logical_replot == TRUE) {15} else {40}, height = if (logical_replot == TRUE) {15} else {40}, units = "cm", limitsize = FALSE)
    
  }, .progress = TRUE)












# plot reduced GO terms - deprecated, since full GO terms don't seem to be too overwhelming
## because there are so few GO terms in common, we have to split by sample type

# rbind and tibblise the gene ontology results (it's only ~80 tables)
# these will be used to ggplot.
long_tibble_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval_plot <- purrr::map2(
  .x = list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval,
  .y = names(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval),
  .f = ~.x %>% dplyr::filter(`parent_Padj` < 0.05) %>% .[, c("parent_term", "parent_Padj")] %>% tibble::add_column("group_name" = .y)) %>%
  rbindlist %>% as_tibble %>% unique

 # %>% .[names(list_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval) %>% grep(pattern = "som\\_cluster\\_(12|14|37)")]

# melt the table of GOterms per timepoint into separate columns for timepoints
wide_tibble_hyperGO_per_timepoint <- reshape2::dcast(data = long_tibble_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval_plot,
                                                     formula = parent_term ~ group_name, value.var = "parent_Padj") %>% as_tibble

wide_tibble_hyperGO_per_timepoint[is.na(wide_tibble_hyperGO_per_timepoint)] <- 1

# remove GO Terms which are not sig in at least one timepoint.
## vector of row indices where it's significant in at least one timepoint.
# vec_row_indices_anysig <- wide_tibble_hyperGO_per_timepoint[, colnames(wide_tibble_hyperGO_per_timepoint) %>% .[colnames(wide_tibble_hyperGO_per_timepoint) != "parent_term"]] %>% array_tree %>% purrr::map(.f = ~any(.x <= 0.05)) %>% unlist %>% which(. == TRUE)
# wide_tibble_hyperGO_per_timepoint <- wide_tibble_hyperGO_per_timepoint[vec_row_indices_anysig, ]

# sort the GO terms (y-axis)
y_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% as.matrix, method = "euclidean", threads = 72)
y_hclust_result <- fastcluster::hclust(y_dist_result, method = "ward.D2")
y_dendrogram <- as.dendrogram(y_hclust_result)

y_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% t) %>% .[["rotation"]] %>% .[, 1]
y_dendrogram_reordered <- reorder(y_dendrogram, y_matrix_PCA1_rowwise)

# sort the group_names (x-axis)
x_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% as.matrix %>% t, method = "euclidean", threads = 72)
x_hclust_result <- fastcluster::hclust(x_dist_result, method = "ward.D2")
x_dendrogram <- as.dendrogram(x_hclust_result)

x_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% t) %>% .[["rotation"]] %>% .[, 1]
x_dendrogram_reordered <- reorder(x_dendrogram, x_matrix_PCA1_rowwise)

tibble_reordered <- wide_tibble_hyperGO_per_timepoint[y_dendrogram_reordered %>% unlist, c("parent_term", colnames(wide_tibble_hyperGO_per_timepoint) %>% .[(x_dendrogram_reordered %>% unlist + 1)])]

# get the order due to the clustering
vector_y_ordered <- tibble_reordered$parent_term
vector_x_ordered <- tibble_reordered %>% dplyr::select(-parent_term) %>% colnames

# melt for ggplot
# long_tibble_reordered <- reshape2::melt(tibble_reordered, variable.name = "group_name", value.name = "Padj", id.vars = c("Term")) %>% as_tibble

# plot the main bulk RNA-Seq heatmap
ggplot(long_tibble_characteristic_markers_for_each_som_cluster_hypergo_reduced_with_hypergo_pval_plot, aes(fill = -log10(parent_Padj))) +
  geom_tile(aes(x = group_name, y = parent_term)) +
  ggtitle(paste("Heatmap of reduced GOterms per cluster/chucked out group", sep = "")) +
  scale_x_discrete(breaks = vector_x_ordered, labels = vector_x_ordered, limits = vector_x_ordered) +
  scale_y_discrete(breaks = vector_y_ordered, labels = vector_y_ordered, limits = vector_y_ordered) +
  # [seq(from = 1, to = length(vector_y_ordered), by = 4)]
  scale_fill_gradient2(low = "orange", mid = "brown", high = "black", na.value = "grey", midpoint = 25) +
  # scale_fill_gradientn(colours = c(yellow", "red", "black"), values = c(1.3, 0.6, 0.5, 0), na.value = "grey") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4, lineheight = 0.75, colour = "black", margin = margin(r = 10)), legend.title.align = 0.5, axis.text.y = element_text(size = 0.5, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 10)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(R_processing_results_dir, "list_characteristic_markers_for_each_som_cluster_hypergo_reduced_plot_heatmap.pdf", sep = ""), device = "pdf", dpi = 600, width = 40, height = 40, units = "cm", limitsize = FALSE)

```

#### summarise go terms based on hierarchy

This is because we want to plot that global heatmap of all functional markers

##### aggregate B-H p-values

```{r}

tibble_characteristic_markers_for_each_som_cluster_hypergo <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_characteristic_markers_for_each_som_cluster_hypergo.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE) %>% as_tibble

tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0 <- tibble_characteristic_markers_for_each_som_cluster_hypergo %>%
  dplyr::filter(Padj <= 0.05) %>%
  dplyr::group_by(GOID, NodeSize, Term, Ont) %>%
  dplyr::summarise("Padj_aggregate" = min(Padj)) %>%
  dplyr::ungroup() 

```

##### simplify go terms by traversing the hierarchy

Seed from every GO term.
Grow seeds upwards through parents until there is no more benefit to taking the parent (i.e. the amount of junk child terms summarised along with the parents becomes too much AND/OR the accumulated p-value does not benefit)

Parents are only taken IF the peer relative entropy is LESS than the child relative entropy.
Relative entropy is defined as the entropy of terms below the Q-line divided by the entropy of terms above the Q-line. This stabilises and normalises the entropy values against differing numbers of peers and children.

THe loop is going to therefore refer to:
 -  CURRENT LEVEL: peers
 -  LEVEL BELOW: children
 -  LEVEL ABOVE: parents

Hence, we are going to *always* be comparing peer entropy to child entropy, with the peer level as the leading edge. Right before every increment, peer terms become child terms and the parent's peers will be taken as the new peers.

```{r}

# import go term hierarchy table
tibble_go_hierarchy0 <- data.table::fread(file = paste(reference_data_dir, "tibble_go_hierarchy_final.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE, na.strings = c("na", "NA", "")) %>% tibble::as_tibble()

tibble_go_hierarchy <- tibble_go_hierarchy0 %>% dplyr::distinct(id, parent_id, .keep_all = FALSE)

future::plan(future::multicore)
options(mc.cores = 96)

list_goterm_simplication_results <- furrr::future_imap(
  .x = tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0 %>% dplyr::rowwise() %>% dplyr::group_split(),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0 %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[750]]
    ###########
    
    cat(a2, "\n")
    
    list_current_entries_considered <- list(a1)
    # find the child entropy
    ## lookup original enrichment table for the children's enrichments
    list_enrichments_of_initial_children <- purrr::map(
      .x = list_current_entries_considered %>% purrr::map(~.x$GOID), 
      .f = function(b1) {
        
        return(
          list(
            "enrichment_match" = tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0[tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0$GOID %in% (tibble_go_hierarchy[tibble_go_hierarchy$parent_id == b1, ] %>% .$id), ],
            "vector_other_peers_with_no_match" = (tibble_go_hierarchy[tibble_go_hierarchy$parent_id == b1, ] %>% .$id) %>% .[!. %in% tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0$GOID]
          )
        )
        
      } )
    
    ## calculate the child relative entropy
    list_entropy_result_children <- purrr::map2(
      .x = list_enrichments_of_initial_children,
      .y = list_current_entries_considered,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_enrichments_of_initial_children[[1]]
        # b2 <- list_current_entries_considered[[1]]
        ###########
        
        # if no initial children, then set entropy to 99 because this would be the lowest level enriched.
        
        if (nrow(b1$enrichment_match) == 0 & length(b1$vector_other_peers_with_no_match) == 0) {
          entropy_factor <- 99
        } else {
          
          entropy_factor <- purrr::map(
          .x = c(b1$enrichment_match$Padj_aggregate, rep(1, times = length(b1$vector_other_peers_with_no_match))),
          .f = ~log(.x)
        ) %>% unlist %>% sum
        
          entropy_factor <- entropy_factor * (1/length(c(b1$enrichment_match$Padj_aggregate, rep(1, times = length(b1$vector_other_peers_with_no_match)))))
            
        }
        
        return(
          "entropy_factor" = entropy_factor
        )
        
      } )
    
    temp_continuing <- TRUE
    
    master_tibble_parent_entries <- tibble()
    
    # BEGIN LOOP
    while (temp_continuing == TRUE) {
      
      print("entropy factor: children")
      print(str(list_entropy_result_children))
      
      # fetch parent IDs based on current enrichment entries
      list_vector_parents <- purrr::map(
        .x = list_current_entries_considered, 
        .f = ~tibble_go_hierarchy[tibble_go_hierarchy$id == .x$GOID, ] %>% .$parent_id
      ) %>% 
        # account for scenario where there are no parents. we have to make tibble anyways 
        purrr::map_if(.p = ~.x %>% length == 0, .f = ~tibble())
      
      # lookup original enrichment table for the parents' enrichments
      list_enrichments_of_parents <- purrr::map(
        .x = list_vector_parents, 
        .f = function(b1) {
          
          purrr::map(
            .x = b1,
            .f = function(c1) {
              
              tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0[tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0$GOID == c1, ] %>% return
              
            }
          ) %>% return
          
        } )
      
      list_enrichments_of_all_peers <- purrr::map(
        .x = list_vector_parents, 
        .f = function(b1) {
          
          purrr::map(
            .x = b1,
            .f = function(c1) {
              
              return(
                list(
                  "enrichment_match" = tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0[tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0$GOID %in% (tibble_go_hierarchy[tibble_go_hierarchy$parent_id == c1, ] %>% .$id), ],
                  "vector_other_peers_with_no_match" = (tibble_go_hierarchy[tibble_go_hierarchy$parent_id == c1, ] %>% .$id) %>% .[!. %in% tibble_characteristic_markers_for_each_som_cluster_hypergo_summarised0$GOID]
                )
              )
              
            } ) %>% return
          
        } )
      
      # get entropy result from the child terms of parents
      # NOTE: if child term didn't exist in the enrichment, then its p-value is considered to be 1.
      list_entropy_result_peers <- purrr::map2(
        .x = list_enrichments_of_all_peers,
        .y = list_current_entries_considered,
        .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- list_enrichments_of_all_peers[[1]]
          # b2 <- list_current_entries_considered[[1]]
          ###########
          
          purrr::map(
            .x = b1,
            .f = function(c1) {
              
              # DEBUG ###
              # c1 <- b1[[1]]
              ###########
              
              # q_value <- if (c1$enrichment_match %>% nrow > 0) {stats::p.adjust(p = c1$enrichment_match$Padj_aggregate, method = "BH") %>% .[c1$enrichment_match$GOID == b2$GOID] %>% return} else {NA}
              # 
              # entropy_factor <- purrr::map(
              #   .x = c(c1$enrichment_match$Padj_aggregate %>% .[. > q_value], rep(1, times = length(c1$vector_other_peers_with_no_match))),
              #   .f = ~.x * log(.x * q_value, base = q_value)
              # ) %>% unlist %>% sum()
              
              entropy_factor <- purrr::map(
                .x = c(c1$enrichment_match$Padj_aggregate, rep(1, times = length(c1$vector_other_peers_with_no_match))),
                .f = ~log(.x)
              ) %>% unlist %>% sum 
              
              entropy_factor <- entropy_factor * (1/length(c(c1$enrichment_match$Padj_aggregate, rep(1, times = length(c1$vector_other_peers_with_no_match)))))
              
              return(
                "entropy_factor" = entropy_factor
              )
              
            } ) %>% return
          
        } )
      
      print("entropy factor: peers")
      print(str(list_entropy_result_peers))
      
      # if TRUE, then entropy of peers is smaller than entropy of children. This means that taking the parent was worth it.
      # This also means that we will have to keep moving upwards thru those parents.
      # here, we account for the case that we don't have any parents enriched
      list_entropy_children_vs_peers <- purrr::pmap(
        .l = list(
          "b1" = list_entropy_result_peers,
          "b2" = list_entropy_result_children,
          "b3" = list_enrichments_of_parents
        ),
        .f = function(b1, b2, b3) {
          
          # DEBUG ###
          # b1 <- list_entropy_result_peers[[3]]
          # b2 <- list_entropy_result_children[[3]]
          # b3 <- list_enrichments_of_parents[[3]]
          ###########
          
          purrr::pmap(
            .l = list(
              "c1" = b1,
              "c3" = b3
            ), 
            .f = function(c1, c3) {
              
              if (nrow(c3) == 0) {
                return(FALSE)
              } else {
                return(c1 < b2)
              }
              
            } ) %>% return
          
        } )
      
      if (any(list_entropy_children_vs_peers %>% unlist) == TRUE) {
        
        temp_continuing <- TRUE
        
        # add the terminated entries to master tibble
        ## terminated entries occur when the peer entropy becomes higher than the child entropy.
        ## This means it no longer makes sense to take the parent.
        master_tibble_parent_entries <- dplyr::bind_rows(
          master_tibble_parent_entries,
          list_current_entries_considered[list_entropy_children_vs_peers %>% purrr::map(~any(.x %>% unlist == FALSE)) %>% unlist] %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::add_column("seed" = a1$GOID, "terminal_type" = "node") %>% tibble::as_tibble()
        )
        
      } else {
        
        temp_continuing <- FALSE
        
        # add the leaves to the master tibble because these are the true terminal parent entries.
        master_tibble_parent_entries <- dplyr::bind_rows(
          master_tibble_parent_entries,
          list_current_entries_considered[list_entropy_children_vs_peers %>% purrr::map(~any(.x %>% unlist == FALSE)) %>% unlist] %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::add_column("seed" = a1$GOID, "terminal_type" = "leaf") %>% tibble::as_tibble()
        )
        
      }
      
      print("temp_continuing:")
      print(temp_continuing)
      
      # un-nest parent entries and assign them to the next round of current entries
      # NOTE: this is because we can have *multiple* child inputs to begin with; and MULTIPLE possible parents from each.
      list_current_entries_considered <- purrr::map2(
        .x = list_entropy_children_vs_peers,
        .y = list_enrichments_of_parents,
        .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- list_entropy_children_vs_peers[[1]]
          # b2 <- list_enrichments_of_parents[[1]]
          ###########
          
          list_continuing_parent_entries <- b2[b1 %>% unlist]
          
          return(list_continuing_parent_entries)
          
        } ) %>% purrr::flatten() %>%
        purrr::discard(.p = ~.x %>% nrow == 0)
      
      # un-nesst peer entropy and use as children for the next round
      list_entropy_result_children <- purrr::map2(
        .x = list_entropy_children_vs_peers,
        .y = list_entropy_result_peers,
        .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- list_entropy_children_vs_peers[[1]]
          # b2 <- list_enrichments_of_parents[[1]]
          ###########
          
          list_continuing_parent_entropies <- b2[b1 %>% unlist]
          
          return(list_continuing_parent_entropies)
          
        } ) %>% purrr::flatten()
      
    }
    
    # remove duplicate parents, especially node versions if there is already a leaf available. 
    master_tibble_parent_entries_filtered <- dplyr::bind_rows(
      master_tibble_parent_entries[master_tibble_parent_entries$terminal_type == "node", ] %>% .[!.$Term %in% (master_tibble_parent_entries[master_tibble_parent_entries$terminal_type == "leaf", ] %>% .$Term), ],
      master_tibble_parent_entries[master_tibble_parent_entries$terminal_type == "leaf", ]
    ) %>% dplyr::distinct(.keep_all = TRUE)
    
    return(master_tibble_parent_entries_filtered)
    
  }, .progress = TRUE )

tibble_goterm_simplication_results <- list_goterm_simplication_results %>% 
  data.table::rbindlist(use.names = TRUE, fill = TRUE) %>%
  tibble::as_tibble() %>%
  dplyr::distinct(.keep_all = TRUE) %>%
  dplyr::group_by(GOID, NodeSize, Term, Ont, Padj_aggregate, terminal_type) %>%
  dplyr::summarise("seeds" = paste(`seed`, collapse = ",")) %>% 
  # add depth
  dplyr::left_join(., tibble_go_hierarchy0[, c("id", "id_depth", "parent_id", "parent_id_depth", "depth_proximity")] %>% unique %>% dplyr::rename("GOID" = "id"))

write.table(x = tibble_goterm_simplication_results, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_goterm_simplication_results.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# tibble_goterm_simplication_results <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_goterm_simplication_results.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE, header = TRUE) %>% tibble::as_tibble()

```

### Z-scores: finding the characteristic set of LISs for each chucked out samples

NOTE: we are just going to do GO enrichment on both positive and negative markers.

```{r}

load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_annotated.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 40),
          tweak(multiprocess, workers = 3)))

list_characteristic_markers_for_each_chucked_out_sample_hypergo <- furrr::future_map2(
  .x = list_characteristic_markers_for_each_chucked_out_sample_annotated,
  .y = names(list_characteristic_markers_for_each_chucked_out_sample_annotated),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_chucked_out_sample_annotated[[2]]
    # a2 <- names(list_characteristic_markers_for_each_chucked_out_sample_annotated) %>% .[[2]]
    ###########
    
    # cat(a2, "\n")
    
    tibble_hypergo_result <- furrr::future_map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = a1 %>% rbindlist %>% .$matched_gene_names %>% unique) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% as_tibble
    
    return(tibble_hypergo_result)
    
  }, .progress = TRUE )

save(list_characteristic_markers_for_each_chucked_out_sample_hypergo, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_characteristic_markers_for_each_chucked_out_sample_hypergo.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo.Rlist", sep = ""))

# write table
tibble_characteristic_markers_for_each_chucked_out_sample_hypergo <- purrr::map2(
  .x = list_characteristic_markers_for_each_chucked_out_sample_hypergo,
  .y = names(list_characteristic_markers_for_each_chucked_out_sample_hypergo),
  .f = ~.x %>% tibble::add_column("group_name" = .y)
) %>% rbindlist %>% as_tibble

data.table::fwrite(x = tibble_characteristic_markers_for_each_chucked_out_sample_hypergo, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# # prepare list of GOSemSim objects for each GO node
# list_GOSemSimDATA <- furrr::future_map(.x = c("BP" = "BP", "MF" = "MF", "CC" = "CC"), .f = ~GOSemSim::godata(org.Hs.eg.db, ont = .x), .progress = TRUE)
# 
# # plan(list(tweak(multiprocess, workers = 3),
# #           tweak(multiprocess, workers = 3)))
# 
# # NOTE: we can't fucking use furrr for L1 because of the fucking database queries
# 
# list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced <- purrr::map2(
#   .x = list_characteristic_markers_for_each_chucked_out_sample_hypergo,
#   .y = names(list_characteristic_markers_for_each_chucked_out_sample_hypergo),
#   .f = function(a1, a2) {
#     
#     # DEBUG ###
#     # a1 <- list_characteristic_markers_for_each_chucked_out_sample_hypergo$chucked_out_RNA_number_6774
#     # a2 <- names(list_characteristic_markers_for_each_chucked_out_sample_hypergo %>% .["chucked_out_RNA_number_6774"]) 
#     ###########
#     
#     cat(a2, "\n")
#     
#     # filter the hypergo table 
#     tibble_hypergo_filtered <- a1 %>% dplyr::filter(Padj < 0.05 & NodeSize < 1000)
#     
#     purrr::map2(
#       .x = list_GOSemSimDATA,
#       .y = names(list_GOSemSimDATA),
#       possibly(.f = function(b1, b2) {
#         
#         # DEBUG ###
#         # b1 <- list_GOSemSimDATA[[1]]
#         # b2 <- names(list_GOSemSimDATA) %>% .[[1]]
#         ###########
#         
#         # reduce GO terms
#         matrix_rrvgo_simmatrix <- rrvgo::calculateSimMatrix(
#           x =  tibble_hypergo_filtered$GOID,
#           orgdb = org.Hs.eg.db,
#           semdata = b1,
#           ont = b2)
#         
#         df_reduced_goterms <- rrvgo::reduceSimMatrix(
#           simMatrix = matrix_rrvgo_simmatrix,
#           scores = tibble_hypergo_filtered$Padj %>% -log10(.) %>% as.vector %>% (function(x) {names(x) <- tibble_hypergo_filtered$GOID; return(x)}),
#           threshold = 0.7,
#           orgdb = org.Hs.eg.db)
#         
#         # filter the reduced goterms table
#         df_reduced_goterms_filtered <- df_reduced_goterms %>% 
#           dplyr::filter(size != 0) %>%
#           dplyr::mutate("Ont" = b2)
#         
#         return(df_reduced_goterms_filtered)
#         
#       }, otherwise = NA) ) %>% 
#       purrr::discard(.p = ~.x %>% is.na %>% .[1] == TRUE) %>% rbindlist %>% as_tibble %>% return
#     
#   } )
# 
# save(list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced, file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced.Rlist", sep = ""), compress = FALSE)
# # load(file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced.Rlist", sep = ""))
# 
# # add in the hypergo padj values for both child and parent terms
# list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval <- purrr::pmap(
#   .l = list(
#     "a1" = list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced,
#     "a2" = list_characteristic_markers_for_each_chucked_out_sample_hypergo,
#     "a3" = names(list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced)
#   ),
#   .f = function(a1, a2, a3) {
#     
#     # DEBUG ###
#     # a1 <- list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced$`chucked_out_RNA_number_6774`
#     # a2 <- list_characteristic_markers_for_each_chucked_out_sample_hypergo$`chucked_out_RNA_number_6774`
#     ###########
#     
#     cat(a3, "\n")
# 
#     # if (a1 %>% nrow > 0) {
# 
#       a1 %>% 
#       dplyr::rename("child_term" = "term", "parent_term" = "parentTerm") %>%
#       dplyr::left_join(., a2[c("Term", "Padj")] %>% dplyr::rename("child_term" = "Term", "child_Padj" = "Padj")) %>% 
#       dplyr::left_join(., a2[c("Term", "Padj")] %>% dplyr::rename("parent_term" = "Term", "parent_Padj" = "Padj")) %>%
#       return
#       
#     # } else {
#     #   return(tibble())
#     # }
#     
#   } )
# 
# save(list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval, file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval.Rlist", sep = ""), compress = FALSE)
# # load(file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval.Rlist", sep = ""))
# 
# # plot full GO terms
# ## because there are so few GO terms in common, we have to split by sample type
# 
# # grep names
# list_som_cluster_groupings_for_plot <- list(
#   "fibroblast_msc" = "som\\_cluster\\_(1$|16|24|29|39)",
#   "endothelial" = "som\\_cluster\\_(12|14|37)",
#   "T-ALL_B-ALL_granulocyte" = "som\\_cluster\\_(7|11)",
#   "neuroblastoma_CNS_nsclung_prostate_renal_OV_BR_cancer" = "som\\_cluster\\_(3$|5|15|19|27|32|33|38)",
#   "keratinocyte" = "som\\_cluster\\_(14|30)",
#   "mixed_astrocyte_mesangial_muscle_epithelial_hairsheath_melanocyte" = "som\\_cluster\\_(4|6|9|13|16|20|29|31)",
#   "DCs_macrophages" = "som\\_cluster\\_(21|25|35|36)",
#   "all_tissues" = "som\\_cluster\\_(2$|8|10|17|26)"
# )
# 
# # re-plot with cherry-picked GO terms ####
# list_cherrypicked_goterms <- list(
#   "fibroblast_msc" = "telomerase holoenzyme complex
# positive regulation of fibroblast proliferation
# histone modification
# type I interferon production
# protein serine/threonine kinase activity
# trans−Golgi network
# transcription factor binding
# ubiquitin−dependent ERAD pathway
# focal adhesion
# SRP−dependent cotranslational protein targeting to membrane
# response to interferon−beta
# osteoblast differentiation
# CRD−mediated mRNA stabilization
# response to unfolded protein
# alternative mRNA splicing, via spliceosome
# Golgi to plasma membrane transport
# regulation of IRE1−mediated unfolded protein response
# disordered domain specific binding
# ubiquitin protein ligase binding
# DNA damage checkpoint
# I−kappaB kinase/NF−kappaB signaling
# integrin−mediated signaling pathway
# INO80−type complex
# SWI/SNF superfamily−type complex
# retrograde transport, endosome to Golgi
# actin cytoskeleton organization
# regulation of receptor−mediated endocytosis
# histone acetyltransferase complex
# COPII−coated vesicle budding
# sterol response element binding
# negative regulation of MAPK cascade
# negative regulation of intracellular lipid transport
# negative regulation of intracellular cholesterol transport" %>% strsplit(split = "\n") %>% unlist,
#   "endothelial" = "leukocyte degranulation
# exocytosis
# SH3 domain binding
# contractile actin filament bundle
# NADPH regeneration
# H4 histone acetyltransferase complex
# COPI−coated vesicle
# SRP−dependent cotranslational protein targeting to membrane
# nuclear−transcribed mRNA catabolic process, nonsense−mediated decay
# trans−Golgi network
# SMAD protein complex
# nuclear−transcribed mRNA catabolic process, no−go decay
# protein farnesyltransferase activity
# Notch binding
# endothelial cell development
# response to wounding
# G2 DNA damage checkpoint
# establishment of endothelial barrier
# GTP binding
# type I interferon production
# mRNA splicing, via spliceosome
# small GTPase binding
# protein serine/threonine kinase activity
# regulation of telomere maintenance via telomere lengthening
# regulation of response to macrophage colony−stimulating factor
# interleukin−3 receptor activity
# transcription coregulator activity
# response to unfolded protein
# Notch signaling pathway
# positive regulation of Schwann cell differentiation
# cell cycle G2/M phase transition
# positive regulation of NF−kappaB transcription factor activity
# regulation of interleukin−12 biosynthetic process
# Golgi to plasma membrane transport
# ubiquitin−dependent ERAD pathway
# response to macrophage colony−stimulating factor
# histone methyltransferase complex" %>% strsplit(split = "\n") %>% unlist,
#   "T-ALL_B-ALL_granulocyte" = "PML body
# mitotic spindle microtubule
# mRNA 3'−UTR binding
# telomere maintenance via telomere lengthening
# DNA damage response, detection of DNA damage
# N6−methyladenosine−containing RNA binding
# azurophil granule
# methylenetetrahydrofolate dehydrogenase (NAD+) activity
# Golgi vesicle transport
# tetrahydrofolate interconversion
# regulation of cell−cell adhesion mediated by integrin
# nuclear−transcribed mRNA catabolic process, nonsense−mediated decay
# focal adhesion
# SRP−dependent cotranslational protein targeting to membrane
# mRNA splicing, via spliceosome
# interleukin−12−mediated signaling pathway
# mitotic G2/M transition checkpoint
# negative regulation of programmed cell death
# positive regulation of intrinsic apoptotic signaling pathway by p53 class mediator
# MHC class I peptide loading complex
# cellular response to interleukin−12
# phosphatidylinositol−3,5−bisphosphate binding
# trans−Golgi network
# mRNA 5'−UTR binding
# actin cytoskeleton organization
# microtubule cytoskeleton organization
# integrin−mediated signaling pathway
# Fc receptor mediated stimulatory signaling pathway
# vascular endothelial cell proliferation
# regulation of leukocyte activation
# regulation of granulocyte differentiation
# antigen receptor−mediated signaling pathway
# regulation of lymphocyte activation
# regulation of T cell activation
# B cell proliferation
# lymphocyte proliferation
# T cell proliferation
# small GTPase binding
# T cell differentiation
# Fc receptor signaling pathway" %>% strsplit(split = "\n") %>% unlist,
#   "neuroblastoma_CNS_nsclung_prostate_renal_OV_BR_cancer" = "COPII−coated vesicle budding
# Golgi vesicle budding
# G2/M transition of mitotic cell cycle
# pro−B cell differentiation
# TOR signaling
# regulation of double−strand break repair
# negative regulation of response to DNA damage stimulus
# G−quadruplex DNA unwinding
# TORC1 signaling
# histone modification
# activation of protein kinase B activity
# immunoglobulin V(D)J recombination
# TORC2 complex
# transcription coregulator activity
# protein kinase activity
# alternative mRNA splicing, via spliceosome
# cellular response to interleukin−6
# GTPase binding
# Ras GTPase binding
# interleukin−6−mediated signaling pathway
# Golgi to plasma membrane protein transport
# CD40 receptor complex
# actin cytoskeleton organization
# Rab GTPase binding
# histone methylation
# microtubule−based process
# microtubule cytoskeleton organization
# BLOC complex
# PML body
# COPII−coated ER to Golgi transport vesicle
# developmental growth
# Wnt signaling pathway
# H4 histone acetyltransferase complex
# NADPH regeneration
# nuclear−transcribed mRNA catabolic process, nonsense−mediated decay
# histone acetyltransferase complex
# SRP−dependent cotranslational protein targeting to membrane
# focal adhesion
# IRE1−mediated unfolded protein response
# DNA integrity checkpoint
# DNA damage checkpoint" %>% strsplit(split = "\n") %>% unlist,
#   "keratinocyte" = "contractile actin filament bundle
# NADPH regeneration
# H4 histone acetyltransferase complex
# exocytosis
# leukocyte degranulation
# immune response−activating cell surface receptor signaling pathway
# SRP−dependent cotranslational protein targeting to membrane
# lysosome
# COPI−coated vesicle
# secretory granule
# focal adhesion
# trans−Golgi network
# IRE1−mediated unfolded protein response
# ERBB2 signaling pathway
# autophagy of mitochondrion
# mitotic G1 DNA damage checkpoint
# ERBB signaling pathway
# PML body
# response to tetrahydrofolate
# mRNA splicing, via spliceosome
# transcription coregulator activity
# Rab GTPase binding
# autophagy
# transport along microtubule
# GTPase binding" %>% strsplit(split = "\n") %>% unlist,
#   "mixed_astrocyte_mesangial_muscle_epithelial_hairsheath_melanocyte" = "SREBP−SCAP−Insig complex
# epidermal cell differentiation
# cellular response to salt
# ER to Golgi vesicle−mediated transport
# epithelial cell differentiation
# COPII−coated ER to Golgi transport vesicle
# cell cortex
# fibroblast growth factor production
# CENP−A containing nucleosome assembly
# Swr1 complex
# ubiquitin−dependent ERAD pathway
# protein serine/threonine kinase activity
# type I interferon production
# threonine aldolase activity
# transcription factor binding
# negative regulation of telomere capping
# telomerase holoenzyme complex
# microtubule plus−end binding
# protein K63−linked ubiquitination
# NIK/NF−kappaB signaling
# mRNA 3'−UTR binding
# regulation of interleukin−2 secretion
# SREBP signaling pathway
# cholesterol metabolic process
# negative regulation of histone H3−K4 methylation
# histone modification
# histone H3−K36 methylation
# histone H4 acetylation
# regulation of telomerase RNA localization to Cajal body
# ERBB signaling pathway
# response to interleukin−12
# estradiol secretion
# U2 snRNP
# focal adhesion
# nuclear−transcribed mRNA catabolic process, nonsense−mediated decay
# alternative mRNA splicing, via spliceosome
# G2/M transition of mitotic cell cycle
# RISC complex
# DNA damage response, detection of DNA damage
# antigen processing and presentation of peptide antigen via MHC class II
# response to leukemia inhibitory factor
# histone acetyltransferase complex
# regulation of microtubule polymerization
# response to interleukin−4
# lysosome" %>% strsplit(split = "\n") %>% unlist,
#   "DCs_macrophages" = "mature B cell differentiation
# B cell activation
# B cell mediated immunity
# MHC class II protein complex binding
# neutrophil mediated immunity
# regulation of I−kappaB kinase/NF−kappaB signaling
# alternative mRNA splicing, via spliceosome
# trans−Golgi network
# autophagy
# post−Golgi vesicle−mediated transport
# ERAD pathway
# transport along microtubule
# type I interferon production
# response to interleukin−12
# MHC class II protein complex assembly
# interleukin−12 production
# T cell activation involved in immune response
# CD4−positive, alpha−beta T cell differentiation
# interleukin−2−mediated signaling pathway
# antigen processing and presentation of peptide antigen via MHC class I
# PML body
# JNK cascade
# T cell differentiation
# COPII−coated ER to Golgi transport vesicle
# Rho GTPase binding
# Rac GTPase binding
# Fc−gamma receptor signaling pathway involved in phagocytosis
# secretory granule membrane
# leukocyte degranulation
# phosphatidylinositol−3,4−bisphosphate binding
# Ran GTPase binding
# interleukin−6−mediated signaling pathway
# spliceosomal snRNP complex
# negative regulation of ERBB signaling pathway
# SNARE binding
# cell cycle G1/S phase transition
# transcription factor binding
# Cul4−RING E3 ubiquitin ligase complex
# IRE1−mediated unfolded protein response
# interleukin−9−mediated signaling pathway
# cellular response to interleukin−9
# toll−like receptor 7 signaling pathway
# interleukin−1 production
# positive regulation of CD4−positive, alpha−beta T cell differentiation
# regulation of interleukin−4 production
# positive regulation of interleukin−2 production
# interleukin−10 production
# positive regulation of JNK cascade
# interleukin−6 production
# response to interleukin−3
# T cell mediated cytotoxicity
# leukocyte mediated cytotoxicity
# MHC class II receptor activity
# regulation of histone H3−K36 methylation
# V(D)J recombination
# MHC class I protein binding
# TORC2 complex
# SWI/SNF complex
# TOR complex
# TORC1 complex
# SMAD protein complex assembly
# positive regulation of CD8−positive, alpha−beta T cell activation
# PERK−mediated unfolded protein response
# regulation of CD40 signaling pathway
# antigen processing and presentation of peptide antigen via MHC class Ib
# N−acyltransferase activity
# positive regulation of alpha−beta T cell activation
# MyD88−independent toll−like receptor signaling pathway
# interferon−beta production
# retinoid X receptor binding
# SWI/SNF superfamily−type complex
# p38MAPK cascade
# Wnt signaling pathway" %>% strsplit(split = "\n") %>% unlist,
#   "all_tissues" = "postsynapse
# axon
# vesicle−mediated transport in synapse
# presynapse
# contractile actin filament bundle assembly
# neurotransmitter secretion
# dendrite development
# microtubule binding
# neuronal cell body
# ARF protein signal transduction
# synaptic vesicle transport
# regulation of NMDA receptor activity
# clathrin coat disassembly
# synaptic vesicle recycling
# SNARE complex
# Golgi to lysosome transport
# COPII−coated vesicle budding
# growth cone
# post−Golgi vesicle−mediated transport
# regulation of GTPase activity
# contractile actin filament bundle
# focal adhesion
# response to type I interferon
# TAP binding
# nuclear−transcribed mRNA catabolic process, nonsense−mediated decay
# U2−type spliceosomal complex
# Cul4−RING E3 ubiquitin ligase complex
# spliceosomal complex
# G2/M transition of mitotic cell cycle
# protein kinase binding
# H4 histone acetyltransferase complex
# alternative mRNA splicing, via spliceosome
# interleukin−12−mediated signaling pathway
# TOR signaling
# regulation of TOR signaling
# positive regulation of cell death
# regulation of Wnt signaling pathway
# mRNA 3'−UTR binding
# H4 histone acetyltransferase activity" %>% strsplit(split = "\n") %>% unlist
# )
# # ####
# 
# plan(multiprocess)
# options(mc.cores = 16)
# 
# logical_replot <- FALSE
# 
# furrr::future_pmap(
#   .l = list(
#     "a1" = list_som_cluster_groupings_for_plot,
#     "a2" = names(list_som_cluster_groupings_for_plot),
#     "a3" = list_cherrypicked_goterms
#   ),
#   .f = function(a1, a2, a3) {
#     
#     # DEBUG ###
#     # a1 <- list_som_cluster_groupings_for_plot[[1]]
#     # a2 <- names(list_som_cluster_groupings_for_plot) %>% .[[1]]
#     # a3 <- list_cherrypicked_goterms[[1]]
#     ###########
#     
#     ## rbind and tibblise the gene ontology results (it's only ~80 tables)
#     ## these will be used to ggplot. 
#     long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_plot <- purrr::map2(
#       .x = list_characteristic_markers_for_each_chucked_out_sample_hypergo,
#       .y = names(list_characteristic_markers_for_each_chucked_out_sample_hypergo),
#       .f = ~.x %>% dplyr::filter(`NodeSize` < 1000 & `Padj` < 0.05) %>% .[, c("Term", "Padj")] %>% tibble::add_column("group_name" = .y)) %>%
#       .[names(list_characteristic_markers_for_each_chucked_out_sample_hypergo) %>% grep(pattern = a1)] %>%
#       rbindlist %>% as_tibble
#     
#     if (logical_replot == TRUE) {
#       
#       long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_plot <- long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_plot[long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_plot$Term %in% a3, ]
#       
#     }
#     
#     # melt the table of GOterms per timepoint into separate columns for timepoints
#     wide_tibble_hyperGO_per_timepoint <- reshape2::dcast(data = long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_plot,
#                                                          formula = Term ~ group_name, value.var = "Padj") %>% as_tibble
#     
#     wide_tibble_hyperGO_per_timepoint[is.na(wide_tibble_hyperGO_per_timepoint)] <- 1
#     
#     # remove GO Terms which are not sig in at least one timepoint.
#     ## vector of row indices where it's significant in at least one timepoint.
#     # vec_row_indices_anysig <- wide_tibble_hyperGO_per_timepoint[, colnames(wide_tibble_hyperGO_per_timepoint) %>% .[colnames(wide_tibble_hyperGO_per_timepoint) != "Term"]] %>% array_tree %>% purrr::map(.f = ~any(.x <= 0.05)) %>% unlist %>% which(. == TRUE)
#     # wide_tibble_hyperGO_per_timepoint <- wide_tibble_hyperGO_per_timepoint[vec_row_indices_anysig, ]
#     
#     # sort the GO terms (y-axis)
#     y_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% as.matrix, method = "euclidean", threads = 32)
#     y_hclust_result <- fastcluster::hclust(y_dist_result, method = "ward.D2")
#     y_dendrogram <- as.dendrogram(y_hclust_result)
#     
#     y_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% t) %>% .[["rotation"]] %>% .[, 1]
#     y_dendrogram_reordered <- reorder(y_dendrogram, y_matrix_PCA1_rowwise)
#     
#     # sort the group_names (x-axis)
#     x_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% as.matrix %>% t, method = "euclidean", threads = 32)
#     x_hclust_result <- fastcluster::hclust(x_dist_result, method = "ward.D2")
#     x_dendrogram <- as.dendrogram(x_hclust_result)
#     
#     x_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% t) %>% .[["rotation"]] %>% .[, 1]
#     x_dendrogram_reordered <- reorder(x_dendrogram, x_matrix_PCA1_rowwise)
#     
#     tibble_reordered <- wide_tibble_hyperGO_per_timepoint[y_dendrogram_reordered %>% unlist, c("Term", colnames(wide_tibble_hyperGO_per_timepoint) %>% .[(x_dendrogram_reordered %>% unlist + 1)])]
#     
#     # get the order due to the clustering
#     vector_y_ordered <- tibble_reordered$Term
#     vector_x_ordered <- tibble_reordered %>% dplyr::select(-Term) %>% colnames
#     
#     # melt for ggplot 
#     # long_tibble_reordered <- reshape2::melt(tibble_reordered, variable.name = "group_name", value.name = "Padj", id.vars = c("Term")) %>% as_tibble
#     
#     # plot the main bulk RNA-Seq heatmap
#     ggplot(long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_plot, aes(fill = -log10(Padj))) +
#       geom_tile(aes(x = group_name, y = Term)) +
#       ggtitle(paste("Heatmap of any significant GOterms per cluster/chucked out group ", a2, sep = "")) +
#       scale_x_discrete(breaks = vector_x_ordered, labels = vector_x_ordered, limits = vector_x_ordered) +
#       scale_y_discrete(breaks = vector_y_ordered[seq(from = 1, to = length(vector_y_ordered), by = 1)], labels = vector_y_ordered[seq(from = 1, to = length(vector_y_ordered), by = 1)] %>% str_trunc(width = 50, side = "center", ellipsis = "..."), limits = vector_y_ordered) +
#       scale_fill_gradient2(low = "orange", mid = "brown", high = "black", na.value = "grey", midpoint = 25) +
#       # scale_fill_gradientn(colours = c(yellow", "red", "black"), values = c(1.3, 0.6, 0.5, 0), na.value = "grey") + 
#       theme(axis.text.x = element_text(angle = 45, hjust = 1, size = if (logical_replot == TRUE) {10} else {12}, lineheight = 0.75, colour = "black", margin = margin(r = 10)), legend.title.align = 0.5, axis.text.y = element_text(size = if (logical_replot == TRUE) {10} else {0.5}, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 10)), text = element_text(family = "Helvetica")) +
#       ggsave(filename = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo_heatmap_", a2, if (logical_replot == TRUE) {"_replot"}, ".pdf", sep = ""), device = "pdf", dpi = 600, width = if (logical_replot == TRUE) {15} else {40}, height = if (logical_replot == TRUE) {15} else {40}, units = "cm", limitsize = FALSE)
#     
#   }, .progress = TRUE)
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# # plot reduced GO terms - deprecated, since full GO terms don't seem to be too overwhelming
# ## because there are so few GO terms in common, we have to split by sample type
# 
# # rbind and tibblise the gene ontology results (it's only ~80 tables)
# # these will be used to ggplot.
# long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval_plot <- purrr::map2(
#   .x = list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval,
#   .y = names(list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval),
#   .f = ~.x %>% dplyr::filter(`parent_Padj` < 0.05) %>% .[, c("parent_term", "parent_Padj")] %>% tibble::add_column("group_name" = .y)) %>%
#   rbindlist %>% as_tibble %>% unique
# 
#  # %>% .[names(list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval) %>% grep(pattern = "som\\_cluster\\_(12|14|37)")]
# 
# # melt the table of GOterms per timepoint into separate columns for timepoints
# wide_tibble_hyperGO_per_timepoint <- reshape2::dcast(data = long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval_plot,
#                                                      formula = parent_term ~ group_name, value.var = "parent_Padj") %>% as_tibble
# 
# wide_tibble_hyperGO_per_timepoint[is.na(wide_tibble_hyperGO_per_timepoint)] <- 1
# 
# # remove GO Terms which are not sig in at least one timepoint.
# ## vector of row indices where it's significant in at least one timepoint.
# # vec_row_indices_anysig <- wide_tibble_hyperGO_per_timepoint[, colnames(wide_tibble_hyperGO_per_timepoint) %>% .[colnames(wide_tibble_hyperGO_per_timepoint) != "parent_term"]] %>% array_tree %>% purrr::map(.f = ~any(.x <= 0.05)) %>% unlist %>% which(. == TRUE)
# # wide_tibble_hyperGO_per_timepoint <- wide_tibble_hyperGO_per_timepoint[vec_row_indices_anysig, ]
# 
# # sort the GO terms (y-axis)
# y_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% as.matrix, method = "euclidean", threads = 72)
# y_hclust_result <- fastcluster::hclust(y_dist_result, method = "ward.D2")
# y_dendrogram <- as.dendrogram(y_hclust_result)
# 
# y_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% t) %>% .[["rotation"]] %>% .[, 1]
# y_dendrogram_reordered <- reorder(y_dendrogram, y_matrix_PCA1_rowwise)
# 
# # sort the group_names (x-axis)
# x_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% as.matrix %>% t, method = "euclidean", threads = 72)
# x_hclust_result <- fastcluster::hclust(x_dist_result, method = "ward.D2")
# x_dendrogram <- as.dendrogram(x_hclust_result)
# 
# x_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-parent_term) %>% t) %>% .[["rotation"]] %>% .[, 1]
# x_dendrogram_reordered <- reorder(x_dendrogram, x_matrix_PCA1_rowwise)
# 
# tibble_reordered <- wide_tibble_hyperGO_per_timepoint[y_dendrogram_reordered %>% unlist, c("parent_term", colnames(wide_tibble_hyperGO_per_timepoint) %>% .[(x_dendrogram_reordered %>% unlist + 1)])]
# 
# # get the order due to the clustering
# vector_y_ordered <- tibble_reordered$parent_term
# vector_x_ordered <- tibble_reordered %>% dplyr::select(-parent_term) %>% colnames
# 
# # melt for ggplot
# # long_tibble_reordered <- reshape2::melt(tibble_reordered, variable.name = "group_name", value.name = "Padj", id.vars = c("Term")) %>% as_tibble
# 
# # plot the main bulk RNA-Seq heatmap
# ggplot(long_tibble_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_with_hypergo_pval_plot, aes(fill = -log10(parent_Padj))) +
#   geom_tile(aes(x = group_name, y = parent_term)) +
#   ggtitle(paste("Heatmap of reduced GOterms per cluster/chucked out group", sep = "")) +
#   scale_x_discrete(breaks = vector_x_ordered, labels = vector_x_ordered, limits = vector_x_ordered) +
#   scale_y_discrete(breaks = vector_y_ordered, labels = vector_y_ordered, limits = vector_y_ordered) +
#   # [seq(from = 1, to = length(vector_y_ordered), by = 4)]
#   scale_fill_gradient2(low = "orange", mid = "brown", high = "black", na.value = "grey", midpoint = 25) +
#   # scale_fill_gradientn(colours = c(yellow", "red", "black"), values = c(1.3, 0.6, 0.5, 0), na.value = "grey") +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4, lineheight = 0.75, colour = "black", margin = margin(r = 10)), legend.title.align = 0.5, axis.text.y = element_text(size = 0.5, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 10)), text = element_text(family = "Helvetica")) +
#   ggsave(filename = paste(R_processing_results_dir, "list_characteristic_markers_for_each_chucked_out_sample_hypergo_reduced_plot_heatmap.pdf", sep = ""), device = "pdf", dpi = 600, width = 40, height = 40, units = "cm", limitsize = FALSE)

```

### [DExpSeq] inter-cluster comparisons of relatively homogenous subtypes

```{r}

load(file = paste(R_processing_results_dir, "list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 3)))

list_DExpSeq_intercluster_comparisons_differential_biomarkers_hypergo <- furrr::future_map(
  .x = list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_DExpSeq_intercluster_comparisons_differential_biomarkers_annotated[[1]]
    ###########
    
    L1_result <- furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        L2_result <- furrr::future_map(
          .x = b1,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            ###########
            
            tibble_hypergo_result <- furrr::future_map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = c1$matched_gene_names %>% unique) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% as_tibble
            
            return(tibble_hypergo_result)
            
          } )
        
      } )
    
  }, .progress = TRUE, .options = furrr_options(seed = 8) )

save(list_DExpSeq_intercluster_comparisons_differential_biomarkers_hypergo, file = paste(R_processing_results_dir, "list_DExpSeq_intercluster_comparisons_differential_biomarkers_hypergo.Rlist", sep = ""), compress = FALSE)

# load(file = paste(R_processing_results_dir, "list_DExpSeq_intercluster_comparisons_differential_biomarkers_hypergo.Rlist", sep = ""))

```

### [zscore/maxmin] comparisons of distinct subtypes within clusters

```{r}

load(file = paste(R_processing_results_dir, "list_annotated_result_differential_comparisons_within_clusters.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 10),
          tweak(multiprocess, workers = 3)))

# annotate the comparison results here and save it.
list_differential_comparisons_within_clusters_hypergo <- furrr::future_map2(
  .x = list_annotated_result_differential_comparisons_within_clusters,
  .y = list_annotated_result_differential_comparisons_within_clusters %>% names,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_differential_comparisons_within_clusters[["12"]]
    # a2 <- list_annotated_result_differential_comparisons_within_clusters %>% names %>% .[1]
    ###########
    
    list_hypergo_results <- furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        # merge all differentially spliced LISs together 
        dt_merged_annotated_tables <- b1 %>% rbindlist
        
        if (dt_merged_annotated_tables$matched_gene_names %>% length > 0) {
          
          tibble_hypergo_result <- furrr::future_map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = dt_merged_annotated_tables$matched_gene_names %>% unique) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% as_tibble
          
        } else {
          
          tibble_hypergo_result <- tibble()
          
        }
        
        return(tibble_hypergo_result)
        
      } ) 
    
    return(list_hypergo_results)
    
  }, .progress = TRUE, .options = furrr_options(seed = 8) )

save(list_differential_comparisons_within_clusters_hypergo, file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_hypergo.Rlist", sep = ""), compress = FALSE)

# rbind and tibblise 
long_tibble_differential_comparisons_within_clusters_hypergo <- purrr::map2(
  .x = list_differential_comparisons_within_clusters_hypergo,
  .y = names(list_differential_comparisons_within_clusters_hypergo),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_differential_comparisons_within_clusters_hypergo[[1]]
    # a2 <- names(list_differential_comparisons_within_clusters_hypergo) %>% .[[1]]
    ###########
    
    purrr::map2(
      .x = a1,
      .y = names(a1),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% .[[1]]
        ###########
        
        b1 %>% 
          tibble::add_column(
            "comparison" = b2,
            "som_cluster" = a2
          ) %>%
          return
        
      } ) %>% rbindlist(fill = TRUE) %>% return
    
  } ) %>% rbindlist(fill = TRUE) %>% as_tibble
  
data.table::fwrite(x = long_tibble_differential_comparisons_within_clusters_hypergo, file = paste(R_processing_results_dir, "long_tibble_differential_comparisons_within_clusters_hypergo.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)












# plot

logical_replot <- FALSE

furrr::future_pmap(
  .l = list(
    "a1" = list_som_cluster_groupings_for_plot,
    "a2" = names(list_som_cluster_groupings_for_plot),
    "a3" = list_cherrypicked_goterms
  ),
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_som_cluster_groupings_for_plot[[1]]
    # a2 <- names(list_som_cluster_groupings_for_plot) %>% .[[1]]
    # a3 <- list_cherrypicked_goterms[[1]]
    ###########
    
    ## rbind and tibblise the gene ontology results (it's only ~80 tables)
    ## these will be used to ggplot. 
    long_tibble_characteristic_markers_for_each_group_hypergo_plot <- purrr::map2(
      .x = list_characteristic_markers_for_each_group_hypergo,
      .y = names(list_characteristic_markers_for_each_group_hypergo),
      .f = ~.x %>% dplyr::filter(`NodeSize` < 1000 & `Padj` < 0.05) %>% .[, c("Term", "Padj")] %>% tibble::add_column("group_name" = .y)) %>%
      .[names(list_characteristic_markers_for_each_group_hypergo) %>% grep(pattern = a1)] %>%
      rbindlist %>% as_tibble
    
    if (logical_replot == TRUE) {
      
      long_tibble_characteristic_markers_for_each_group_hypergo_plot <- long_tibble_characteristic_markers_for_each_group_hypergo_plot[long_tibble_characteristic_markers_for_each_group_hypergo_plot$Term %in% a3, ]
      
    }
    
    # melt the table of GOterms per timepoint into separate columns for timepoints
    wide_tibble_hyperGO_per_timepoint <- reshape2::dcast(data = long_tibble_characteristic_markers_for_each_group_hypergo_plot,
                                                         formula = Term ~ group_name, value.var = "Padj") %>% as_tibble
    
    wide_tibble_hyperGO_per_timepoint[is.na(wide_tibble_hyperGO_per_timepoint)] <- 1
    
    # remove GO Terms which are not sig in at least one timepoint.
    ## vector of row indices where it's significant in at least one timepoint.
    # vec_row_indices_anysig <- wide_tibble_hyperGO_per_timepoint[, colnames(wide_tibble_hyperGO_per_timepoint) %>% .[colnames(wide_tibble_hyperGO_per_timepoint) != "Term"]] %>% array_tree %>% purrr::map(.f = ~any(.x <= 0.05)) %>% unlist %>% which(. == TRUE)
    # wide_tibble_hyperGO_per_timepoint <- wide_tibble_hyperGO_per_timepoint[vec_row_indices_anysig, ]
    
    # sort the GO terms (y-axis)
    y_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% as.matrix, method = "euclidean", threads = 32)
    y_hclust_result <- fastcluster::hclust(y_dist_result, method = "ward.D2")
    y_dendrogram <- as.dendrogram(y_hclust_result)
    
    y_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% t) %>% .[["rotation"]] %>% .[, 1]
    y_dendrogram_reordered <- reorder(y_dendrogram, y_matrix_PCA1_rowwise)
    
    # sort the group_names (x-axis)
    x_dist_result <- parallelDist::parDist(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% as.matrix %>% t, method = "euclidean", threads = 32)
    x_hclust_result <- fastcluster::hclust(x_dist_result, method = "ward.D2")
    x_dendrogram <- as.dendrogram(x_hclust_result)
    
    x_matrix_PCA1_rowwise <- prcomp(wide_tibble_hyperGO_per_timepoint %>% dplyr::select(-Term) %>% t) %>% .[["rotation"]] %>% .[, 1]
    x_dendrogram_reordered <- reorder(x_dendrogram, x_matrix_PCA1_rowwise)
    
    tibble_reordered <- wide_tibble_hyperGO_per_timepoint[y_dendrogram_reordered %>% unlist, c("Term", colnames(wide_tibble_hyperGO_per_timepoint) %>% .[(x_dendrogram_reordered %>% unlist + 1)])]
    
    # get the order due to the clustering
    vector_y_ordered <- tibble_reordered$Term
    vector_x_ordered <- tibble_reordered %>% dplyr::select(-Term) %>% colnames
    
    # melt for ggplot 
    # long_tibble_reordered <- reshape2::melt(tibble_reordered, variable.name = "group_name", value.name = "Padj", id.vars = c("Term")) %>% as_tibble
    
    # plot the main bulk RNA-Seq heatmap
    ggplot(long_tibble_characteristic_markers_for_each_group_hypergo_plot, aes(fill = -log10(Padj))) +
      geom_tile(aes(x = group_name, y = Term)) +
      ggtitle(paste("Heatmap of any significant GOterms per cluster/chucked out group ", a2, sep = "")) +
      scale_x_discrete(breaks = vector_x_ordered, labels = vector_x_ordered, limits = vector_x_ordered) +
      scale_y_discrete(breaks = vector_y_ordered[seq(from = 1, to = length(vector_y_ordered), by = 1)], labels = vector_y_ordered[seq(from = 1, to = length(vector_y_ordered), by = 1)] %>% str_trunc(width = 50, side = "center", ellipsis = "..."), limits = vector_y_ordered) +
      scale_fill_gradient2(low = "orange", mid = "brown", high = "black", na.value = "grey", midpoint = 25) +
      # scale_fill_gradientn(colours = c(yellow", "red", "black"), values = c(1.3, 0.6, 0.5, 0), na.value = "grey") + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = if (logical_replot == TRUE) {10} else {12}, lineheight = 0.75, colour = "black", margin = margin(r = 10)), legend.title.align = 0.5, axis.text.y = element_text(size = if (logical_replot == TRUE) {10} else {0.5}, lineheight = 0.75, colour = "black"), axis.title.y = element_text(margin = margin(r = 10)), text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(R_processing_results_dir, "list_characteristic_markers_for_each_group_hypergo_heatmap_", a2, if (logical_replot == TRUE) {"_replot"}, ".pdf", sep = ""), device = "pdf", dpi = 600, width = if (logical_replot == TRUE) {15} else {40}, height = if (logical_replot == TRUE) {15} else {40}, units = "cm", limitsize = FALSE)
    
  }, .progress = TRUE)


```

### [zscore/maxmin] comparisons of different subtypes of samples between clusters

```{r}

load(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_list_annotated_result_sample_subtypes_between_clusters.Rlist", sep = ""))

# merge positive negative markers
list_annotated_result_sample_subtypes_between_clusters_combined_positive_negative_markers <- purrr::map(
  .x = list_annotated_result_sample_subtypes_between_clusters,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_sample_subtypes_between_clusters[[1]]
    ###########
    
    list_L2_combined_positive_negative_markers <- purrr::map2(
      .x = a1$list_LIV_row_indices_positive_markers_for_each_sample,
      .y = a1$list_LIV_row_indices_negative_markers_for_each_sample,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1$list_LIV_row_indices_positive_markers_for_each_sample %>% .[[1]]
        # b2 <- a1$list_LIV_row_indices_negative_markers_for_each_sample %>% .[[1]]
        ###########
        
        return(dplyr::bind_rows(b1, b2))
        
      } )
    
    return(list_L2_combined_positive_negative_markers)
    
  } )

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 12)))

# GO enrichment for combined positive negative markers
tibble_sample_subtypes_between_clusters_hypergo_combined_positive_negative_markers <- furrr::future_map2(
  .x = list_annotated_result_sample_subtypes_between_clusters_combined_positive_negative_markers,
  .y = names(list_annotated_result_sample_subtypes_between_clusters_combined_positive_negative_markers),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_sample_subtypes_between_clusters_combined_positive_negative_markers[[1]]
    # a2 <- names(list_annotated_result_sample_subtypes_between_clusters_combined_positive_negative_markers) %>% .[[1]]
    ###########
    
    cat(a2, "\n")
    
    list_cell_tissue_type_result_annotated <- furrr::future_map2(
      .x = a1,
      .y = names(a1),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[9]]
        # b2 <- names(a1) %>% .[[9]]
        ###########
        
        cat(b2, "\n")
        
        if (b1$matched_gene_names %>% length > 0) {
          
          tibble_hypergo_result <- purrr::map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = b1$matched_gene_names %>% unique) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% tibble::add_column("cluster" = b2)
          
        } else {
          
          tibble_hypergo_result <- tibble()
          
        }
        
        return(tibble_hypergo_result)
        
      } ) %>% rbindlist(fill = TRUE) %>% tibble::add_column("sample_name" = a2) %>% return
    
  } ) %>% rbindlist(fill = TRUE) %>% as_tibble

save(tibble_sample_subtypes_between_clusters_hypergo_combined_positive_negative_markers, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_sample_subtypes_between_clusters_hypergo_combined_positive_negative_markers.tibble", sep = ""), compress = FALSE)

data.table::fwrite(x = tibble_sample_subtypes_between_clusters_hypergo_combined_positive_negative_markers, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_sample_subtypes_between_clusters_hypergo_combined_positive_negative_markers.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

# GO enrichment for separated positive negative markers
tibble_sample_subtypes_between_clusters_hypergo_separated_positive_negative_markers <- furrr::future_map2(
  .x = list_annotated_result_sample_subtypes_between_clusters,
  .y = names(list_annotated_result_sample_subtypes_between_clusters),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_sample_subtypes_between_clusters[[1]]
    # a2 <- names(list_annotated_result_sample_subtypes_between_clusters) %>% .[[1]]
    ###########
    
    list_positive_negative_markers_result <- purrr::map2(
      .x = a1,
      .y = names(a1) %>% gsub(pattern = "list_LIV_row_indices_(.*)s_for_each_sample", replacement = "\\1"),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% gsub(pattern = "list_LIV_row_indices_(.*)s_for_each_sample", replacement = "\\1") %>% .[[1]]
        ###########
        
        list_cell_tissue_type_result_annotated <- furrr::future_map2(
          .x = b1,
          .y = names(b1),
          .f = function(c1, c2) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            # c2 <- names(b1) %>% .[[1]]
            ###########
            
            if (c1$matched_gene_names %>% length > 0) {
              
              tibble_hypergo_result <- purrr::map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = c1$matched_gene_names %>% unique) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% tibble::add_column("cluster" = c2)
              
            } else {
              
              tibble_hypergo_result <- tibble()
              
            }
            
            return(tibble_hypergo_result)
            
          } ) %>% rbindlist %>% tibble::add_column("positive_or_negative_marker" = b2) %>% return
        
      } ) %>% rbindlist %>% tibble::add_column("sample_name" = a2) %>% return
    
  }, .progress = TRUE ) %>% rbindlist %>% as_tibble

save(tibble_sample_subtypes_between_clusters_hypergo_separated_positive_negative_markers, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_sample_subtypes_between_clusters_hypergo_separated_positive_negative_markers.tibble", sep = ""), compress = FALSE)

data.table::fwrite(x = tibble_sample_subtypes_between_clusters_hypergo_separated_positive_negative_markers, file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_sample_subtypes_between_clusters_hypergo_separated_positive_negative_markers.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)

```

## Transcript and (predicted) protein ontology

- match to BioMart and dbPTM -> due to the size of the data, we're just going to use the rows that were differentially spliced. 
- and THEN summarise the results of BioMart and dbPTM.

### import annotations

```{r}

# THE DATA ###
load(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_pooled_replicates.tibble", sep = ""))

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

# fetch the LIS data
tibble_LIS_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, c("database_id", "aes_id", "exon_number", "event_region", "LIV_exon_coords", "psisigma_gene_symbol", "alternative_exon_coords", "splicemode", "psisigma_nmd", "psisigma_reference_transcript")]

tibble_merged_non_IR_and_IR_annotations_summarised <- read.delim(file = paste(R_processing_results_dir, "tibble_merged_non_IR_and_IR_annotations_summarised.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

# Ensembl ENSP to uniprot entry ID mapping ###
tibble_ENSP_to_uniprotkb <- read.delim(file = paste(shared_dir, "table_ENSP_to_uniprot_entry_mapping_38.98.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% as_tibble

# non-homolog and non-(super)family entries from interpro
tibble_non_family_interpro_entries <- c("interpro_active.site_entries.tsv", "interpro_binding.site_entries.tsv", "interpro_conserved.site_entries.tsv", "interpro_domain_entries.tsv", "interpro_PTM_entries.tsv", "interpro_repeat_entries.tsv") %>% 
  purrr::map(.f = ~read.delim(paste(shared_dir, .x, sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble) %>% rbindlist %>% as_tibble

# IMPORT GTF ANNOTATION OF TRANSCRIPT/EXON/PROTEIN CODING REGIONS ETC... ###
tibble_ref_gtf_original <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique
colnames(tibble_ref_gtf_original) <- c("seqnames", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 
tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# BIOMART ###
# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(shared_dir, "table_biomart_ENSP_to_", .x, "_38.98.txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

# import dbPTM info ###
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", check.names = FALSE, na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info ###
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES ###
# tibble_PTM_combined <- dplyr::bind_rows(tibble_dbPTM_allhuman_annotations, tibble_phosphositeplus_allhuman_phosphosites)
tibble_PTM_combined <- tibble_dbPTM_allhuman_annotations

```

### Match ALL LIVs to BioMart and dbPTM

```{r}

query_name <- "totalrna_all"
intron_retention_string <- "IR"

# get matched gene names and poison exon finder annotation
tibble_alternative_exon_table <- dplyr::left_join(tibble_LIS_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering, tibble_merged_non_IR_and_IR_annotations_summarised)

# identifier table
# chr start end strand table
vector_chr <- gsub(x = tibble_alternative_exon_table$event_region, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\1")
vector_VSR_start <- purrr::map2(.x = gsub(x = tibble_alternative_exon_table$event_region, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2") %>% type.convert(as.is = TRUE),
                                .y = gsub(x = tibble_alternative_exon_table$event_region, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3") %>% type.convert(as.is = TRUE),
                                .f = ~min(.x, .y)) %>% unlist
vector_VSR_end <- purrr::map2(.x = gsub(x = tibble_alternative_exon_table$event_region, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2") %>% type.convert(as.is = TRUE),
                              .y = gsub(x = tibble_alternative_exon_table$event_region, pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3") %>% type.convert(as.is = TRUE),
                              .f = ~max(.x, .y)) %>% unlist

plan(multiprocess)
options(mc.cores = 16)

vector_alt_segment_starts <- tibble_alternative_exon_table$LIV_exon_coords %>% strsplit(split = "\\;") %>% furrr::future_map(~.x %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\2"), .progress = TRUE)
vector_alt_segment_ends <- tibble_alternative_exon_table$LIV_exon_coords %>% strsplit(split = "\\;") %>% furrr::future_map(~.x %>% unlist %>% gsub(pattern = "^([^\\:]+)\\:([^\\-]+)\\-(\\d+)", replacement = "\\3"), .progress = TRUE)

tibble_alternative_exons_chr_start_end_strand <- tibble(
  "event_region" = tibble_alternative_exon_table$event_region,
  "LIV_exon_coords" = tibble_alternative_exon_table$LIV_exon_coords,
  "splicemode" = tibble_alternative_exon_table$splicemode,
  "matched_gene_names" = tibble_alternative_exon_table$matched_gene_names,
  "chr" = vector_chr,
  "strand" = "*",
  "vector_VSR_start" = vector_VSR_start,
  "vector_VSR_end" = vector_VSR_end,
  "vector_alt_segment_starts" = vector_alt_segment_starts,
  "vector_alt_segment_ends" = vector_alt_segment_ends) %>% unique

# subset the recon GTF and exon table by chromosomes in common so that we can map2 over them
## split exon table by chromosome
list_alternative_exons_by_chr <- tibble_alternative_exons_chr_start_end_strand %>% 
  dplyr::group_split(chr) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
## split GTF table by chromosome
list_ref_gtf_subset_by_chr <- tibble_ref_gtf_original %>% 
  dplyr::group_split(seqnames) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$seqnames %>% unique) %>% unlist)
## get and filter for only chromosomes in common
vector_chr_in_commmon <- intersect(names(list_ref_gtf_subset_by_chr), names(list_alternative_exons_by_chr))

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 3)))

cat("match VSRs to reference transcriptome\n")
list_ref_entries_matched_to_exons <- future_map2(
  .x = list_alternative_exons_by_chr[vector_chr_in_commmon],
  .y = list_ref_gtf_subset_by_chr[vector_chr_in_commmon],
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_alternative_exons_by_chr[[1]]
    # a2 <- list_ref_gtf_subset_by_chr[[1]]
    ##########
    
    cat(a1$chr %>% unique, "\n")
    
    plan(list(tweak(multiprocess, workers = 6),
              tweak(multiprocess, workers = 3)))
    
    list_per_chromosome <- future_imap(
      .x = a1 %>% array_tree,
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[5]]
        ###########
        
        cat(b2, "\n")
        
        # detect exon extension/skipping
        ## get vector of VSR and exon coords
        vector_VSR_exon_coords <- b1[c("vector_VSR_start", "vector_VSR_end", "vector_alt_segment_starts", "vector_alt_segment_ends")] %>% unlist %>% type.convert(as.is = TRUE)
        ## if no. of unique VSR + alt. exon coords = 4, then it's exon skipping. If 3, then partial exon extension.
        # IR EVENTS
        if (grepl(x = b1$splicemode, pattern = intron_retention_string) == TRUE) {
          
          # VSR MATCHING
          # match transcripts to the IR region
          list_matched_GTF_exon_entries <- extract_matching.exons(query_chr = b1$chr, query_start = b1$vector_VSR_start %>% type.convert(as.is = TRUE), query_end = b1$vector_VSR_end %>% type.convert(as.is = TRUE), query_strand = b1$strand, tibble_gtf_table = a2, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon") %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          # get parent transcript entries
          list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~a2[which(a2$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          
          # INEXACT MATCHING IF VSR MATCHING FAILS
          if (list_matched_GTF_exon_entries %>% length == 0) {
            list_GTF_entries_matched_to_IR_junction <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = b1$vector_alt_segment_starts %>% type.convert(as.is = TRUE), query_end = b1$vector_alt_segment_ends %>% type.convert(as.is = TRUE), query_strand = b1$strand, tibble_gtf_table = a2, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, match_consecutive = TRUE, return_type = "exon")
            # extract overlapping, same strand, (and maybe) same gene_name/gene_id transcripts.
            tibble_IR_junction_parent_transcript_entries <- a2[which(a2$transcript_id %in% names(list_GTF_entries_matched_to_IR_junction) &
                                                               a2$type == "transcript"), ]
            # get overlapping/samestrand/same gene_id transcript entries
            ## determine if it's called "gene_name" or "gene_id"
            tibble_gene_name <- a2 %>% head %>% dplyr::select(contains("gene_id"), contains("gene_name"))
            gene_name_or_gene_id <- colnames(tibble_gene_name[, 1])
            
            if (a2 %>% dplyr::select(contains("gene_id"), contains("gene_name")) %>% ncol != 0) {
              tibble_transcript_entries_overlapping_IR_junction_transcripts <- 
                a2[which(a2$type == "transcript" &
                     a2$start <= (tibble_IR_junction_parent_transcript_entries$end %>% max) &
                     a2$end >= (tibble_IR_junction_parent_transcript_entries$start %>% min) & 
                     a2$strand %in% (tibble_IR_junction_parent_transcript_entries$strand %>% unique) &
                     (a2[, gene_name_or_gene_id] %>% unlist) %in% (tibble_IR_junction_parent_transcript_entries[, gene_name_or_gene_id] %>% unlist)), ]
            } else if (a2 %>% dplyr::select(contains("gene_id"), contains("gene_name")) %>% ncol == 0) {
              tibble_transcript_entries_overlapping_IR_junction_transcripts <- 
                a2[which(a2$type == "transcript" &
                     a2$start <= (tibble_IR_junction_parent_transcript_entries$end %>% max) &
                     a2$end >= (tibble_IR_junction_parent_transcript_entries$start %>% min) & 
                     a2$strand %in% (tibble_IR_junction_parent_transcript_entries$strand %>% unique)), ]
            }
            
            # retrieve the full entries of overlapping transcripts
            tibble_all_candidate_overlapping_full_entries <- a2[which(a2$transcript_id %in% tibble_transcript_entries_overlapping_IR_junction_transcripts$transcript_id), ]
            
            # extract only transcripts with encapsulating exons. These are the final exon matches.
            list_matched_GTF_exon_entries <- 
              tibble_all_candidate_overlapping_full_entries[tibble_all_candidate_overlapping_full_entries$type == "exon" &
                                                         tibble_all_candidate_overlapping_full_entries$start <= b1$vector_alt_segment_starts %>% type.convert(as.is = TRUE) &
                                                         tibble_all_candidate_overlapping_full_entries$end >= b1$vector_alt_segment_ends %>% type.convert(as.is = TRUE), ] %>% 
              dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            # get parent transcript entries
            list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~tibble_all_candidate_overlapping_full_entries[which(tibble_all_candidate_overlapping_full_entries$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          }
          
          ### EXON SKIPPING
        } else if (vector_VSR_exon_coords %>% unique %>% length >= 4) {
          
          # exact match of each alternative exon to the reference GTF
          list_matched_GTF_exon_entries <- purrr::map2(.x = b1$vector_alt_segment_starts, .y = b1$vector_alt_segment_ends, .f = ~extract_matching.exons(query_chr = b1$chr, query_start = .x %>% type.convert(as.is = TRUE), query_end = .y %>% type.convert(as.is = TRUE), query_strand = b1$strand, tibble_gtf_table = a2, tolerance_left = 0, tolerance_right = 0, tolerance_inside = 0, tolerance_outside = 0, return_type = "exon"))
          
          if (list_matched_GTF_exon_entries %>% purrr::map(~.x %>% nrow > 0) %>% unlist %>% all == TRUE) {
            
            # only keep the ENST IDs that matched to all exons in the L.I.S
            vector_common_ENST_IDs <- list_matched_GTF_exon_entries %>% purrr::map(~.x$transcript_id) %>% purrr::reduce(intersect)
            
            # rbind, filter by common ENST IDs, list-ify by transcript_id
            list_matched_GTF_exon_entries <- list_matched_GTF_exon_entries %>% rbindlist %>% .[.$transcript_id %in% vector_common_ENST_IDs, ] %>% dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            
          }
          
          # get parent transcript entries
          list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~a2[which(a2$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          
          ### PARTIAL EXON EXTENSIONS
        } else if (vector_VSR_exon_coords %>% unique %>% length == 3) {
          
          # ENHANCED EXON EXTENSION MATCHING
          # Strategy: 
          # 1. Determine the common VSR and exon coord.
          # 2. Calculate the genomic coord of the DR + 1 nucleotide.
          # This is done using the equation: genome_coord_first_nucleotide_extending_into_common_region = common + (common_coord-VSR_only_coord)/(abs(common_coord-VSR_only_coord))
          # 3. Find the CONSTITUTIVE (native, non-extended) exon by requiring no overlap with the DR but has either the start or end coord = the DR + 1 nucleotide.
          # 4. The exonic matches are any exon which overlaps the region of the constitutive span AND contains the WHOLE DR on the same strand.
          common_coord <- intersect(c(b1$vector_VSR_start %>% type.convert(as.is = TRUE), b1$vector_VSR_end %>% type.convert(as.is = TRUE)), 
                                    c(b1$vector_alt_segment_starts %>% type.convert(as.is = TRUE), b1$vector_alt_segment_ends %>% type.convert(as.is = TRUE)))
          aes_id_only_coord <- setdiff(c(b1$vector_VSR_start %>% type.convert(as.is = TRUE), b1$vector_VSR_end %>% type.convert(as.is = TRUE)), common_coord)
          exon_only_coord <- setdiff(c(b1$vector_alt_segment_starts %>% type.convert(as.is = TRUE), b1$vector_alt_segment_ends %>% type.convert(as.is = TRUE)), common_coord)
          genome_coord_first_nucleotide_extending_into_common_region = common_coord + ((common_coord - aes_id_only_coord)/(abs(common_coord - aes_id_only_coord)))
          
          tibble_GTF_exons_with_DR_plus_one_nucleotide <- 
            a2[(which(a2$type == "exon" &
                        (a2$start == genome_coord_first_nucleotide_extending_into_common_region |
                           a2$end == genome_coord_first_nucleotide_extending_into_common_region))), ]
          # require no overlap with DR
          tibble_constitutive_exons <- 
            tibble_GTF_exons_with_DR_plus_one_nucleotide[!(tibble_GTF_exons_with_DR_plus_one_nucleotide$start <= max(common_coord, exon_only_coord) &
                                                             tibble_GTF_exons_with_DR_plus_one_nucleotide$end >= min(common_coord, exon_only_coord)), ]
          
          # find exons overlapping with the constitutive and containing the whole DR regions.
          list_matched_GTF_exon_entries <- 
            a2[which(a2$type == "exon" &
                       a2$strand %in% (tibble_constitutive_exons$strand %>% unique) &
                       # constitutive region overlap
                       a2$start <= max(tibble_constitutive_exons$start %>% max, tibble_constitutive_exons$end %>% max) &
                       a2$end >= min(tibble_constitutive_exons$start %>% min, tibble_constitutive_exons$end %>% min) &
                       # DR encapsulation
                       a2$start <= min(common_coord, exon_only_coord) &
                       a2$end >= max(common_coord, exon_only_coord)), ] %>%
            dplyr::group_split(transcript_id) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          
          # get parent transcript entries
          list_parent_GTF_transcript_entries <- purrr::map(.x = list_matched_GTF_exon_entries %>% names, .f = ~a2[which(a2$transcript_id == .x), ]) %>% set_names(list_matched_GTF_exon_entries %>% names)
          
        } # END CONDITIONS ###
        
        # rbind and tibblise the list_matched_GTF_exon_entries
        ref_matched_exons <- list_matched_GTF_exon_entries %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble
        
        # extract the matched transcript_ids
        vector_matched_transcript_ids <- ref_matched_exons$transcript_id %>% unique
        
        # GET STRAND ###
        list_matched_strand <- list_parent_GTF_transcript_entries %>% purrr::map(~.x$strand %>% unique)
        
        return(purrr::splice(
          b1,
          "ref_matched_exons" = ref_matched_exons %>% list,
          "vector_matched_transcript_ids" = vector_matched_transcript_ids %>% list,
          "list_parent_GTF_transcript_entries" = list_parent_GTF_transcript_entries %>% list,
          "matched_strand" = list_matched_strand %>% unlist %>% unique
        ))
        
      }, .progress = TRUE)
    
    # keep elements that didn't have any matches to GTF
    list_per_chromosome_unmatched <- list_per_chromosome %>% purrr::keep(.p = ~.x$ref_matched_exons %>% nrow == 0)
    # prune elements that didn't have any matches to GTF
    list_per_chromosome_pruned <- list_per_chromosome %>% purrr::discard(.p = ~.x$ref_matched_exons %>% nrow == 0)
    
    return(list("unmatched_list" = list_per_chromosome_unmatched,
                "pruned_list" = list_per_chromosome_pruned))
    
  }, .progress = TRUE)

# write the entries that didn't have any matches to the reference GTF.
tibble_ref_entries_matched_to_exons_unmatched <- list_ref_entries_matched_to_exons %>% purrr::map(~.x$unmatched_list) %>% flatten %>% purrr::map(~.x[c("event_region", "LIV_exon_coords", "splicemode", "chr", "strand", "vector_VSR_start", "vector_VSR_end", "vector_alt_segment_starts", "vector_alt_segment_ends")] %>% as_tibble) %>% rbindlist %>% as_tibble
# write
write.table(x = tibble_ref_entries_matched_to_exons_unmatched, file = paste(R_processing_results_dir, "table_exon_ontology_unmatched_exons_", query_name, ".txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# extract the pruned entries and flatten
list_ref_entries_matched_to_exons_pruned <- list_ref_entries_matched_to_exons %>% purrr::map(~.x$pruned_list) 
# %>% flatten

plan(list(tweak(multiprocess, workers = 28),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 3)))

# add the matched CDS from the exon number and transcript ids of matched exons
list_ref_entries_matched_to_exons.and.CDS <- furrr::future_map2(
  .x = list_ref_entries_matched_to_exons_pruned,
  .y = list_ref_gtf_subset_by_chr[names(list_ref_entries_matched_to_exons_pruned)],
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_ref_entries_matched_to_exons_pruned[[1]]
    ###########
    
    furrr::future_map(
      .x = a1,
      .f = ~purrr::splice(.x,
                          "ref_matched_CDS" = dplyr::semi_join(a2[a2$type == "CDS", ], .x$ref_matched_exons %>% .[, c("transcript_id", "exon_number")], by = c("transcript_id", "exon_number"))
      ) ) %>% 
      return
    
  }, .progress = TRUE ) 

# GENERATE GENOME-RELATIVE COORDS FOR EVERY DIFFERENTIAL POSITION.
# also generate genome-relative coords for every CDS position of transcripts with a matched exon. this is necessary because we need to deal with gaps.
list_genome_relative_exonic.and.CDS_coords <- furrr::future_map2(
  .x = list_ref_entries_matched_to_exons.and.CDS,
  .y = list_ref_gtf_subset_by_chr[names(list_ref_entries_matched_to_exons.and.CDS)],
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_ref_entries_matched_to_exons.and.CDS[[1]]
    ###########
    
    future_imap(
      .x = a1, 
      .f = function(b1, b2) {
        
        # DEBUG ###
        # purrr::map(.x = a1, .f = ~.x$LIV_exon_coords == "1:10433842-10433965;1:10434657-10434690") %>% unlist %>% which
        # b1 <- a1[[82]]
        ###########
        
        # cat("\nprocessing entry number: ", a2)
        
        # retrieve the genomic coords of the differential exonic region (just start:end)
        vector_genomic_coords_of_all_differential_exon_positions <- purrr::map2(.x = b1$vector_alt_segment_starts, .y = b1$vector_alt_segment_ends, .f = ~(.x %>% type.convert(as.is = TRUE)):(.y %>% type.convert(as.is = TRUE))) %>% unlist %>% unique %>% sort
        
        # find the overlapping features from the parent transcripts (from the matched exons)
        ## get parent transcript entries
        tibble_parent_transcript_entries <- dplyr::semi_join(a2, b1$ref_matched_exons, by = "transcript_id")
        ## find overlapping features
        tibble_overlapping_parent_transcript_features <- tibble_parent_transcript_entries[purrr::map2(.x = tibble_parent_transcript_entries$start, .y = tibble_parent_transcript_entries$end, .f = ~intersect(.x:.y, vector_genomic_coords_of_all_differential_exon_positions) %>% length > 0) %>% unlist %>% which, ]
        
        # retrieve the genomic coords of the differential CDS region
        ## we have to intersect each (genome-relative) CDS region with the genomic coords of differential exon positions
        ## list-ify the matched CDS entries by transcript_id
        list_matched_CDS_by_transcript_id <- b1$ref_matched_CDS %>% 
          dplyr::group_split(transcript_id) %>% 
          set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
        ## list out all the positions for each CDS entry and intersect with the differential exon's positions
        list_all_genome_relative_matched_CDS_positions <- purrr::map(
          .x = list_matched_CDS_by_transcript_id,
          .f = ~purrr::map2(.x = .x$start, .y = .x$end, .f = ~.x:.y) %>% unlist)
        ## intersect for differential CDS positions
        list_differential_CDS_positions <- purrr::map(.x = list_all_genome_relative_matched_CDS_positions, .f = ~intersect(.x, vector_genomic_coords_of_all_differential_exon_positions))
        
        return(splice(
          b1,
          "vector_genomic_coords_of_all_differential_exon_positions" = vector_genomic_coords_of_all_differential_exon_positions %>% list,
          "tibble_overlapping_parent_transcript_features" = tibble_overlapping_parent_transcript_features %>% list,
          "list_differential_CDS_positions" = list_differential_CDS_positions %>% list
        ))
        
      } ) %>%
      
      # drop exons that don't have any differential regions.
      purrr::discard(.x = ., .p = ~(nrow(.x$ref_matched_exons) == 0)) %>% 
      return
    
  }, .progress = TRUE )

# CALCULATE THE PROTEIN-RELATIVE COORDS FROM GENOME-RELATIVE DIFFERENTIAL CDS POSITIONS
list_protein_relative_differential_coords <- furrr::future_pmap(
  .l = list(
    "a1" = list_genome_relative_exonic.and.CDS_coords,
    "a2" = list_ref_gtf_subset_by_chr[names(list_genome_relative_exonic.and.CDS_coords)],
    "a3" = names(list_genome_relative_exonic.and.CDS_coords)
    ),
  .f = function(a1, a2, a3) {
    
    # DEBUG ###
    # a1 <- list_genome_relative_exonic.and.CDS_coords[[1]]
    # a2 <- list_ref_gtf_subset_by_chr[names(list_genome_relative_exonic.and.CDS_coords)] %>% .[[1]]
    # a3 <- names(list_genome_relative_exonic.and.CDS_coords) %>% .[[1]]
    ###########
    
    # cat(a3, "\n")
    
    future_imap(
      .x = a1, 
      .f = function(b1, b2) {
        
        # cat(b2, "\n")
        
        # DEBUG ###
        # purrr::map(.x = a1, .f = ~.x$LIV_exon_coords == "1:10433842-10433965;1:10434657-10434690") %>% unlist %>% which
        # b1 <- a1[[82]]
        ###########
        
        # get current strand - this is necessary for getting CDS-relative coords.
        current_strand <- b1$ref_matched_exons$strand %>% unique
        
        # retrieve all the genome-relative positions of the parent CDS
        # NOTE: CDS might not always be available. we account for this.
        if (b1$ref_matched_CDS %>% nrow != 0) {
          
          list_vector_genome_relative_coords_parent_CDS <- purrr::map(
            .x = b1$ref_matched_CDS$transcript_id %>% unique,
            .f = function(c1) {
              
              # DEBUG ###
              # c1 <- b1$ref_matched_CDS$transcript_id %>% .[[1]]
              ###########
              
              tibble_ref_gtf_matching_transcript_id <- a2[a2$transcript_id == c1 & a2$type == "CDS", ]
              # create genome-relative positions
              vector_genome_relative_positions <- purrr::map2(.x = tibble_ref_gtf_matching_transcript_id$start,
                                                              .y = tibble_ref_gtf_matching_transcript_id$end,
                                                              .f = ~.x:.y) %>% unlist %>% unique %>% sort(decreasing = FALSE)
              return(vector_genome_relative_positions)
            } ) %>% set_names(b1$ref_matched_CDS$transcript_id %>% unique)
          
          # rename the list_differential_CDS_positions to be the same order as the list_vector_CDS_relative_coords
          b1$list_differential_CDS_positions <- b1$list_differential_CDS_positions[list_vector_genome_relative_coords_parent_CDS %>% names]
          
          # calculate CDS-relative diff CDS coords
          list_vector_CDS_relative_coords <- purrr::map2(.x = b1$list_differential_CDS_positions,
                                                         .y = list_vector_genome_relative_coords_parent_CDS,
                                                         .f = function(c1, c2) {
                                                           
                                                           if (current_strand == "+") {
                                                             which(c2 %in% c1) %>% return 
                                                           } else if (current_strand == "-") {
                                                             which((c2 %>% rev) %in% c1) %>% return 
                                                           }
                                                           
                                                         } ) 
          
          # get protein_id for later on
          vector_protein_ids <- names(list_vector_CDS_relative_coords) %>% purrr::map(.f = ~b1$ref_matched_CDS %>% dplyr::filter(transcript_id == .x) %>% .$protein_id %>% unique) %>% unlist
          
          # convert ENST IDs of list_vector_CDS_relative_coords to ENSP
          names(list_vector_CDS_relative_coords) <- vector_protein_ids
          
          # name list_differential_CDS_positions to have protein ids as well
          names(b1$list_differential_CDS_positions) <- vector_protein_ids
          
          # finally get the protein-relative coords.
          # protein-relative coords are simply the ceiling of a third of the transcript-relative coords
          protein_relative_differential_coords <- purrr::map(.x = list_vector_CDS_relative_coords,
                                                             .f = ~ceiling(.x / 3) %>% unlist %>% unique)
          
        } else {
          
          protein_relative_differential_coords <- NULL
          
        }
        
        return(splice(
          b1,
          "protein_relative_differential_coords" = protein_relative_differential_coords %>% list
        ))
        
      } ) %>% 
      return
    
  }, .progress = TRUE )

plan(list(tweak(multiprocess, workers = 33),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 3)))

# MATCH THE DIFFERENTIAL TRANSCRIPT-RELATIVE COORDS TO THE ENSEMBL GTF
# MATCH THE DIFFERENTIAL PROTEIN-RELATIVE COORDS TO THE FETCHED BIOMART LIST AS WELL AS THE PTMS
suppressMessages(
  list_matched_annotation <- future_map(
    .x = list_protein_relative_differential_coords %>% flatten, 
    .f = function(a1) {
      
      # WARNING!! FIX THIS WHEN NAMING THE FUNCTION!
      # list_of_tibbles_biomart_domain_annotation <<- list_of_tibbles_biomart_domain_annotation
      
      # tibble_ENSP_to_uniprotkb <<- tibble_ENSP_to_uniprotkb
      # tibble_PTM_combined <<- tibble_PTM_combined
      # tibble_ref_gtf_original <<- tibble_ref_gtf_original
      ############################################
      
      # DEBUG ###
      # a1 <- list_protein_relative_differential_coords %>% flatten %>% .[[158267]]
      ###########
      
      list_biomart_annotations <- purrr::map2(
        .x = a1$protein_relative_differential_coords, 
        .y = names(a1$protein_relative_differential_coords), .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- a1$protein_relative_differential_coords %>% .[[1]]
          # b2 <- names(a1$protein_relative_differential_coords) %>% .[1]
          ###########
          
          CDS.relative.coords <- b1
          protein.id <- b2
          
          # find domains which overlapped with the differential positions at the protein-relative level
          list_matched_biomart_annotations <- purrr::map2(.x = list_of_tibbles_biomart_domain_annotation, 
                                                          .y = names(list_of_tibbles_biomart_domain_annotation),
                                                          .f = function(c1, c2) {
                                                            
                                                            # DEBUG ###
                                                            # c1 <- list_of_tibbles_biomart_domain_annotation[[5]]
                                                            # c2 <- names(list_of_tibbles_biomart_domain_annotation) %>% .[[5]]
                                                            ###########
                                                            
                                                            tibble_domain_subset <- c1[c1$ensembl_peptide_id == protein.id, ]
                                                            
                                                            if (nrow(tibble_domain_subset) != 0) {
                                                              
                                                              # test matched_domain_entriesfor which differential positions lie between a domain
                                                              
                                                              row.indices_of_overlaps_with_differential_positions <- which(purrr::map2(
                                                                .x = tibble_domain_subset$start, 
                                                                .y = tibble_domain_subset$end, 
                                                                .f = ~any(.x < CDS.relative.coords &
                                                                            .y > CDS.relative.coords)) %>% unlist)
                                                              
                                                              # extract matched GTF entries
                                                              tibble_matched_domain_entries <- tibble_domain_subset[row.indices_of_overlaps_with_differential_positions, ]
                                                              
                                                            } else if (nrow(tibble_domain_subset) == 0) {
                                                              
                                                              tibble_matched_domain_entries <- tibble_domain_subset
                                                              
                                                            }
                                                            
                                                            # calculate the degree of overlap
                                                            tibble_matched_domain_entries <- tibble_matched_domain_entries %>% dplyr::mutate("percentage_overlap" = purrr::map2(.x = tibble_matched_domain_entries$start, .y = tibble_matched_domain_entries$end, .f = function(a1, a2) {(intersect(a1:a2, CDS.relative.coords) %>% length)/((a1:a2) %>% length)} ) %>% unlist)
                                                            
                                                            # rename the columns back to being domain-type specific
                                                            colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "start", replacement = paste(c2, "_", "start", sep = ""))
                                                            colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "end", replacement = paste(c2, "_", "end", sep = ""))
                                                            colnames(tibble_matched_domain_entries) <- gsub(x = colnames(tibble_matched_domain_entries), pattern = "percentage_overlap", replacement = paste(c2, "_", "percentage_overlap", sep = ""))
                                                            
                                                            return(tibble_matched_domain_entries)
                                                            
                                                          } )
          
          # reduce into tibble by full join
          tibble_matched_biomart_annotations <- list_matched_biomart_annotations %>% purrr::reduce(dplyr::full_join)
          
          return(tibble_matched_biomart_annotations)
          
        } )
      
      list_PTM_annotations <- purrr::map2(
        .x = a1$protein_relative_differential_coords, 
        .y = names(a1$protein_relative_differential_coords), .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- a1$protein_relative_differential_coords %>% .[[1]]
          # b2 <- names(a1$protein_relative_differential_coords) %>% .[1]
          ###########
          
          tibble_uniprotkb_entries_from_ENSP <- tibble_ENSP_to_uniprotkb[tibble_ENSP_to_uniprotkb$ensembl_peptide_id == b2, ]
          
          tibble_combined_PTM_matching_entries <- tibble_uniprotkb_entries_from_ENSP %>% dplyr::left_join(., tibble_PTM_combined, by = "uniprotkb_entry") %>%
            
            .[.$modified_residue_position %in% b1, ]
          
          return(tibble_combined_PTM_matching_entries)
          
        } )
      
      return(purrr::splice(
        a1,
        "biomart_annotations" = list_biomart_annotations %>% rbindlist(fill = TRUE) %>% as_tibble %>% list,
        "PTMs" = list_PTM_annotations %>% rbindlist(fill = TRUE) %>% as_tibble %>% list
      ))
      
    }, .progress = TRUE)
)

# save the raw list
save(list_matched_annotation, file = paste(R_processing_results_dir, "list_matched_annotation.Rlist", sep = ""), compress = FALSE)
# load(file = paste(R_processing_results_dir, "list_matched_annotation.Rlist", sep = ""))

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 3)))

# TIDY AND WRAP UP ALL THE ANNOTATIONS.
# prepare for export
list_tidied_annotation <- list_matched_annotation %>% 
  furrr::future_map(.f = ~
                      # concatenate all bare vectors 
                      modify_at(.x, .at = "vector_genomic_coords_of_all_differential_exon_positions", .f = ~.x %>% paste(collapse = ",")) %>%
                      modify_at(.x, .at = "matched_strand", .f = ~.x %>% paste(collapse = ";")) %>%
                      modify_at(.x, .at = "vector_matched_transcript_ids", .f = ~.x %>% paste(collapse = ",")) %>%
                      modify_at(.x, .at = c("list_differential_CDS_positions", "protein_relative_differential_coords"), .f = ~purrr::map(.x = .x, .f = ~.x %>% paste(collapse = ","))) %>%
                      # extract just the type and transcript_biotype from the overlapping parent transcript features
                      modify_at(.x, .at = "tibble_overlapping_parent_transcript_features", .f = ~.x[, c("type", "transcript_biotype")] %>% unlist %>% unique %>% sort %>% paste(collapse = ",")), .progress = TRUE)

# extract the transcript features and tibblise 
tibble_final_transcript_feature_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("event_region", "LIV_exon_coords", "splicemode", "matched_gene_names", "vector_matched_transcript_ids", "tibble_overlapping_parent_transcript_features")] %>% as_tibble) %>%
  rbindlist %>% 
  as_tibble %>%
  setNames(c("event_region", "LIV_exon_coords", "splicemode", "matched_gene_names", "vector_matched_transcript_ids", "tibble_overlapping_parent_transcript_features"))
# write table
write.table(x = tibble_final_transcript_feature_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_transcript_features_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_final_transcript_feature_annotation, file = paste(R_processing_results_dir, "tibble_final_transcript_feature_annotation.tibble", sep = ""), compress = FALSE)

plan(list(tweak(multiprocess, workers = 24),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 3)))

# extract the biomart results and tibblise 
tibble_final_biomart_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("event_region", "LIV_exon_coords", "splicemode", "matched_gene_names", "biomart_annotations")] ) %>%
  purrr::discard(.p = ~.x$biomart_annotations %>% nrow == 0) %>%
  furrr::future_map(~purrr::modify_at(.x = .x, .at = "biomart_annotations", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble, .progress = TRUE) %>%
  rbindlist(fill = TRUE) %>% 
  type_convert %>%
  as_tibble %>% 
  dplyr::group_split(ensembl_peptide_id) %>%
  furrr::future_map(~.x %>% unique, .progress = TRUE) %>% 
  rbindlist %>%
  as_tibble
# write table
write.table(x = tibble_final_biomart_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_biomart_domains_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_final_biomart_annotation, file = paste(R_processing_results_dir, "tibble_final_biomart_annotation.tibble", sep = ""), compress = FALSE)

# extract the PTM results and tibblise 
tibble_final_PTM_annotation <- list_tidied_annotation %>% purrr::map(~.x[c("event_region", "LIV_exon_coords", "splicemode", "matched_gene_names", "PTMs")] ) %>%
  purrr::discard(.p = ~.x$PTMs %>% nrow == 0) %>%
  furrr::future_map(~purrr::modify_at(.x = .x, .at = "PTMs", .f = ~array_tree(.x, margin = 2)) %>% flatten %>% as_tibble, .progress = TRUE) %>%
  rbindlist %>% 
  dplyr::group_split(ensembl_peptide_id) %>%
  furrr::future_map(~.x %>% unique, .progress = TRUE) %>% 
  rbindlist %>% 
  as_tibble 
# write table
write.table(x = tibble_final_PTM_annotation, file = paste(R_processing_results_dir, "table_exon_ontology_matched_PTMs_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_final_PTM_annotation, file = paste(R_processing_results_dir, "tibble_final_PTM_annotation.tibble", sep = ""), compress = FALSE)

# extract the other supporting information and tibblise
tibble_final_annotation_supp <- list_tidied_annotation %>% 
  furrr::future_map(~.x[c("event_region", "LIV_exon_coords", "splicemode", "matched_gene_names", "vector_genomic_coords_of_all_differential_exon_positions", "list_differential_CDS_positions", "vector_matched_transcript_ids", "protein_relative_differential_coords")], .progress = TRUE) %>%
  furrr::future_map_if(.p = ~.x$protein_relative_differential_coords %>% length != 0, .f = ~.x %>% (function(x) {
    purrr::splice(x, 
                  "tibble" = x[c("protein_relative_differential_coords", "list_differential_CDS_positions")] %>% purrr::map_depth(.depth = 2, .f = ~paste(.x, collapse = ",")) %>% purrr::map2(.x = ., .y = names(.), .f = ~.x %>% as_tibble %>% t %>% as_tibble(rownames = "ensembl_peptide_id") %>% setNames(c("ensembl_peptide_id", .y))) %>% purrr::reduce(dplyr::full_join, by = "ensembl_peptide_id")) %>% return}), .progress = TRUE ) %>%
  furrr::future_map_if(.p = ~.x$protein_relative_differential_coords %>% length == 0, .f = ~purrr::modify_at(.x = .x, .at = "protein_relative_differential_coords", .f = function(.x) {return("NA")} ) %>% splice("ensembl_peptide_id" = "NA"), .progress = TRUE) %>%
  furrr::future_map(.f = ~.x[-which(names(.x) %in% c("protein_relative_differential_coords", "list_differential_CDS_positions"))], .progress = TRUE) %>%
  furrr::future_map(~.x %>% flatten %>% as_tibble, .progress = TRUE) %>%
  purrr::discard(.p = ~.x %>% nrow == 0) %>% rbindlist(use.names = TRUE, fill = TRUE) %>% 
  dplyr::group_split(ensembl_peptide_id) %>%
  furrr::future_map(~.x %>% unique, .progress = TRUE) %>% 
  rbindlist %>%
  as_tibble
# write table
write.table(x = tibble_final_annotation_supp, file = paste(R_processing_results_dir, "table_exon_ontology_supporting_info_", query_name, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_final_annotation_supp, file = paste(R_processing_results_dir, "tibble_final_annotation_supp.tibble", sep = ""), compress = FALSE)
  
```

### Match the transcript and protein ontology to DS items

#### Characteristic markers for each cluster

```{r}

load(file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_group_annotated.Rlist", sep = ""))

load(file = paste(R_processing_results_dir, "tibble_final_transcript_feature_annotation.tibble", sep = ""))
load(file = paste(R_processing_results_dir, "tibble_final_biomart_annotation.tibble", sep = ""))
load(file = paste(R_processing_results_dir, "tibble_final_PTM_annotation.tibble", sep = ""))

plan(list(tweak(multiprocess, workers = 36),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 3)))

list_characteristic_markers_for_each_cluster_transcript_ontology <- furrr::future_map2(
  .x = list_characteristic_markers_for_each_group_annotated,
  .y = names(list_characteristic_markers_for_each_group_annotated),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_characteristic_markers_for_each_group_annotated[[1]]
    # a2 <- names(list_characteristic_markers_for_each_group_annotated) %>% .[[1]]
    ###########
    
    furrr::future_map(
      .x = a1,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        ###########
        
        return(
          list(
            "transcript_ontology" = dplyr::left_join(b1[, c("event_region", "LIV_exon_coords", "splicemode")] %>% unique, tibble_final_transcript_feature_annotation) %>% unique,
            "biomart" = dplyr::left_join(b1[, c("event_region", "LIV_exon_coords", "splicemode")] %>% unique, tibble_final_biomart_annotation) %>% unique,
            "dbPTM" = dplyr::left_join(b1[, c("event_region", "LIV_exon_coords", "splicemode")] %>% unique, tibble_final_PTM_annotation) %>% unique
          )
        )
        
      } ) %>% return
    
  }, .progress = TRUE)

save(list_characteristic_markers_for_each_cluster_transcript_ontology, file = paste(R_processing_results_dir, "list_characteristic_markers_for_each_cluster_transcript_ontology.Rlist", sep = ""), compress = FALSE)

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 3)))

# analyse the data, create summary table
suppressMessages(
  
  tibble_characteristic_markers_for_each_group_summary_all_ontology <- furrr::future_map2(
    .x = list_characteristic_markers_for_each_cluster_transcript_ontology,
    .y = names(list_characteristic_markers_for_each_cluster_transcript_ontology),
    .f = function(a1, a2) {
      
      # DEBUG ###
      # a1 <- list_characteristic_markers_for_each_cluster_transcript_ontology[[1]]
      # a2 <- names(list_characteristic_markers_for_each_cluster_transcript_ontology) %>% .[[1]]
      ###########
      
      list_positive_negative_markers_result <- purrr::map2(
        .x = a1,
        .y = names(a1),
        .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- a1[[1]]
          # b2 <- names(a1) %>% .[[1]]
          ###########
          
          tibble_transcript_ontology_summary <- tibble(
            "frequency_protein_coding" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "protein\\_coding") %>% length,
            "frequency_start_codon" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "start\\_codon") %>% length,
            "frequency_stop_codon" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "stop\\_codon") %>% length,
            "frequency_retained_intron" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "retained\\_intron") %>% length,
            "frequency_five_prime_utr" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "five\\_prime\\_utr") %>% length,
            "frequency_three_prime_utr" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "three\\_prime\\_utr") %>% length,
            "frequency_nonsense_mediated_decay" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "nonsense\\_mediated\\_decay") %>% length,
            "frequency_lncRNA" = grep(x = b1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "lncRNA") %>% length
          ) %>%
            tibble::add_column(
              "cluster_name" = a2,
              "positive_or_negative_markers" = b2,
              .before = 1
            )
          
          tibble_biomart_ontology_summary <- tibble(
            "frequency_interpro" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `interpro` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
            "frequency_mobidblite" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `mobidblite` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
            "frequency_seg" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `seg_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
            "frequency_ncoils" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `ncoils_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
            "frequency_tmhmm" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `tmhmm_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
            "frequency_signalp" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `signalp_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
            "frequency_sifts" = b1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `sifts_import` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
          ) %>%
            tibble::add_column(
              "cluster_name" = a2,
              "positive_or_negative_markers" = b2,
              .before = 1
            )
          
          tibble_PTM_ontology_summary <- b1$dbPTM %>% 
            dplyr::group_by(PTM_type) %>%
            dplyr::summarise("frequency" = n()) %>%
            na.omit %>%
            t %>%
            as_tibble %>%
            setNames(nm = .[1, ] %>% unlist) %>%
            .[-1, ] %>%
            type_convert %>%
            tibble::add_column(
              "cluster_name" = a2,
              "positive_or_negative_markers" = b2,
              .before = 1
            )
          
          return(list(
            "tibble_transcript_ontology_summary" = tibble_transcript_ontology_summary,
            "tibble_biomart_ontology_summary" = tibble_biomart_ontology_summary,
            "tibble_PTM_ontology_summary" = tibble_PTM_ontology_summary
          ) )
          
        } )
      
      # combine positive and negative markers for each ontology type
      list_combined <- purrr::splice(
        "tibble_transcript_ontology_summary" = purrr::map(.x = list_positive_negative_markers_result, .f = ~.x$tibble_transcript_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble,
        "tibble_biomart_ontology_summary" = purrr::map(.x = list_positive_negative_markers_result, .f = ~.x$tibble_biomart_ontology_summary) %>% rbindlist(fill = TRUE) %>% as_tibble,
        "tibble_PTM_ontology_summary" = purrr::map(.x = list_positive_negative_markers_result, .f = ~.x$tibble_PTM_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble
      )
      
      return(list_combined)
      
    }, .progress = TRUE )
  
)

# combine all clusters for each ontology type
tibble_characteristic_markers_for_each_group_summary_all_ontology_combined <- purrr::splice(
  "tibble_transcript_ontology_summary" = purrr::map(.x = tibble_characteristic_markers_for_each_group_summary_all_ontology, .f = ~.x$tibble_transcript_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble,
  "tibble_biomart_ontology_summary" = purrr::map(.x = tibble_characteristic_markers_for_each_group_summary_all_ontology, .f = ~.x$tibble_biomart_ontology_summary) %>% rbindlist(fill = TRUE) %>% as_tibble,
  "tibble_PTM_ontology_summary" = purrr::map(.x = tibble_characteristic_markers_for_each_group_summary_all_ontology, .f = ~.x$tibble_PTM_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble
)

save(tibble_characteristic_markers_for_each_group_summary_all_ontology_combined, file = paste(R_processing_results_dir, "tibble_characteristic_markers_for_each_group_summary_all_ontology_combined.Rlist", sep = ""), compress = FALSE)
load(file = paste(R_processing_results_dir, "tibble_characteristic_markers_for_each_group_summary_all_ontology_combined.Rlist", sep = ""))

# plot
purrr::map2(
  .x = tibble_characteristic_markers_for_each_group_summary_all_ontology_combined,
  .y = names(tibble_characteristic_markers_for_each_group_summary_all_ontology_combined) %>% gsub(pattern = "tibble\\_(.*)\\_summary", replacement = "\\1"),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- tibble_characteristic_markers_for_each_group_summary_all_ontology_combined %>% .[[3]]
    # a2 <- names(tibble_characteristic_markers_for_each_group_summary_all_ontology_combined) %>% gsub(pattern = "tibble\\_(.*)\\_summary", replacement = "\\1") %>% .[[3]]
    ###########
    
    tibble_for_plot <- a1 %>% 
      # normalise the tallies to the row sum
      dplyr::mutate(across(.cols = contains("frequency"), .fns = function(x) {return(x*100/rowSums(a1 %>% dplyr::select(contains("frequency"))))} ) ) %>%
      # positive_or_negative_markers column values have to be shortened
      dplyr::mutate("positive_or_negative_markers" = gsub(x = `positive_or_negative_markers`, pattern = "vector\\_row\\_indices\\_(.*)\\_passing\\_threshold", replacement = "\\1")) %>%
      reshape2::melt(id.vars = c("cluster_name", "positive_or_negative_markers")) %>%
      as_tibble %>%
      dplyr::mutate("cluster_name" = `cluster_name` %>% as.factor %>% fct_relevel(`cluster_name` %>% unique %>% mixedsort),
                    "som_cluster_or_chucked_out_cluster" = gsub(x = `cluster_name`, pattern = "(.*er)\\_.*$", replacement = "\\1")) %>% 
      type_convert()
    # %>%
    #   tibble::add_column("cluster_positive_negative_markers" = paste(.$cluster_name, "_", .$positive_or_negative_markers, sep = ""))
    
    # reorder(PTM_type, -tally)
    ggplot(tibble_for_plot, aes(x = cluster_name, y = value, fill = variable)) +
      geom_col(position = "dodge") +
      facet_wrap(facets = som_cluster_or_chucked_out_cluster ~ positive_or_negative_markers %>% as.factor %>% fct_relevel(c("positive_markers", "negative_markers")), ncol = 1, scales = "free") +
      geom_text(stat = "identity",  position = position_dodge(width = 1), aes(label = value %>% signif(2)), angle = 90, hjust = 0, size = 0.8) +
      ggtitle(paste(a2)) +
      xlab("Group name") +
      scale_x_discrete(labels = function(x) {str_trunc(string = x, width = 25, side = "center", ellipsis = "...")}) +
      ylab("Proportion for group (%)") +
      # ylim(c(0, max(tibble_PTM_tally$tally) + 5)) +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 3), 
            axis.title.y = element_text(size = 3), 
            legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), 
            text = element_text(family = "Helvetica")) +
      ggsave(filename = paste(R_processing_results_dir, "totalrna_characteristic_markers_for_each_cluster_", a2, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 20, units = "cm") +
      ggsave(filename = paste(R_processing_results_dir, "totalrna_characteristic_markers_for_each_cluster_", a2, ".svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 20, units = "cm") 
    
    write.table(x = tibble_for_plot, file = paste(R_processing_results_dir, "totalrna_characteristic_markers_for_each_cluster_", a2, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
    
  } )

```

#### Intra-cluster comparisons

```{r}

load(file = paste(R_processing_results_dir, "list_annotated_result_differential_comparisons_within_clusters.Rlist", sep = ""))

load(file = paste(R_processing_results_dir, "tibble_final_transcript_feature_annotation.tibble", sep = ""))
load(file = paste(R_processing_results_dir, "tibble_final_biomart_annotation.tibble", sep = ""))
load(file = paste(R_processing_results_dir, "tibble_final_PTM_annotation.tibble", sep = ""))

plan(list(tweak(multiprocess, workers = 36),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 3)))

list_annotated_result_differential_comparisons_within_clusters_transcript_ontology <- furrr::future_map2(
  .x = list_annotated_result_differential_comparisons_within_clusters,
  .y = names(list_annotated_result_differential_comparisons_within_clusters),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_annotated_result_differential_comparisons_within_clusters[[1]]
    # a2 <- names(list_annotated_result_differential_comparisons_within_clusters) %>% .[[1]]
    ###########
    
    furrr::future_map2(
      .x = a1,
      .y = names(a1),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% .[[1]]
        ###########
        
        furrr::future_map2(
          .x = b1,
          .y = names(b1),
          .f = function(c1, c2) {
            
            # DEBUG ###
            # c1 <- b1[[1]]
            # c2 <- names(b1) %>% .[[1]]
            ###########
            
            return(
              list(
                "transcript_ontology" = dplyr::left_join(c1[, c("event_region", "LIV_exon_coords", "splicemode")] %>% unique, tibble_final_transcript_feature_annotation) %>% unique,
                "biomart" = dplyr::left_join(c1[, c("event_region", "LIV_exon_coords", "splicemode")] %>% unique, tibble_final_biomart_annotation) %>% unique,
                "dbPTM" = dplyr::left_join(c1[, c("event_region", "LIV_exon_coords", "splicemode")] %>% unique, tibble_final_PTM_annotation) %>% unique
              )
            )
            
          } ) %>% return
        
      } ) %>% return
    
  }, .progress = TRUE)

save(list_annotated_result_differential_comparisons_within_clusters_transcript_ontology, file = paste(R_processing_results_dir, "list_annotated_result_differential_comparisons_within_clusters_transcript_ontology.Rlist", sep = ""), compress = FALSE)

plan(list(tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 3)))

# analyse the data, create summary table
suppressMessages(
  
 list_differential_comparisons_within_clusters_transcript_ontology <- purrr::map2(
    .x = list_annotated_result_differential_comparisons_within_clusters_transcript_ontology,
    .y = names(list_annotated_result_differential_comparisons_within_clusters_transcript_ontology),
    .f = function(a1, a2) {
      
      # DEBUG ###
      # a1 <- list_annotated_result_differential_comparisons_within_clusters_transcript_ontology[[10]]
      # a2 <- names(list_annotated_result_differential_comparisons_within_clusters_transcript_ontology) %>% .[[10]]
      ###########
      
      cat(a2, "\n")
      
      list_intracluster_comparisons_result <- furrr::future_map2(
        .x = a1,
        .y = names(a1),
        .f = function(b1, b2) {
          
          # DEBUG ###
          # b1 <- a1[[1]]
          # b2 <- names(a1) %>% .[[1]]
          ###########
          
          cat(b2, "\n")
          
          list_positive_negative_markers_result <- purrr::map2(
            .x = b1,
            .y = names(b1) %>% gsub(pattern = ".*(comparison_._greater).*", replacement = "\\1"),
            .f = function(c1, c2) {
              
              # DEBUG ###
              # c1 <- b1[[2]]
              # c2 <- names(b1) %>% gsub(pattern = ".*(comparison_._greater).*", replacement = "\\1") %>% .[[2]]
              ###########
              
              cat(c2, "\n")
              
              if (nrow(c1$transcript_ontology) > 0) {
                tibble_transcript_ontology_summary <- tibble(
                  "frequency_protein_coding" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "protein\\_coding") %>% length,
                  "frequency_start_codon" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "start\\_codon") %>% length,
                  "frequency_stop_codon" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "stop\\_codon") %>% length,
                  "frequency_retained_intron" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "retained\\_intron") %>% length,
                  "frequency_five_prime_utr" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "five\\_prime\\_utr") %>% length,
                  "frequency_three_prime_utr" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "three\\_prime\\_utr") %>% length,
                  "frequency_nonsense_mediated_decay" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "nonsense\\_mediated\\_decay") %>% length,
                  "frequency_lncRNA" = grep(x = c1$transcript_ontology$tibble_overlapping_parent_transcript_features, pattern = "lncRNA") %>% length
                ) %>%
                  tibble::add_column(
                    "cluster_name" = a2,
                    "comparison_name" = b2,
                    "which_comparison_greater" = c2,
                    .before = 1
                  )
              } else {
                tibble_transcript_ontology_summary <- tibble()
              }
              
              if (nrow(c1$biomart) > 0) {
                tibble_biomart_ontology_summary <- tibble(
                  "frequency_interpro" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `interpro` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                  "frequency_mobidblite" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `mobidblite` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                  "frequency_seg" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `seg_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                  "frequency_ncoils" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `ncoils_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                  "frequency_tmhmm" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `tmhmm_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                  "frequency_signalp" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `signalp_percentage_overlap` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                  "frequency_sifts" = c1$biomart %>% dplyr::group_by(event_region, LIV_exon_coords, splicemode) %>% dplyr::summarise("exists" = `sifts_import` %>% na.omit %>% length > 0) %>% .$exists %>% which %>% length,
                ) %>%
                  tibble::add_column(
                    "cluster_name" = a2,
                    "comparison_name" = b2,
                    "which_comparison_greater" = c2,
                    .before = 1
                  )
              } else {
                tibble_biomart_ontology_summary <- tibble()
              }
              
              if (nrow(c1$dbPTM %>% .[.$PTM_type %>% is.na != TRUE, ]) > 0) {
                tibble_PTM_ontology_summary <- c1$dbPTM %>% 
                  .[.$PTM_type %>% is.na != TRUE, ] %>% 
                  dplyr::group_by(PTM_type) %>%
                  dplyr::summarise("frequency" = n()) %>%
                  na.omit %>%
                  t %>%
                  as_tibble %>%
                  setNames(nm = .[1, ] %>% unlist) %>%
                  .[-1, ] %>%
                  type_convert %>%
                  tibble::add_column(
                    "cluster_name" = a2,
                    "comparison_name" = b2,
                    "which_comparison_greater" = c2,
                    .before = 1
                  )
              } else {
                tibble_PTM_ontology_summary <- tibble()
              }
              
              return(list(
                "tibble_transcript_ontology_summary" = tibble_transcript_ontology_summary,
                "tibble_biomart_ontology_summary" = tibble_biomart_ontology_summary,
                "tibble_PTM_ontology_summary" = tibble_PTM_ontology_summary
              ) )
              
            } ) %>% return
          
          # combine positive and negative markers for each ontology type
          list_combined <- purrr::splice(
            "tibble_transcript_ontology_summary" = purrr::map(.x = list_positive_negative_markers_result, .f = ~.x$tibble_transcript_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble,
            "tibble_biomart_ontology_summary" = purrr::map(.x = list_positive_negative_markers_result, .f = ~.x$tibble_biomart_ontology_summary) %>% rbindlist(fill = TRUE) %>% as_tibble,
            "tibble_PTM_ontology_summary" = purrr::map(.x = list_positive_negative_markers_result, .f = ~.x$tibble_PTM_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble
          )
          
          return(list_combined)
          
        } )
      
      # combine positive and negative markers for each ontology type
      list_combined <- purrr::splice(
        "tibble_transcript_ontology_summary" = purrr::map(.x = list_intracluster_comparisons_result, .f = ~.x$tibble_transcript_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble,
        "tibble_biomart_ontology_summary" = purrr::map(.x = list_intracluster_comparisons_result, .f = ~.x$tibble_biomart_ontology_summary) %>% rbindlist(fill = TRUE) %>% as_tibble,
        "tibble_PTM_ontology_summary" = purrr::map(.x = list_intracluster_comparisons_result, .f = ~.x$tibble_PTM_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble
      )
      
      return(list_combined)
      
    } )
  
)

# combine all clusters for each ontology type
list_differential_comparisons_within_clusters_transcript_ontology_combined <- purrr::splice(
  "tibble_transcript_ontology_summary" = purrr::map(.x = list_differential_comparisons_within_clusters_transcript_ontology, .f = ~.x$tibble_transcript_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble,
  "tibble_biomart_ontology_summary" = purrr::map(.x = list_differential_comparisons_within_clusters_transcript_ontology, .f = ~.x$tibble_biomart_ontology_summary) %>% rbindlist(fill = TRUE) %>% as_tibble,
  "tibble_PTM_ontology_summary" = purrr::map(.x = list_differential_comparisons_within_clusters_transcript_ontology, .f = ~.x$tibble_PTM_ontology_summary) %>% rbindlist(fill = TRUE)  %>% as_tibble
)

save(list_differential_comparisons_within_clusters_transcript_ontology_combined, file = paste(R_processing_results_dir, "list_differential_comparisons_within_clusters_transcript_ontology_combined.Rlist", sep = ""), compress = FALSE)

```

#### Inter-cluster comparisons of the same cell/tissue type

```{r}

load(file = paste(R_processing_results_dir, "list_annotated_result_sample_subtypes_between_clusters.Rlist", sep = ""))

list_annotated_result_sample_subtypes_between_clusters

```

# WGCNA analysis

Orthogonal approach to find DS events and signature modules of AS events specific to each sample

## load data

```{r}

# THE DATA ###
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

# get column indices for each sample type because we are going to looop through each of them
list_vector_column_subsetting_indices <- purrr::map(
  .x = c("tissue", "cell type", "cell line"), 
  .f = ~which(gsub(x = colnames(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))), pattern = "_absolute\\.psi", replacement = "") %in% (tibble_combined_mapping_info[grep(x = tibble_combined_mapping_info$Type, pattern = .x), ] %>% .$condition_names))
  ) %>% set_names(nm = c("tissue", "cell type", "cell line"))

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

```

## Try WGCNA package (deprecated) - too slow

```{r eval=FALSE, include=FALSE}

library(WGCNA)

options(stringsAsFactors = FALSE)

WGCNA::enableWGCNAThreads()

plan(list(tweak(multiprocess, workers = 6),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 3)))

# Choose a set of soft-thresholding powers
vector_soft_thresholding_powers <- seq(from = 1, to = 20, by = 1)
# Call the network topology analysis function
list_sft <- purrr::map2(
  .x = list_vector_column_subsetting_indices,
  .y = names(list_vector_column_subsetting_indices),
  .f = function(a1, a2) {
    
    # DEBUG ###
    a1 <- list_vector_column_subsetting_indices[[1]]
    a2 <- names(list_vector_column_subsetting_indices) %>% .[[1]]
    ###########
    
    test <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[, a1] %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < length(X) } ) %>% unlist, ]
    
    L1_sft <- WGCNA::pickSoftThreshold(test %>% t, powerVector = vector_soft_thresholding_powers, verbose = 5, blockSize = nrow(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering))
    
    L1_CM <- WGCNA::blockwiseConsensusModules(multiExpr = test %>% array_tree(margin = 2) %>% purrr::map(.f = ~.x %>% t) %>% purrr::map(.f = ~list("data" = .x)), power = which((L1_sft$fitIndices$SFT.R.sq * L1_sft$fitIndices$truncated.R.sq) == max(L1_sft$fitIndices$SFT.R.sq * L1_sft$fitIndices$truncated.R.sq ) ) %>% .[1], minModuleSize = 30, deepSplit = 2,pamRespectsDendro = FALSE,mergeCutHeight = 0.25, numericLabels = TRUE,minKMEtoStay = 0,saveTOMs = TRUE, verbose = 5)
    
    plan(list(tweak(multiprocess, workers = 4),
              tweak(multiprocess, workers = 4)))
    
    write.table(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% tibble::add_column("id" = 1:nrow(.), .before = 1), file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering_psimatrixonly.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    
    
    
    
    
    
    
    data.table::fwrite(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ] %>% t %>% as_tibble(rownames = "rowname") %>% tibble::add_column("Class" = dplyr::left_join(.$rowname %>% gsub(pattern = "\\_absolute\\.psi", replacement = "") %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_processed_UMAP_cluster_legend) %>% .$som_cluster) %>% .[!is.na(.$Class), ] %>% dplyr::select(-rowname) , file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering_psimatrixonly_", a2, "_test.txt", sep = ""), sep = "\t", quote = FALSE, row.names = TRUE, col.names = TRUE)
    # %>% tibble::add_column("id" = 1:nrow(.), .before = 1)
    
  } )

# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",main = paste("Scale independence"));text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",main = paste("Mean connectivity"))text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

```

## FastGCN

Modified from: Liang, M., Zhang, F., Jin, G. and Zhu, J., 2015. FastGCN: a GPU accelerated tool for fast gene co-expression networks. PloS one, 10(1), p.e0116776.

### Set up FastGCN

```{r}

#############################################################################
#FastGCN (a GPU accelerated tool for Fast Gene Co-expression Networks) 1.1   #
#Copyright (c) 2010-2014 by Meimei Liang, Futao Zhang, Gulei Jin and Jun Zhu#
#Institute of Bioinformatics, Zhejiang University, China                    #
#First use Information Entropy to pre-process and cut off some genes.       # 
#Then calculate the Pairwise Correlation Coefficients.                      #
#Z-normalization of the coefficients                                        #
#############################################################################

entropy_pre <- function(eData,remain_para)
{
  #the first column is the gene names
  eData_tmp <- eData[, -1]
  gNum <- dim(eData_tmp)[1]
  sNum <- dim(eData_tmp)[2]
  eData_tmp <- abs(eData_tmp)
  #option 1
  rowSum <- rowSums(eData_tmp)
  p <- eData_tmp/rowSum
  logp <- log(p)
  plogp <- p*logp
  entropy <- -rowSums(plogp, na.rm = TRUE)
  
  #option 2: use the code below, but it is too slow.
  #entropy=c()
  #for( i in 1:gNum)
  #{
  #    expr_sum=sum(abs(eData_tmp[i,]))
  #    pij=abs(eData_tmp[i,])/expr_sum
  #    entropy=c(entropy,-sum(pij*log(pij)))
  #}
  
  sorted_entropy <- sort(entropy)
  if (remain_para > 1.0) {
    pos <- round(remain_para)
  } else {
    pos <- ceiling(remain_para*gNum)}
  
  threshold <- sorted_entropy[pos]
  idx <- which(entropy <= threshold)
  eData <- eData[idx,]
  return(eData)	
}

cal_pcc=function(eData, USE_WGCNA, no.threads_corr)
{
  eData_tmp = eData[,-1]
  eData_tmp = as.matrix(eData_tmp)
  gNum=dim(eData_tmp)[1]
  sNum=dim(eData_tmp)[2]
  if(USE_WGCNA){
    print("using WGCNA package.")
    WGCNA::allowWGCNAThreads(nThreads = no.threads_corr)
    coeff <- WGCNA::cor(t(eData_tmp))
  }else{
    WGCNA::allowWGCNAThreads(nThreads = no.threads_corr)
    coeff <- WGCNA::cor(t(eData_tmp))
    # , method = "pearson"
  }
  # or use the code below, but it is too slow.
  #coeff=c()
  #for(i in 1:gNum)
  #{
  #	j=i+1
  #	while(j<=gNum)
  #	{
  
  #		tmp=cor(eData_tmp[i,],eData_tmp[j,], method="pearson")
  
  #		coeff=c(coeff,tmp)		
  
  #		j=j+1
  #	}
  #}	
  return(coeff)
}
getRow=function(vecid)
{
  rownum=round(sqrt(vecid))
  while(TRUE){
    if((rownum*(rownum-1)/2)>=vecid) break
    rownum=rownum+1
  }
  return(rownum)
}

# Imputation with Overall Mean of the whole values
OM_impute=function(eData)
{
  miss_idx=is.na(eData)
  if(length(which(miss_idx==TRUE))>0)
  {
    etmp=eData[,-1]
    etmp=as.vector(as.matrix(etmp))
    idx=which(is.na(etmp))
    etmp=etmp[-idx]
    iValue=mean(etmp)
    eData[miss_idx]=iValue	
  }
  return(eData)
}
# Imputation with Overall Mean of each Gene expression values
OMG_impute=function(eData)
{
  miss_idx=which(is.na(eData))
  if(length(miss_idx)>0)
  {
    geneNum=dim(eData)[1]
    for( i in 1:geneNum)
    {
      idx=which(is.na(eData[i,]))
      if(length(idx)>0)
      {
        vec=eData[i,]
        vec[idx]=0
        rMean=sum(vec[-1])/(length(vec)-length(idx)-1)
        eData[i,idx]=rMean
      }
    }
  }
  
  return(eData)
}

#Modules Identification. Input is the Pearson Correlation Coefficient Symmetric Matrix
#z-score as the evaluation criteria.
Modls_Idnt=function(coeff, gname, coeff_mean, coeff_sd, Z_threshold) {
  
  # DEBUG ###
  # coeff <- coeff
  # gname <- gname
  ###########
  
  rlt <- list()
  adja_mat <- (abs(coeff) - coeff_mean) / coeff_sd
  diag(adja_mat) <- 0 # set the diagonal zero 
  idx <- adja_mat >= Z_threshold
  adja_mat[idx] <- 1
  adja_mat[!idx] <- 0 #got the adjacency matrix
  K <- rowSums(adja_mat) # got the node connectivity 
  idx <- which(K == 0)
  adja_mat <- adja_mat[-idx,-idx] #remove the genes whose K is zero
  K <- K[-idx]	
  rlt$gname <- gname[-idx] #adjust the gene names
  H <- adja_mat %*% adja_mat
  diag(H) <- 0
  H_A <- H + adja_mat
  slt_num <- length(K)
  K_mat <- matrix(rep(K,slt_num), slt_num, slt_num)
  KI_KJ <- K_mat + t(K_mat)
  Denominator <- KI_KJ - H_A
  rlt$S <- H_A / Denominator # got the similarity matrix
  return(rlt)
}

Modls_Idnt_=function(coeff)
{
  adja_mat=(abs(coeff)-coeff_mean)/coeff_sd # currently adja_mat is the z-score matrix
  diag(adja_mat)=0 # set the diagonal zero 
  idx=adja_mat>=Z_threshold
  adja_mat[idx]=1
  adja_mat[!idx]=0 #got the adjacency matrix
  K=rowSums(adja_mat) # got the node connectivity 
  H=adja_mat%*%adja_mat
  diag(H)=0
  H_A=H+adja_mat
  slt_num=length(K)
  K_mat=matrix(rep(K,slt_num),slt_num,slt_num)
  KI_KJ=K_mat+t(K_mat)
  Denominator=KI_KJ-H_A
  S=H_A/Denominator # got the similarity matrix
  return(S)
}

# NOTE: eData: rows = genes; columns = samples. the first column is reserved for a column identifier
# NOTE: there is a bug in corFast right now, so disable it.
FastGCN_wrapper <- function(df_input, Z_threshold = 6.8, FDR_cutoff = 0.05, use.FDR = TRUE, no.threads_corr = 16, no.threads_loop = 8, use.WGCNA = FALSE, entropy_remain_para = 1) {
  
  # DEBUG ###
  # eData <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[1:2340, a1] %>% tibble::add_column("id" = 1:nrow(.), .before = 1)
  # df_input <- a1
  # Z_threshold <- 6.8
  # FDR_cutoff <- 0.05
  # use.FDR <- TRUE
  # no.threads_corr <- 24
  # no.threads_loop <- 24
  # use.WGCNA <- TRUE
  # entropy_remain_para <- 1
  ###########
  
  remain_para <- entropy_remain_para
  Z_threshold <- Z_threshold
  FDR <- FDR_cutoff
  FDR_switcher <- use.FDR
  eData <- df_input #the first row is the individual names
  
  USE_WGCNA <- use.WGCNA
  
  library(WGCNA)
  WGCNA::allowWGCNAThreads(nThreads = no.threads_corr)
  #print(WGCNAnThreads())
  
  timestamp = Sys.time()
  
  message("imputation\n")
  #imputation with overall mean
  eData <- OMG_impute(eData)
  #imputation completed
  
  message("step1: Filter with Genetic Entropy\n")
  if (abs(remain_para - 1.0) > 1e-6) eData <- entropy_pre(eData, remain_para)
  
  message("step2: calculate the PCC and get the coefficient matrix\n")
  # coeff <- cal_pcc(eData[, -1], USE_WGCNA, no.threads_corr = no.threads_corr)
  coeff <- stats::cor(eData[, -1] %>% as.matrix %>% t, method = "pearson")
  
  message("step3: Normalization and FDR control\n")
  coeff_vec <- coeff[upper.tri(coeff)]
  abs_coeff <- abs(coeff_vec)
  coeff_sd <- sd(abs_coeff %>% na.omit)
  coeff_mean <- mean(abs_coeff %>% na.omit)
  coeff_z <- (abs_coeff - coeff_mean) / coeff_sd
  pval <- 1 - pnorm(coeff_z)
  qval <- p.adjust(pval, method = "BH", length(pval))
  
  message("step4: Modules Identification\n")
  gname <- as.character(eData[, 1])
  dt_rlt <- Modls_Idnt(coeff, gname, coeff_mean, coeff_sd, Z_threshold)
  # gname <- dt_rlt$gname
  # S <- dt_rlt$S
  
  Sys.time()-timestamp
  
  message("step5 output the co-expression network\n")
  if (FDR_switcher == TRUE) {
    idx <- which(qval <= FDR)
  } else {
    idx <- which(coeff_z >= Z_threshold)
  }
  
  # plan(list(tweak(multiprocess, workers = no.threads_loop),
  #           tweak(multiprocess, workers = 1))) 
  
  plan(list(tweak(multiprocess, workers = 66),
  tweak(multiprocess, workers = 1)))
  
  collectGarbage()
  
  message("step6 summarise the data\n")
  list_gnames <- furrr::future_imap(
    .x = idx,
    .f = function(a1, a2) {
      
      # DEBUG ###
      # a1 <- idx[[1]]
      ###########
      
      # cat(a2, "\n")
      
      vec_id <- a1
      row_id <- getRow(vec_id)
      col_id <- vec_id - (row_id - 1) * (row_id - 2) / 2
      gName1 <- as.character(eData[row_id, 1])
      gName2 <- as.character(eData[col_id, 1])
      
      return(list(
        "gName1" = gName1,
        "gName2" = gName2
      ))
      
    }, .progress = TRUE )
  
  plan(list(tweak(multiprocess, workers = 66),
  tweak(multiprocess, workers = 1)))
  
  list_rlt <- furrr::future_pmap(
    .l = list(
      "a1" = idx,
      "a2" = list_gnames,
      "a3" = 1:length(idx)
    ),
    .f = function(a1, a2, a3) {
      
      # DEBUG ###
      # a1 <- idx[[1]]
      # a2 <- list_gnames[[1]]
      # a3 <- (1:length(idx)) %>% .[[1]]
      ###########
      
      vec_id <- a1
      
      coeff_pcc <- coeff_vec[vec_id]	
      z_value <- coeff_z[vec_id]
      p_value <- pval[vec_id]
      q_value <- qval[vec_id]
      
      rlt <- data.frame(
        "gene1" = a2$gName1,
        "gene2" = a2$gName2,
        "coeff_pcc" = coeff_pcc,
        "z-score" = z_value,
        "p_value" = p_value,
        "q_value" = q_value
      ) 
      
      return(rlt)
      
    }, .progress = TRUE )
  
  tibble_rlt <- list_rlt %>% rbindlist %>% as_tibble
  
  return(list(
    "tibble_rlt" = tibble_rlt,
    "dt_rlt" = dt_rlt
  ) )
  
}

```

### Run FastGCN 

#### individual cluster shenanigans

```{r}

# library(coop)
# library(gpuMagic)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 4)))

list_absolute_psi_table_split_by_som_cluster <- furrr::future_map(.x = tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(.f = ~.x$condition_names %>% unique), .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% tibble::add_column("id" = 1:nrow(.), .before = 1) %>% dplyr::select(id, contains("absolute.psi")) %>% .[, gsub(x = colnames(.), pattern = "\\_absolute\\.psi", replacement = "") %in% c(.x, "id")] %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ], .progress = TRUE) %>% 
  set_names(nm = tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(.f = ~.x$som_cluster %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4)))

# write each table for GPU version of fastGCN
furrr::future_map2(
  .x = list_absolute_psi_table_split_by_som_cluster,
  .y = names(list_absolute_psi_table_split_by_som_cluster),
  .f = ~data.table::fwrite(x = .x, file = paste(R_processing_results_dir, "tibble_absolute_psi_for_GPU_fastGCN_som_cluster_", .y, ".txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE), .progress = TRUE)

# list_absolute_psi_table_split_by_type <- purrr::map(.x = list_vector_column_subsetting_indices, .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[, .x] %>% tibble::add_column("id" = 1:nrow(.), .before = 1))

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 22)))

library(WGCNA)

list_fastGCN_results <- furrr::future_map2(
  .x = list_absolute_psi_table_split_by_som_cluster[5: length(list_absolute_psi_table_split_by_som_cluster)],
  .y = names(list_absolute_psi_table_split_by_som_cluster) %>% .[5: length(list_absolute_psi_table_split_by_som_cluster)],
  .f = function(a1, a2) {
    
    # DEBUG ###
    a1 <- list_absolute_psi_table_split_by_som_cluster[[1]]
    a2 <- names(list_absolute_psi_table_split_by_som_cluster) %>% .[[1]]
    ###########
    
    cat(a2, "\n")
    
    collectGarbage()
    
    list_fastGCN_result <- FastGCN_wrapper(
      df_input = dplyr::bind_cols(a1[, "id"], a1 %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble), 
      Z_threshold = 6.8, FDR_cutoff = 0.05, use.FDR = TRUE, no.threads_corr = 8, no.threads_loop = 66, use.WGCNA = TRUE, entropy_remain_para = 1) %>%
      tibble::add_column("comparison_name" = a2)
    
    save(list_fastGCN_result, file = paste(R_processing_results_dir, "list_fastGCN_results_som_cluster_", a2, ".Rlist", sep = ""), compress = FALSE)
    
    list_fastGCN_result$tibble_rlt <- list_fastGCN_result$tibble_rlt %>%
      tibble::add_column("comparison_name" = a2)
    
    data.table::fwrite(x = list_fastGCN_result$tibble_rlt, file = paste(R_processing_results_dir, "tibble_fastGCN_result_som_cluster_", a2, ".txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    
  }, .progress = TRUE )

# save(list_fastGCN_results, file = paste(R_processing_results_dir, "list_fastGCN_results.Rlist", sep = ""), compress = FALSE)

```

##### import externally run FastGCN results

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 2)))

list_fastGCN_clusterone_tibbles <- furrr::future_map(
  .x = list.files(path = R_processing_results_dir_2, pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*)_scaled.genepro") %>% gsub(pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*)_scaled.genepro", replacement = "\\1") %>% .[. != "NA"],
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list.files(path = R_processing_results_dir_2, pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*).genepro") %>% gsub(pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*).genepro", replacement = "\\1") %>% .[. != "NA"] %>% .[1]
    ###########
    
    tibble_clusterone_result <- read.delim(paste(R_processing_results_dir_2, "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_", a1, "_scaled.csv", sep = ""), sep = ",", header = TRUE, row.names = NULL) %>% as_tibble %>% 
      dplyr::filter(P.value <= 0.05 & Size >= 25)

    return(tibble_clusterone_result)
    
  }, .progress = TRUE ) %>% set_names(nm = list.files(path = R_processing_results_dir_2, pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*)_scaled.genepro") %>% gsub(pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*)_scaled.genepro", replacement = "\\1") %>% .[. != "NA"] %>% paste("som_cluster_", ., sep = ""))

```

##### analysis point #1: characteristic modules for each cluster

```{r}

# THE DATA ###
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_chucked_out_items_UMAP <- data.table::fread(paste(R_processing_results_dir_2, "tibble_chucked_out_items_UMAP_consensus_som_clusterONE_all_data.txt", sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% .[.$condition_names %>% is.na != TRUE, ]

vector_chucked_out_sample_names <- paste("chucked_out_RNA_number_", tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$RNA_number %>% unique) %>% unlist, sep = "")

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

tibble_mapping_condition_names_RNA_number_to_cluster_name <- dplyr::bind_rows(
  # chucked out items
  tibble("cluster_name" = vector_chucked_out_sample_names, 
         "RNA_number" = vector_chucked_out_sample_names %>% gsub(pattern = "chucked\\_out\\_RNA\\_number\\_", replacement = "") ) %>% mutate_all(as.character) %>% dplyr::left_join(., tibble_chucked_out_items_UMAP[, c("RNA_number", "condition_names")] %>% mutate_all(as.character)) %>% (function(x) {x[x$cluster_name %>% duplicated, "cluster_name"] <- paste(x[x$cluster_name %>% duplicated, ] %>% .$cluster_name, "_2", sep = "") ; return(x)} ) %>% mutate_all(as.character),
  tibble_processed_UMAP_cluster_legend[, c("cluster_number", "RNA_number", "condition_names")] %>% dplyr::mutate("cluster_name" = paste("no_", `cluster_number`, sep = "")) %>% mutate_all(as.character)
  ) %>% type_convert

list_absolute_psi_table_split_by_som_cluster <- furrr::future_map(.x = tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(.f = ~.x$condition_names %>% unique), .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% tibble::add_column("id" = 1:nrow(.), .before = 1) %>% dplyr::select(id, contains("absolute.psi")) %>% .[, gsub(x = colnames(.), pattern = "\\_absolute\\.psi", replacement = "") %in% c(.x, "id")] %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ], .progress = TRUE) %>% 
  set_names(nm = tibble_processed_UMAP_cluster_legend %>% dplyr::group_split(som_cluster) %>% purrr::map(.f = ~.x$som_cluster %>% unique) %>% unlist)

# cryptic function to create a list where .[[1]] = comparison 1, .[[2]] = comparison 2
create_comparison_from_sample_number_and_cluster <- function(vector_cluster_1, vector_cluster_2, cluster_number, tibble_mapping_file, comparison_1_vs_rest = NULL) {
  
  if (comparison_1_vs_rest == TRUE) {
    
    return(
      list(
        vector_cluster_1, tibble_mapping_file[tibble_mapping_file$som_cluster == cluster_number & !tibble_mapping_file$cluster_number %in% vector_cluster_1, ] %>% .$cluster_number
      )
    )
    
  } else if (comparison_1_vs_rest == FALSE) {
    
    return(
      list(
        vector_cluster_1, vector_cluster_2
      )
    )
    
  }
  
}

list_sample_numbers_for_each_cluster_ordered_by_subtype <- list(
  "1_ECs" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(9, 10), cluster_number = "1", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "2_muscle cells, fibroblast/msc" = c(17, 18, 43, 44, 63, 65, 179, 66, 69, 174, 204, 206, 207, 21, 22, 35, 49, 56, 175, 186, 188, 189, 190),
  "3_muscle cells, fibroblast/msc" = c(15, 16, 25, 26, 182, 184, 3, 4, 34, 37, 54, 47, 57, 64, 177, 178, 225, 209),
  "4_mesodermal etc." = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(194, 197, 230, 233, 237, 238, 254, 255, 262, 263), cluster_number = "4", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "5_muscle cells, fibroblast/msc" = c(5, 6, 13, 14, 36, 55, 170, 39, 52, 229, 240, 272, 273, 53, 222, 280, 281),
  "6_keratinocytes, epithelial cells" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(40, 176), cluster_number = "6", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "7_brain tissue" = tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster == 7, ] %>% .$cluster_number,
  "8_T-ALL, B-ALL" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(157:159, 292), cluster_number = "8", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "9_T-ALL, B-ALL, B cell lines, multiple myeloma" = c(136, 137, 140, 151, 155, 154, 296, 152, 141, 142),
  "10_colon_prostate_lung_ovarian_cancers" = c(83, 84, 293, 294, 79, 80, 81, 82, 91, 92, 131),
  "11_normal neuron, oligodend. precursor, neuroblastoma" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(168, 169), cluster_number = "11", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "12_skeletal muscle, heart tissue" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(217), cluster_number = "12", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "13_foll. root sheath cell, smooth muscle, fibroblast" = c(11, 12, 33, 42, 51, 199, 245, 278, 279, 286),
  "14_neuroblastoma, melanoma, CNS cancer, BRCAR and lung cancer" = c(77, 78, 87, 88, 94, 95, 101, 128, 147, 148, 297),
  "15_fibroblast, epithelial" = c(224, create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(58, 203, 205, 208, 228, 276, 282, 283), vector_cluster_2 = c(200, 202), comparison_1_vs_rest = FALSE) %>% unlist),
  "16_NK, T, B, monocyte" = c(71, 72, 73, 74, 139, 288, 287),
  "17_CNS, ovarian, renal, neuroblastoma, lung, melanoma" = c(100, 153, 300, 301, 133, 295, 134, 143, 289, 145, 149),
  "18_all melanoma" = tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster == 18, ] %>% .$cluster_number,
  "19_BRCAR, colon cancer" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(127, 150), cluster_number = "19", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "20_endodermal etc." = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(215, 218, 236, 260, 261, 267), cluster_number = "20", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "21_mixed alv_M0, renal_cancer, stomach" = c(7,8, 31, 32, 266, 299),
  "22_imDCs, alv M0" = c(112, 113, 114, 115, 187),
  "23_smooth muscle, fibroblast, lens epithelial" = c(1, 2, 48, 221, 201),
  "24_OVCAR, BRCAR, lung cancer" = c(93, 129, 130, 298, 303),
  "25_neuroblastoma, melanoma" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(29, 30), cluster_number = "25", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "26_all renal cancer" = tibble_processed_UMAP_cluster_legend[tibble_processed_UMAP_cluster_legend$som_cluster == 26, ] %>% .$cluster_number,
  "27_heart cells" = c(198, 219, 220, 239),
  "28_spinal cord astrocyte, fibroblast/msc" = create_comparison_from_sample_number_and_cluster(vector_cluster_1 = c(38), cluster_number = "28", tibble_mapping_file = tibble_processed_UMAP_cluster_legend, comparison_1_vs_rest = TRUE) %>% unlist,
  "29_jejunum, distal colon" = c(248, 249, 193),
  "30_adrenal gland, liver" = c(264, 265, 234),
  "31_granulocytes" = c(75, 76, 118),
  "32_LGL and APL leukemia" = c(116, 117, 125)
)

som_cluster_numbers_of_clusterone_result_list <- names(list_fastGCN_clusterone_tibbles) %>% gsub(pattern = "som\\_cluster\\_", replacement = "")

som_cluster_numbers_of_comparison_order_list <- names(list_sample_numbers_for_each_cluster_ordered_by_subtype) %>% gsub(pattern = "([^\\_])\\_.*", replacement = "\\1")

som_cluster_numbers_of_abs_psi_table <- names(list_absolute_psi_table_split_by_som_cluster)

vector_clusters_in_common <- intersect(som_cluster_numbers_of_clusterone_result_list, som_cluster_numbers_of_comparison_order_list) %>%
  intersect(., som_cluster_numbers_of_abs_psi_table)

plan(list(tweak(multiprocess, workers = 20),
          tweak(multiprocess, workers = 2)))

furrr::future_pmap(
  .l = list(
    "a1" = list_fastGCN_clusterone_tibbles[som_cluster_numbers_of_clusterone_result_list %in% vector_clusters_in_common] %>% .[order(som_cluster_numbers_of_clusterone_result_list[(som_cluster_numbers_of_clusterone_result_list %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a2" = list_sample_numbers_for_each_cluster_ordered_by_subtype[som_cluster_numbers_of_comparison_order_list %in% vector_clusters_in_common] %>% .[order(som_cluster_numbers_of_comparison_order_list[(som_cluster_numbers_of_comparison_order_list %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a3" = list_absolute_psi_table_split_by_som_cluster[som_cluster_numbers_of_abs_psi_table %in% vector_clusters_in_common] %>% .[order(som_cluster_numbers_of_abs_psi_table[(som_cluster_numbers_of_abs_psi_table %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a4" = paste("som_cluster_", vector_clusters_in_common, sep = "") 
  ),
  .f = function(a1, a2, a3, a4) {
    
    # DEBUG ###
    # a1 <- list_fastGCN_clusterone_tibbles[som_cluster_numbers_of_clusterone_result_list %in% vector_clusters_in_common] %>% .[[4]]
    # a2 <- list_sample_numbers_for_each_cluster_ordered_by_subtype[som_cluster_numbers_of_comparison_order_list %in% vector_clusters_in_common] %>% .[[4]]
    # a3 <- list_absolute_psi_table_split_by_som_cluster[som_cluster_numbers_of_abs_psi_table %in% vector_clusters_in_common] %>% .[[4]]
    # a4 <- paste("som_cluster_", vector_clusters_in_common, sep = "") %>% .[[4]]
    ###########
    
    tibble_absolute_psi_rearranged <- a3 %>% 
      (function(x) {
        
        tibble_result <- x
        
        vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
        vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "")
        
        colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% gsub(pattern = "no\\_", replacement = "") %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
        
        return(tibble_result)
        
          } )
    
    tibble_absolute_psi_rearranged <- tibble_absolute_psi_rearranged[, c("id", a2)]
    
    # require that the PSI range must be at least 15
    vector_rowwise_PSI_range <- apply(X = tibble_absolute_psi_rearranged %>% dplyr::select(-id), MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit) - min(X %>% na.omit))} )
    
    tibble_absolute_psi_rearranged_scaled <- tibble_absolute_psi_rearranged[which(vector_rowwise_PSI_range >= 15), ]
    
    tibble_absolute_psi_rearranged_scaled[, 2:length(tibble_absolute_psi_rearranged_scaled)] <- tibble_absolute_psi_rearranged_scaled %>% as.data.frame %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble
    
    # construct graphing tibble
    long_tibble_cluster_LIS_ID_psi <- a1 %>% 
      dplyr::rename("WGCNA_cluster" = Cluster) %>%
      group_by(WGCNA_cluster) %>%
      dplyr::summarise(id = Members %>% strsplit(split = " ") %>% unlist) %>%
      type_convert %>%
      dplyr::inner_join(., tibble_absolute_psi_rearranged_scaled %>% reshape2::melt(id.vars = "id", value.name = "psi", variable.name = "sample_number") %>% as_tibble %>% mutate_at(.vars = "id", as.double))
    
    long_tibble_cluster_LIS_ID_psi_average.line <- long_tibble_cluster_LIS_ID_psi %>%
      dplyr::group_by(WGCNA_cluster, sample_number) %>%
      dplyr::summarise(avg_psi = mean(psi))
    
    ggplot() +
      geom_line(data = long_tibble_cluster_LIS_ID_psi, aes(x = sample_number, y = psi, group = id), alpha = 0.1) +
      geom_line(data = long_tibble_cluster_LIS_ID_psi_average.line, aes(x = sample_number, y = avg_psi, group = WGCNA_cluster), colour = "red") +
      
      scale_colour_manual(values = c("black")) +
      # facet_grid(quotient_facet.y ~ remainder_facet.x) +
      facet_wrap(~ WGCNA_cluster, scales = 'free') +
      scale_x_discrete(limits = a2 %>% as.character, labels = a2 %>% as.character) +
      xlab("UMAP sample number") +
      ylab("PSI") +
      # guides(colour = FALSE) +
      theme_bw() +
      theme(text = element_text(family = "Helvetica", size = 3)) +
      # axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), 
      ggsave(filename = paste(R_processing_results_dir, "fastGCN_clusterONE_module_lineplot_intracluster_variable_LIS_", a4, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 50, units = "cm") 
    
    # +
    #   ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 50, units = "cm")
    
    write.table(x = long_tibble_cluster_LIS_ID_psi, file = paste(R_processing_results_dir, "fastGCN_clusterONE_module_lineplot_intracluster_variable_LIS_", a4, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
    
  }, .progress = TRUE )

```

#### shenanigans between clusters for each subtype

##### Run FastGCN

```{r}

# THE DATA ###
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

list_condition_names_of_cell_or_tissue_types_in_multiple_clusters <- list(
  "fibroblasts" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "fibroblast", ignore.case = TRUE, useBytes = TRUE), ],
  "MSCs" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "mesenchymal", ignore.case = TRUE, useBytes = TRUE), ],
  "smooth_muscle" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "smooth muscle", ignore.case = TRUE, useBytes = TRUE), ],
  "epithelial_cells" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "epithelial", ignore.case = TRUE, useBytes = TRUE), ],
  "T-ALL" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "T\\-ALL", ignore.case = TRUE, useBytes = TRUE), ],
  "neuroblastoma" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "neuroblastoma", ignore.case = TRUE, useBytes = TRUE), ],
  "ovarian_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "ovarian cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "breast_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "breast cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "cns_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "CNS cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "NSC_lung_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "non\\-small cell", ignore.case = TRUE, useBytes = TRUE), ],
  "prostate_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "prostate cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "renal_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "renal cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "keratinocyte" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "keratinocyte", ignore.case = TRUE, useBytes = TRUE), ],
  "astrocyte" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "astrocyte", ignore.case = TRUE, useBytes = TRUE), ],
  "macrophage" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "macrophage", ignore.case = TRUE, useBytes = TRUE), ]
) %>% 
  purrr::map(.f = ~.x %>% dplyr::group_split(som_cluster))

# library(coop)
# library(gpuMagic)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 4)))

list_absolute_psi_table_split_by_sample_subtype <- furrr::future_map(.x = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters %>% purrr::map(.f = ~.x %>% rbindlist %>% .$condition_names), .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% tibble::add_column("id" = 1:nrow(.), .before = 1) %>% dplyr::select(id, contains("absolute.psi")) %>% .[, gsub(x = colnames(.), pattern = "\\_absolute\\.psi", replacement = "") %in% c(.x, "id")] %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ], .progress = TRUE) %>% 
  set_names(nm = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters %>% names)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4)))

# write each table for GPU version of fastGCN
furrr::future_map2(
  .x = list_absolute_psi_table_split_by_sample_subtype,
  .y = names(list_absolute_psi_table_split_by_sample_subtype),
  .f = ~data.table::fwrite(x = .x, file = paste(R_processing_results_dir, "tibble_absolute_psi_for_GPU_fastGCN_intercluster_subtype_", .y, ".txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE), .progress = TRUE)

# list_absolute_psi_table_split_by_type <- purrr::map(.x = list_vector_column_subsetting_indices, .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[, .x] %>% tibble::add_column("id" = 1:nrow(.), .before = 1))

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 22)))

library(WGCNA)

list_fastGCN_results <- furrr::future_map2(
  .x = list_absolute_psi_table_split_by_sample_subtype,
  .y = names(list_absolute_psi_table_split_by_sample_subtype),
  .f = function(a1, a2) {
    
    # DEBUG ###
    a1 <- list_absolute_psi_table_split_by_sample_subtype[[1]]
    a2 <- names(list_absolute_psi_table_split_by_sample_subtype) %>% .[[1]]
    ###########
    
    cat(a2, "\n")
    
    collectGarbage()
    
    list_fastGCN_result <- FastGCN_wrapper(
      df_input = a1 %>% 
        .[future_apply(X = ., MARGIN = 1, FUN = function(X) { max(X[2:length(X)]) - min(X[2:length(X)]) >= 15 } ), ] %>%
        (function(x) {dplyr::bind_cols(x[, "id"], x %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble) %>% return } ), 
      Z_threshold = 6.8, FDR_cutoff = 0.05, use.FDR = TRUE, no.threads_corr = 8, no.threads_loop = 66, use.WGCNA = TRUE, entropy_remain_para = 1)
    
    save(list_fastGCN_result, file = paste(temp_fast_storage_dir, "list_fastGCN_result_intercluster_subtype_", a2, "_scaled.Rlist", sep = ""), compress = FALSE)
    
    list_fastGCN_result$tibble_rlt <- list_fastGCN_result$tibble_rlt %>%
      tibble::add_column("comparison_name" = a2)
    
    data.table::fwrite(x = list_fastGCN_result$tibble_rlt, file = paste(temp_fast_storage_dir, "list_fastGCN_result_intercluster_subtype_", a2, "_scaled.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    
  }, .progress = TRUE )

# save(list_fastGCN_results, file = paste(R_processing_results_dir, "list_fastGCN_results.Rlist", sep = ""), compress = FALSE)

```

##### import externally run FastGCN results

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 2)))

list_fastGCN_clusterone_tibbles_subtypes_between_clusters <- furrr::future_map(
  .x = list.files(path = R_processing_results_dir_2, pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_intercluster_subtype_(.*)_scaled.genepro") %>% gsub(pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_intercluster_subtype_(.*)_scaled.genepro", replacement = "\\1") %>% .[. != "NA"],
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list.files(path = R_processing_results_dir_2, pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*).genepro") %>% gsub(pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_som_cluster_(.*).genepro", replacement = "\\1") %>% .[. != "NA"] %>% .[1]
    ###########
    
    tibble_clusterone_result <- read.delim(paste(R_processing_results_dir_2, "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_intercluster_subtype_", a1, "_scaled.csv", sep = ""), sep = ",", header = TRUE, row.names = NULL) %>% as_tibble %>% 
      dplyr::filter(P.value <= 0.05 & Size >= 25)

    return(tibble_clusterone_result)
    
  }, .progress = TRUE ) %>% set_names(nm = list.files(path = R_processing_results_dir_2, pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_intercluster_subtype_(.*)_scaled.genepro") %>% gsub(pattern = "fastGCN_clusterONE_PSIsigma_intersection1_min10_penalty2_haircut0.1_single_match_overlap0.8_seedeverynode_intercluster_subtype_(.*)_scaled.genepro", replacement = "\\1") %>% .[. != "NA"] )

```

##### analysis point: characteristic modules for each subtype for each cell type

```{r}

# THE DATA ###
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "UMAP_consensus_som_clusterone_total_RNA_psisigma_replicates_pooled_replicates_with_na_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

tibble_chucked_out_items_UMAP <- data.table::fread(paste(R_processing_results_dir_2, "tibble_chucked_out_items_UMAP_consensus_som_clusterONE_all_data.txt", sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% .[.$condition_names %>% is.na != TRUE, ]

vector_chucked_out_sample_names <- paste("chucked_out_RNA_number_", tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$RNA_number %>% unique) %>% unlist, sep = "")

tibble_mapping_condition_names_RNA_number_to_cluster_name <- dplyr::bind_rows(
  # chucked out items
  tibble("cluster_name" = vector_chucked_out_sample_names, 
         "RNA_number" = vector_chucked_out_sample_names %>% gsub(pattern = "chucked\\_out\\_RNA\\_number\\_", replacement = "") ) %>% mutate_all(as.character) %>% dplyr::left_join(., tibble_chucked_out_items_UMAP[, c("RNA_number", "condition_names")] %>% mutate_all(as.character)) %>% (function(x) {x[x$cluster_name %>% duplicated, "cluster_name"] <- paste(x[x$cluster_name %>% duplicated, ] %>% .$cluster_name, "_2", sep = "") ; return(x)} ) %>% mutate_all(as.character),
  tibble_processed_UMAP_cluster_legend[, c("cluster_number", "RNA_number", "condition_names")] %>% dplyr::mutate("cluster_name" = paste("no_", `cluster_number`, sep = "")) %>% mutate_all(as.character)
  ) %>% type_convert

list_condition_names_of_cell_or_tissue_types_in_multiple_clusters <- list(
  "fibroblasts" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "fibroblast", ignore.case = TRUE, useBytes = TRUE), ],
  "MSCs" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "mesenchymal", ignore.case = TRUE, useBytes = TRUE), ],
  "smooth_muscle" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "smooth muscle", ignore.case = TRUE, useBytes = TRUE), ],
  "epithelial_cells" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "epithelial", ignore.case = TRUE, useBytes = TRUE), ],
  "T-ALL" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "T\\-ALL", ignore.case = TRUE, useBytes = TRUE), ],
  "neuroblastoma" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "neuroblastoma", ignore.case = TRUE, useBytes = TRUE), ],
  "ovarian_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "ovarian cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "breast_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "breast cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "cns_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "CNS cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "NSC_lung_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "non\\-small cell", ignore.case = TRUE, useBytes = TRUE), ],
  "prostate_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "prostate cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "renal_cancer" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Biological_source, pattern = "renal cancer", ignore.case = TRUE, useBytes = TRUE), ],
  "keratinocyte" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "keratinocyte", ignore.case = TRUE, useBytes = TRUE), ],
  "astrocyte" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "astrocyte", ignore.case = TRUE, useBytes = TRUE), ],
  "macrophage" = tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "macrophage", ignore.case = TRUE, useBytes = TRUE), ]
) %>% 
  purrr::map(.f = ~.x %>% dplyr::group_split(som_cluster))

# retrieve the sample number order for x-axis

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 4)))

list_absolute_psi_table_split_by_sample_subtype <- furrr::future_map(.x = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters %>% purrr::map(.f = ~.x %>% rbindlist %>% .$condition_names), .f = ~wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% tibble::add_column("id" = 1:nrow(.), .before = 1) %>% dplyr::select(id, contains("absolute.psi")) %>% .[, gsub(x = colnames(.), pattern = "\\_absolute\\.psi", replacement = "") %in% c(.x, "id")] %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ], .progress = TRUE) %>% 
  set_names(nm = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters %>% names)

list_sample_numbers_for_each_cluster_ordered_by_subtype <- list_condition_names_of_cell_or_tissue_types_in_multiple_clusters %>%
  purrr::map(.f = ~.x %>% rbindlist %>% .$cluster_number)

# also write sample number legend
write.table(x = purrr::map2(
  .x = list_condition_names_of_cell_or_tissue_types_in_multiple_clusters,
  .y = names(list_condition_names_of_cell_or_tissue_types_in_multiple_clusters), 
  .f = ~.x %>% rbindlist %>% tibble::add_column("cell_type" = .y)) %>% rbindlist %>% as_tibble, file = paste(R_processing_results_dir, "fastGCN_clusterONE_module_lineplot_intercluster_variable_LIS_sample_number_legend.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

cell_types_of_clusterone_result_list <- names(list_fastGCN_clusterone_tibbles_subtypes_between_clusters)

cell_types_of_cell_type_order_list <- names(list_sample_numbers_for_each_cluster_ordered_by_subtype)

cell_types_of_abs_psi_table <- names(list_absolute_psi_table_split_by_sample_subtype)

vector_clusters_in_common <- intersect(cell_types_of_clusterone_result_list, cell_types_of_cell_type_order_list) %>%
  intersect(., cell_types_of_abs_psi_table)

plan(list(tweak(multiprocess, workers = 20),
          tweak(multiprocess, workers = 2)))

furrr::future_pmap(
  .l = list(
    "a1" = list_fastGCN_clusterone_tibbles_subtypes_between_clusters[cell_types_of_clusterone_result_list %in% vector_clusters_in_common] %>% .[order(cell_types_of_clusterone_result_list[(cell_types_of_clusterone_result_list %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a2" = list_sample_numbers_for_each_cluster_ordered_by_subtype[cell_types_of_cell_type_order_list %in% vector_clusters_in_common] %>% .[order(cell_types_of_cell_type_order_list[(cell_types_of_cell_type_order_list %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a3" = list_absolute_psi_table_split_by_sample_subtype[cell_types_of_abs_psi_table %in% vector_clusters_in_common] %>% .[order(cell_types_of_abs_psi_table[(cell_types_of_abs_psi_table %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a4" = vector_clusters_in_common
  ),
  .f = function(a1, a2, a3, a4) {
    
    # DEBUG ###
    # a1 <- list_fastGCN_clusterone_tibbles_subtypes_between_clusters[cell_types_of_clusterone_result_list %in% vector_clusters_in_common] %>% .[[4]]
    # a2 <- list_sample_numbers_for_each_cluster_ordered_by_subtype[cell_types_of_cell_type_order_list %in% vector_clusters_in_common] %>% .[[4]]
    # a3 <- list_absolute_psi_table_split_by_sample_subtype[cell_types_of_abs_psi_table %in% vector_clusters_in_common] %>% .[[4]]
    # a4 <- vector_clusters_in_common
    ###########
    
    tibble_absolute_psi_rearranged <- a3 %>% 
      (function(x) {
        
        tibble_result <- x
        
        vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
        vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "")
        
        colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% gsub(pattern = "no\\_", replacement = "") %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
        
        return(tibble_result)
        
          } )
    
    tibble_absolute_psi_rearranged <- tibble_absolute_psi_rearranged[, c("id", a2)]
    
    # require that the PSI range must be at least 15
    vector_rowwise_PSI_range <- apply(X = tibble_absolute_psi_rearranged %>% dplyr::select(-id), MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit) - min(X %>% na.omit))} )
    
    tibble_absolute_psi_rearranged_scaled <- tibble_absolute_psi_rearranged[which(vector_rowwise_PSI_range >= 15), ]
    
    tibble_absolute_psi_rearranged_scaled[, 2:length(tibble_absolute_psi_rearranged_scaled)] <- tibble_absolute_psi_rearranged_scaled %>% as.data.frame %>% dplyr::select(-id) %>% genescale(m = ., axis = 1, method = "Z") %>% as_tibble
    
    # construct graphing tibble
    long_tibble_cluster_LIS_ID_psi <- a1 %>% 
      dplyr::rename("WGCNA_cluster" = Cluster) %>%
      group_by(WGCNA_cluster) %>%
      dplyr::summarise(id = Members %>% strsplit(split = " ") %>% unlist) %>%
      type_convert %>%
      dplyr::inner_join(., tibble_absolute_psi_rearranged_scaled %>% reshape2::melt(id.vars = "id", value.name = "psi", variable.name = "sample_number") %>% as_tibble %>% mutate_at(.vars = "id", as.double))
    
    long_tibble_cluster_LIS_ID_psi_average.line <- long_tibble_cluster_LIS_ID_psi %>%
      dplyr::group_by(WGCNA_cluster, sample_number) %>%
      dplyr::summarise(avg_psi = mean(psi))
    
    ggplot() +
      geom_line(data = long_tibble_cluster_LIS_ID_psi, aes(x = sample_number, y = psi, group = id), alpha = 0.1) +
      geom_line(data = long_tibble_cluster_LIS_ID_psi_average.line, aes(x = sample_number, y = avg_psi, group = WGCNA_cluster), colour = "red") +
      
      scale_colour_manual(values = c("black")) +
      # facet_grid(quotient_facet.y ~ remainder_facet.x) +
      facet_wrap(~ WGCNA_cluster, scales = 'free') +
      scale_x_discrete(limits = a2 %>% as.character, labels = a2 %>% as.character) +
      xlab("UMAP sample number") +
      ylab("PSI") +
      # guides(colour = FALSE) +
      theme_bw() +
      theme(text = element_text(family = "Helvetica", size = 3)) +
      # axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), 
      ggsave(filename = paste(R_processing_results_dir, "fastGCN_clusterONE_module_lineplot_intercluster_variable_LIS_", a4, ".pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 50, units = "cm") 
    
    # +
    #   ggsave(filename = paste(R_processing_results_dir, OB_xdim, "x", OB_ydim, "_SOM_", length(wide_tibble_of_final_SOM_summary_5_by_5_OBseries$ensembl_gene_id %>% unique), "_genes_expr_OB_diff_qvalue0.01_fc2.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 50, units = "cm")
    
    write.table(x = long_tibble_cluster_LIS_ID_psi, file = paste(R_processing_results_dir, "fastGCN_clusterONE_module_lineplot_intercluster_variable_LIS_", a4, ".txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
    
  }, .progress = TRUE )

tibble_merged_non_IR_and_IR_annotations_summarised <- data.table::fread(file = paste(R_processing_results_dir, "tibble_merged_non_IR_and_IR_annotations_summarised.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

tibble_poison_exon_finder_summary <- data.table::fread(file = paste(R_processing_results_dir, "tibble_poison_exon_finder_summary.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE, na.strings = c("NA", "N/A", "na")) %>% as_tibble

plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 16)))

list_fastGCN_modules_subtypes_across_clusters_annotated <- furrr::future_pmap(
  .l = list(
    "a1" = list_fastGCN_clusterone_tibbles_subtypes_between_clusters[cell_types_of_clusterone_result_list %in% vector_clusters_in_common] %>% .[order(cell_types_of_clusterone_result_list[(cell_types_of_clusterone_result_list %in% vector_clusters_in_common)], vector_clusters_in_common)],
    "a4" = vector_clusters_in_common
  ),
  .f = function(a1, a4) {
    
    # DEBUG ###
    # a1 <- list_fastGCN_clusterone_tibbles_subtypes_between_clusters[cell_types_of_clusterone_result_list %in% vector_clusters_in_common] %>% .[order(cell_types_of_clusterone_result_list[(cell_types_of_clusterone_result_list %in% vector_clusters_in_common)], vector_clusters_in_common)] %>% .[[4]]
    # a4 <- vector_clusters_in_common %>% .[[4]]
    ###########
    
    furrr::future_map(
      .x = a1$Members %>% strsplit(split = " "),
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1$Members %>% strsplit(split = " ") %>% .[[1]]
        ###########
        
        tibble_annotated_module <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% tibble::add_column("id" = 1:nrow(.), .before = 1) %>% .[.$id %in% b1, ]
        
        tibble_annotated_module_with_consequences <- tibble_annotated_module %>% 
          dplyr::left_join(., tibble_merged_non_IR_and_IR_annotations_summarised) %>%
          dplyr::left_join(., tibble_poison_exon_finder_summary)
        
        return(tibble_annotated_module_with_consequences)
        
      } ) %>% set_names(nm = a1$Cluster %>% as.character) %>% return
    
  }, .progress = TRUE ) %>% set_names(nm = vector_clusters_in_common)

# GO enrichment
plan(list(tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 16),
          tweak(multiprocess, workers = 3)))

load(paste(shared_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

list_fastGCN_modules_subtypes_across_clusters_hypergo <- furrr::future_pmap(
  .l = list(
    "a1" = list_fastGCN_modules_subtypes_across_clusters_annotated,
    "a2" = names(list_fastGCN_modules_subtypes_across_clusters_annotated)
  ),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_fastGCN_modules_subtypes_across_clusters_annotated[[1]]
    # a2 <- names(list_fastGCN_modules_subtypes_across_clusters_annotated) %>% .[[1]]
    ###########
    
    furrr::future_map2(
      .x = a1,
      .y = names(a1),
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- a1[[1]]
        # b2 <- names(a1) %>% .[[1]]
        ###########
        
        tibble_hypergo_result <- furrr::future_map(.x = c("BP", "MF", "CC"), .f = ~GOHyperGAll(catdb = catdb, gocat = .x, Nannot = 2, sample = b1$matched_gene_names %>% strsplit(split = "\\;") %>% unlist) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble) %>% rbindlist %>% as_tibble %>% dplyr::filter(Padj <= 0.05) %>% tibble::add_column("WGCNA_cluster" = b2, .before = 1)
        
        return(tibble_hypergo_result)
        
      } ) %>% rbindlist(fill = TRUE) %>% tibble::add_column("cell_type" = a2, .before = 1) %>% return
    
  }, .progress = TRUE ) %>% rbindlist(fill = TRUE) %>% as_tibble 




```

# ML/classification

## Trying to create my own thing

we attempt to create an adaptive classifier that is constantly learning new things

```{r}

# we test with some samples from the Atlas. Let's try endothelial cells, epithelial cells and fibroblast. we withhold some samples for validation
list_training_sample_numbers <- list(
  "ECs" = c(19, 20, 24, 41, 59, 62, 67, 171, 172, 180, 226, 241, 242, 243, 246, 247, 269, 270, 271),
  "epithelial_cells_som_cluster_6" = c(27, 28, 40, 46, 50, 60, 68, 71, 73, 74, 121, 122, 135, 139, 146, 176, 227, 244, 274, 275),
  "fibroblasts" = c(33, 42, 47, 48, 51, 52, 57, 58, 61, 64, 66, 173, 174, 177, 178, 199, 203, 220, 221, 228, 239, 240, 272, 273)
)

list_witheld_sample_numbers <- list(
  "ECs" = c(23, 181, 223, 268),
  "epithelial_cells_som_cluster_6" = c(45, 72, 287, 288),
  "fibroblasts" = c(69, 229, 245)
)

tibble_chucked_out_items_UMAP <- data.table::fread(paste(R_processing_results_dir, "tibble_chucked_out_items_UMAP_consensus_som_clusterONE_all_data.txt", sep = ""), sep = "\t", header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% .[.$condition_names %>% is.na != TRUE, ]

vector_chucked_out_sample_names <- paste("chucked_out_RNA_number_", tibble_chucked_out_items_UMAP %>% dplyr::group_split(RNA_number) %>% purrr::map(~.x$RNA_number %>% unique) %>% unlist, sep = "")

tibble_mapping_condition_names_RNA_number_to_cluster_name <- dplyr::bind_rows(
  # chucked out items
  tibble("cluster_name" = vector_chucked_out_sample_names, 
         "RNA_number" = vector_chucked_out_sample_names %>% gsub(pattern = "chucked\\_out\\_RNA\\_number\\_", replacement = "") ) %>% mutate_all(as.character) %>% dplyr::left_join(., tibble_chucked_out_items_UMAP[, c("RNA_number", "condition_names")] %>% mutate_all(as.character)) %>% (function(x) {x[x$cluster_name %>% duplicated, "cluster_name"] <- paste(x[x$cluster_name %>% duplicated, ] %>% .$cluster_name, "_2", sep = "") ; return(x)} ) %>% mutate_all(as.character),
  tibble_processed_UMAP_cluster_legend[, c("cluster_number", "RNA_number", "condition_names")] %>% dplyr::mutate("cluster_name" = paste("no_", `cluster_number`, sep = "")) %>% mutate_all(as.character)
  ) %>% type_convert

tibble_absolute_psi_group_number_as_columns <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% 
  tibble::add_column("id" = 1:nrow(.), .before = 1) %>% 
  dplyr::select(id, contains("absolute.psi")) %>% 
  (function(x) {
        
        tibble_result <- x
        
        vector_condition_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\1")
        vector_data_type_names_in_psi_table <- colnames(tibble_result) %>% gsub(pattern = "^(.*)(\\_numerator|\\_denominator|\\_passes\\_read\\_threshold|\\_no\\_replicates|\\_absolute\\.psi)", replacement = "\\2")
        
        colnames(tibble_result) <- paste(dplyr::left_join(vector_condition_names_in_psi_table %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_mapping_condition_names_RNA_number_to_cluster_name) %>% .$cluster_name %>% (function(x) {x[is.na(x)] <- ""; return(x)} ), vector_data_type_names_in_psi_table, sep = "")
        
        return(tibble_result)
        
      } )

tibble_absolute_psi_training <- purrr::map(
  .x = list_training_sample_numbers,
  .f = ~tibble_absolute_psi_group_number_as_columns %>% 
    dplyr::select(id, contains(paste("no_",.x, "_absolute.psi", sep = "")))
) %>% purrr::reduce(dplyr::left_join) %>% 
  dplyr::select(-id)

# .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ] %>%

tibble_processed_UMAP_cluster_legend[grep(x = tibble_processed_UMAP_cluster_legend$Description, pattern = "fibroblast", ignore.case = TRUE), ] %>% .$cluster_number %>% paste(collapse = ", ")

```

### training

```{r}

matrix_initial_M <- data.frame(
  "EC" = tibble_absolute_psi_training$no_19_absolute.psi,
  "epithelial" = tibble_absolute_psi_training$no_27_absolute.psi,
  "fibroblast" = tibble_absolute_psi_training$no_33_absolute.psi) %>% as.matrix

vector_input <- tibble_absolute_psi_training$no_20_absolute.psi

matrix_input_expanded <- matrix(data = rep(vector_input, times = ncol(matrix_initial_M)), nrow = tibble_absolute_psi_training$no_20_absolute.psi %>% length)

matrix_square_euclidean_distances <- (matrix_initial_M - matrix_input_expanded) * (matrix_initial_M - matrix_input_expanded)

vector_correlation_weights <- matrix_square_euclidean_distances %>% colSums()

output_choice <- vector_correlation_weights[vector_correlation_weights == min(vector_correlation_weights)] %>% names

choice_is_correct_or_not <- readline(prompt = paste("I think this is: ", output_choice, ". Is this correct? (Y/N)", sep = ""))

if (choice_is_correct_or_not == "Y") {
  
  break()
  
} else if (choice_is_correct_or_not == "N") {
  
  is_subtype <- readline(prompt = paste("Is this sample meant to be a subtype? (Y/N)", sep = ""))
  
  if (is_subtype == "Y") {
    
    
    
  } else if (is_subtype == "N") {
    
    
    
  }
  
}

```

## export for sklearn

```{r}

# THE DATA ###
wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ <- data.table::fread(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ_dezeroed.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE) %>% as_tibble

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_filtered_SJ

wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")][is.na(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering[, grep(x = wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% colnames, pattern = "absolute.psi")])] <- 0

# get column indices for each sample type because we are going to looop through each of them
list_vector_column_subsetting_indices <- purrr::map(
  .x = c("tissue", "cell type", "cell line"), 
  .f = ~which(gsub(x = colnames(wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi"))), pattern = "_absolute\\.psi", replacement = "") %in% (tibble_combined_mapping_info[grep(x = tibble_combined_mapping_info$Type, pattern = .x), ] %>% .$condition_names))
  ) %>% set_names(nm = c("tissue", "cell type", "cell line"))

tibble_processed_UMAP_cluster_legend <- read.delim(file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_umap_consensus_som_clusterone_with_na_plotly_all_data_cluster_legend_annotated.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% 
  as_tibble

plan(list(tweak(multiprocess, workers = 6),
          tweak(multiprocess, workers = 6),
          tweak(multiprocess, workers = 3)))

furrr::future_map2(
  .x = list_vector_column_subsetting_indices,
  .y = names(list_vector_column_subsetting_indices),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_vector_column_subsetting_indices[[1]]
    # a2 <- names(list_vector_column_subsetting_indices) %>% .[[1]]
    ###########
    
    tibble_subset_by_sample_type <- wide_tibble_processed_sorted_tibbles_with_LIV_info_filtered_for_at_least_5_in_any_with_dexseq_ids_for_clustering %>% dplyr::select(contains("absolute.psi")) %>% .[, a1] %>% .[future_apply(X = ., MARGIN = 1, FUN = function(X) {(which(X == 0) %>% length) < (length(X) - 1) } ), ] %>% t %>% as_tibble(rownames = "rowname") %>% tibble::add_column("Class" = dplyr::left_join(.$rowname %>% gsub(pattern = "\\_absolute\\.psi", replacement = "") %>% tibble::enframe(name = NULL, value = "condition_names"), tibble_processed_UMAP_cluster_legend) %>% .$som_cluster, .before = 1) %>% .[!is.na(.$Class), ] %>% dplyr::select(-rowname)
    
    data.table::fwrite(x = tibble_subset_by_sample_type %>% dplyr::select(-Class) , file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_tibble_abs_psi_", a2, "_prep_for_sklearn.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    
    data.table::fwrite(x = tibble_subset_by_sample_type[, "Class"] , file = paste(R_processing_results_dir, "atlas_totalrna_psisigma_vector_class_labels_", a2, "_prep_for_sklearn.txt", sep = ""), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    # %>% tibble::add_column("id" = 1:nrow(.), .before = 1)
    
  }, .progress = TRUE )

```

