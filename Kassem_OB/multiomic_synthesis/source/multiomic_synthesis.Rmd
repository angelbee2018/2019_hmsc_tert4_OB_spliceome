---
title: "Multiomic Synthesis - Phospho-proteo-spliceome project"
author: "Angel Liang"
date: "16/04/2020"
output: html_document
---

# Set the running environment

## Packages and directories

```{r}

library(tidyverse)
library(gtools)
library(extrafont)
# font_import(paths = "~/.local/share/fonts/")
loadfonts(device = "pdf")
# windowsFonts("Helvetica" = windowsFont("Helvetica"))
library(RColorBrewer)

library(genefilter)

library(ggplot2)
library(ggpattern)
library(plotly)

library(kohonen)
library(genefilter)
# library(gplots)
# library(lattice)
library(svglite)
library(scales)
library(furrr)
options(future.globals.maxSize = 30000000000, future.fork.enable = TRUE)
plan(multicore)
memory.limit(100000)
library(data.table)

library(crayon)
library(VennDiagram)

library(biomaRt)
httr::set_config(httr::config(ssl_verifypeer = FALSE))
ensembl_mart = useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host = "http://sep2019.archive.ensembl.org")
library(systemPipeR)
library(GOstats)
library(PFAM.db)
# library(bc3net)

# library(ComplexHeatmap)

library(ggdendro)
library(data.table)
# library(Rfast)

source("/mnt/LTS/tools/angel_suite/source/main_source.R")

reference_data_dir <- "/mnt/LTS/reference_data/"

# results_dir <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/multiomic_synthesis/results/"
results_dir <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/multiomic_synthesis/results/"
# results_dir <- "/media/angel/seagate_500/"

ucsc_hg19_to_hg38_chainfile_path <- "/mnt/LTS/reference_data/hg38_ensembl_reference/hg19ToHg38.over.chain"

nmd_classifier_dir <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_NMD_classifier/results/"

# results_directory_figures <- paste(results_dir, "figures/", sep="")
# 
# if(! dir.exists(results_directory_figures) ) {
#      dir.create(results_directory_figures, recursive = TRUE)}

# ensembl gene_nane gene_stable_id and transcript_stable_id mapping
tibble_ensembl_gene_name_transcript_stable_id_mapping <- read.delim(file = paste(reference_data_dir, "table_ensembl_gene_name_transcript_stable_id_mapping.txt", sep = ""), header = TRUE, row.names = NULL, check.names = FALSE, stringsAsFactors = FALSE) %>% as_tibble

vector_OBseries_timepoints_raw <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")
vector_OBseries_timepoints_edited <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

vector_2023_ont_timepoints_edited <- c("MSC", "6h", "1d", "3d", "9d", "12d")

# import the reference and recon GTFs with first/last exon information as well as flaggged NMD info.
# tibble_ref_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf_exon.only_with_first.last.gtf") %>% as_tibble
# tibble_recon_gtf <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/alltimepoints_denovo_reconstructed_stringtiemerged_exon.only_with_first.last_NMD_E4.gtf") %>% as_tibble

# tibble_ref_gtf_with_NMD_flagged <- rtracklayer::import("/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E2.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E2 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E2.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E3 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E3.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E4 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E4.gtf") %>% as_tibble
# tibble_ref_gtf_with_NMD_flagged_E5 <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMDflagger_qualitycheck_E5.gtf") %>% as_tibble

```

## generating enrichment catalog of PFAM protein families

```{r}

# PROTEINFAMILY
# polyA_RNAseq_background_pfam <- getBM(filters = "biotype", values = c("protein_coding", "long_noncoding", "transcribed_processed_gene", "transcribed_unitary_gene", "transcribed_unprocessed_gene", "translated_processed_gene"), attributes = c("external_gene_name", "pfam"), mart = ensembl_mart) %>% .[.$pfam != "",]

# obtain description(definition, DE) for each PFAM ID

# PFAM_all_descriptions <- as.data.frame(PFAMDE[mappedkeys(PFAMDE)]) %>% setNames(., c("pfam", "family_description"))

# polyA_RNAseq_background_pfam <- dplyr::left_join(polyA_RNAseq_background_pfam, PFAM_all_descriptions, by = "pfam")

# polyA_RNAseq_background_pfam[, "family_description"] <- as.character(polyA_RNAseq_background_pfam[, "family_description"])

# write.table(x = polyA_RNAseq_background_pfam, file = paste(results_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), quote = FALSE, row.names = FALSE, col.names = FALSE, sep = "\t")

polyA_RNAseq_background_pfam <- read.delim(file = paste(reference_data_dir, "polyA_RNAseq_GO_background_PROTEINFAMILY.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, row.names = NULL, check.names = FALSE) %>% setNames(c("external_gene_name", "family_accession", "family_description"))

# create list of gene UNIVERSE

reference_geneset_universe <- polyA_RNAseq_background_pfam$external_gene_name

# create list containing collections of genes under their according family descriptions

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam

polyA_RNAseq_background_pfam_2 <- polyA_RNAseq_background_pfam_2[, names(polyA_RNAseq_background_pfam_2) != "pfam"]

list_of_pfam_descriptions <- polyA_RNAseq_background_pfam_2$family_description %>% unique %>% as.list

list_of_pfam_gene_family_categories <- purrr::map(.x = list_of_pfam_descriptions, .f = ~as.list(polyA_RNAseq_background_pfam[polyA_RNAseq_background_pfam$family_description == .x, "external_gene_name"]))

names(list_of_pfam_gene_family_categories) <- list_of_pfam_descriptions

list_of_pfam_gene_family_categories <- list_of_pfam_gene_family_categories %>% purrr::map(~unlist(.x))

```

# Import files

## RNA expression section

### define functions

```{r}

## END filteratleast_x_reads_in_anytimepoint

average_counts_from_triplicate <- function(input_matrix, no_annotation_cols) {
  
input_matrix <- input_matrix %>% as_tibble

a <- seq(from = 1 + no_annotation_cols, to = (input_matrix %>% ncol) - 3 + 1, by = 3)
b <- seq(from = 3 + no_annotation_cols, to = input_matrix %>% ncol, by = 3)
c <- purrr::map2(a, b, ~.x:.y)

# generate logical tests for each partition each row. does each timepoint have at least 5 junction reads in all replicates?
d <- purrr::map(.x = c, .f = ~input_matrix[, .x])

e <- purrr::map(.x = d, .f = ~apply(.x, 1, FUN = mean) %>% as_tibble %>% setNames(gsub(x = colnames(.x), pattern = "(.*)(_r[1-3])", replacement = "\\1_avg") %>% unique))

f <- purrr::reduce(e, bind_cols) %>% as_tibble

output_matrix <- bind_cols(input_matrix[, 1:no_annotation_cols], f)

return(output_matrix)

}

## END average_counts_from_triplicate

```

### import expression tables of DE genes

```{r}

logCPM_OBseries_anysig_DEGs_dir <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_RSEM/run_1_original/R_processing_results/table_edgeR_GLM_DEGs_logCPM.txt"

logCPM_OBseries_anysig_DEGs_import <- read.delim(file = paste(logCPM_OBseries_anysig_DEGs_dir), sep = "\t", header = TRUE, stringsAsFactors = FALSE, row.names = NULL, na.strings = c("NONE", "NA", "INF", "Inf")) %>% as_tibble

# load(file = paste(results_dir, "ENSG_to_genesymbol_DEGs.dataframe", sep = ""))

# ENSG_to_genesymbol_DEGs <- getBM(filters = "ensembl_gene_id", values = logCPM_OBseries_anysig_DEGs_import$ensembl_gene_id, attributes = c("ensembl_gene_id", "external_gene_name"), mart = ensembl_mart)

# append official gene symbol to the DEG table and average the counts
logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs_import %>% average_counts_from_triplicate(., no_annotation_cols = 2)

```

## JUM/PSI-Sigma/MAJIQ section

### set global vars.

```{r}

vector_OBseries_timepoints_raw <- c("ud", "6h", "12h", "24h", "3d", "6d", "9d", "12d")
vector_OBseries_timepoints_edited <- c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

UNION_junc_coor_path <- "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/JUM_diff/UNION_junc_coor_with_junction_ID_more_than_5_read_in_at_least_3_samples.txt"

tibble_RSEM_edgeR_DEGs_all_GO <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_RSEM/run_1_original/R_processing_results/table_hypergoresult_allDEGs_allGO.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

### Import differential/constitutive/all detected tables

```{r}

# JUM ###
# tibble_JUM_5x5_som_clustered <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/5x5_SOM_869_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_5x5_som_clustered <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/5x5_SOM_869_junctions_PSI_OB_diff_any_qvalue0.01_any_deltaPSI_greaterthan_0.15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_906_differential_VSRs_qvalue0.01_dPSI0.15_timeseries_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_scaled_PSI_timeseries_wide <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_869_differential_VSRs_qvalue0.01_dPSI0.15_timeseries_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

load("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_tibble_of_all_detailed_tables_with_na.tibble")

# tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_983_differential_VSRs_qvalue0.01_dPSI0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_983_differential_VSRs_qvalue0.01_dPSI0.15_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# fill in the missing sub_junc_coor for cassette and IR events
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\5") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\3") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::mutate("AS_event_chr" = gsub(x = AS_event_ID, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_(.*)$", replacement = "\\1"))

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_330_differential_VSRs_qvalue0.01_dPSI0.15_with_na_ud.6h.1d_only.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, na.strings = c("NA", "n/a", "", "na")) %>% as_tibble
# fill in the missing sub_junc_coor for cassette and IR events
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\5") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\3") %>% type.convert
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only %>% dplyr::mutate("AS_event_chr" = gsub(x = AS_event_ID, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_(.*)$", replacement = "\\1"))

# tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_7855_constitutive_VSRs_dPSI_OB_diff_qvalue0.01_dPSI0.15_no_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_7913_constitutive_VSRs_dPSI_OB_diff_qvalue0.01_dPSI0.15_no_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# fill in the missing sub_junc_coor for cassette and IR events
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "cassette_exon_events", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\5") %>% type.convert

tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "sub_junction_start_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\3") %>% type.convert
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "sub_junction_end_coor"] <- gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode == "intron_retention", "AS_event_ID"] %>% unlist, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_([^\\_]+)\\_([^\\_]+)$", replacement = "\\4") %>% type.convert

tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na <- tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::mutate("AS_event_chr" = gsub(x = AS_event_ID, pattern = "^([^\\_]+)\\_(\\+|\\-)\\_(.*)$", replacement = "\\1"))

# tibble_JUM_all_junctions_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_all_JUM_results_13137_VSRs_with_na_annotated.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_all_junctions_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/wide_table_of_all_JUM_results_13137_VSRs_with_na_annotated.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# PSI-Sigma ###
# tibble_PSIsigma_5x5_som_clustered <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/5x5_SOM_1368_exons_LIV.PSI_OB_diff_any_DEXSeq_padj0.01_any_deltaPSI_greaterthan_15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_5x5_som_clustered <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/5x5_SOM_1368_exons_LIV.PSI_OB_diff_any_DEXSeq_padj0.01_any_deltaPSI_greaterthan_15_wide.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_1368LIVs_scaled.PSI_OB_diff.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_scaled_PSI_timeseries_wide <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_1368LIVs_scaled.PSI_OB_diff.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_ud.6h.1d_only <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/wide_table_of_43LIVs_scaled.PSI_OB_diff_MSC_6h_1d.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, na.strings = c("NA", "n/a", "", "na")) %>% as_tibble

# tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_table_of_all_constitutive_LIV7532_dpsi15_DEXSeq_padj0.01.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_table_of_all_constitutive_LIV7532_dpsi15_DEXSeq_padj0.01.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# tibble_PSIsigma_all_exons_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_DEXSeq_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_all_exons_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_DEXSeq_results.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# MAJIQ ###
tibble_majiq_5x5_som_clustered <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_wide_tibble_5x5_initial_som.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_majiq_scaled_PSI_timeseries_wide <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_tibble_matrix_psi_differential_scaled.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_majiq_differential_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_wide_tibble_dpsi_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_majiq_differential_with_na_0.8 <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_wide_tibble_dpsi_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_majiq_differential_with_na_0.95 <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.95_cons0.95_wide_tibble_dpsi_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_majiq_constitutive <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_wide_tibble_dpsi_constitutive.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_majiq_differential_dpsi0.10_pvalue0.01_with_na_ud.6h.1d_only <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_wide_tibble_5x5_initial_som.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, na.strings = c("NA", "n/a", "", "na")) %>% as_tibble

# tibble_majiq_constitutive_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_wide_tibble_5x5_initial_som.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_majiq_all_lsvs_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_wide_tibble_psi.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

### Import gene ontology enrichment tables

```{r}

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/Top inf significantly over-represented GO terms for OB series dPSI_0.15_anyqvalue0.01_915_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/Top inf significantly over-represented families for OB series dPSI_0.15_anyqvalue0.01_915_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_GOterms_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_PFAM_families_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_majiq_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_tibble_hypergo_result_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

# tibble_majiq_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/top_inf_PFAM_families_OB_series_dPSI_15_anyDEXSeq_padj0.01_1137_genes_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

```

### Import junction/exon ontology supporting info

```{r}

# JUM ###
# tibble_JUM_junction_ontology_supp_info <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# PSI-Sigma ###
# tibble_PSIsigma_exon_ontology_supp_info <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/R_processing_results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# JUM ###
tibble_JUM_junction_ontology_supp_info <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_supp_info <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_supporting_info_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# majiq ###
tibble_majiq_junction_ontology_supp_info <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_table_junction_ontology_supporting_info.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_PSIsigma_exon_ontology_unmatched_items <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_unmatched_exons_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

```

### Import junction/exon ontology tables

```{r}

# JUM ###
# tibble_JUM_junction_ontology_transcripts <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_junction_ontology_biomart <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_JUM_junction_ontology_PTM <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# PSI-Sigma ###
# tibble_PSIsigma_exon_ontology_transcripts <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_exon_ontology_biomart <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_PSIsigma_exon_ontology_PTMs <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# JUM ###
tibble_JUM_junction_ontology_transcripts <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_biomart <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_JUM_junction_ontology_PTMs <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/table_junction_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_JUM_junction_ontology_biomart_plots <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/tally_overlapping_interpro_domains_differential_junctions_0.15_qvalue0.01_468_VSRs_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_JUM" = "genes", "tally_JUM" = "tally")
tibble_JUM_junction_ontology_PTMs_plots <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_JUM/run_2_PGNEXUS_OBseries_readlength100/R_processing_results/tally_overlapping_PTMs_differential_0.15_qvalue0.01_468_VSRs_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_JUM" = "tally")

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_transcripts <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_transcript_features_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_biomart <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_biomart_domains_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_PSIsigma_exon_ontology_PTMs <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/table_exon_ontology_matched_PTMs_all_differential.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_PSIsigma_exon_ontology_biomart_plots <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/tally_overlapping_interpro_domains_differential_exons_15_DEXSeq_padj0.01_617_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_PSIsigma" = "genes", "tally_PSIsigma" = "tally")
tibble_PSIsigma_exon_ontology_PTMs_plots <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/tally_overlapping_PTMs_differential_dpsi15_DEXSeq_padj0.01_617_exons_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_PSIsigma" = "tally")

# majiq ###
tibble_majiq_junction_ontology_transcripts <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_table_junction_ontology_matched_transcript_features.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_majiq_junction_ontology_biomart <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_table_junction_ontology_matched_biomart_domains.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_majiq_junction_ontology_PTMs <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_table_junction_ontology_matched_ptms.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
### plots for combining
tibble_majiq_junction_ontology_biomart_plots <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_tibble_interpro_id_tally_per_vsr.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("genes_PSIsigma" = "genes", "tally_PSIsigma" = "tally")
tibble_majiq_junction_ontology_PTMs_plots <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_majiq/R_processing_results/2019_msc_spliceome_majiq_diff0.8_cons0.8_tibble_PTM_tally.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble %>% dplyr::rename("tally_PSIsigma" = "tally")

```

## import public CLIP-Seq data and match with GTF information

### set directories

```{r}

clipseq_dir <- "/mnt/Tertiary/sharedfolder/isoform_usage_project/CLIPseq_files/"

FLASHseq_dir <- "/mnt/4tb_ironwolf/2019_FLASHseq/results/R_processing_results/"

# import chainfile
chainfile_hg19_to_hg38 <- rtracklayer::import.chain(con = ucsc_hg19_to_hg38_chainfile_path)

```

### Import coordinate level CLIP-Seq data

#### FLASH-Seq: SRSF1/2/3/4/5/6/7/9/11

```{r}

list_FLASHseq_tibbles_hg19 <- purrr::map(
  .x = list.files(path = FLASHseq_dir, pattern = paste(".*bed_annotated.*", sep = "")),
  .f = function(a1) {
    
    read.delim(paste(FLASHseq_dir, a1, sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% 
      as_tibble %>%
      dplyr::rename("chr" = "feature_chr", "start" = "feature_start", "end" = "feature_end") %>% 
      return
    
  } ) %>%
  set_names(c(
    "SRSF1 FLASH GSE118265",
    "SRSF2 FLASH GSE118265",
    "SRSF3 FLASH GSE118265",
    "SRSF4 FLASH GSE118265",
    "SRSF5 FLASH GSE118265",
    "SRSF6 FLASH GSE118265",
    "SRSF7 FLASH GSE118265",
    "SRSF9 FLASH GSE118265",
    "SRSF11 FLASH GSE118265"
  ))

# CONVERT FROM hg19 TO hg38 ###
list_FLASHseq_tibbles_hg38 <- purrr::map(
  .x = list_FLASHseq_tibbles_hg19,
  .f = ~rtracklayer::liftOver(x = .x %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% 
                                regioneR::toGRanges(),
                              chain = chainfile_hg19_to_hg38) %>%
    as_tibble %>%
    dplyr::select(-group, -group_name) %>%
    dplyr::rename("chr" = "seqnames") %>% 
    dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) )
  
```

#### SRSF2 (GSE111900)

```{r}

tibble_GSE111900_SRSF2_coord_info <- read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/GSE111900_srsf2_wt_hits.clip_coord_info.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE) %>% as_tibble

# split the genomic coords into chr start and end
tibble_peakfile_SRSF2_hits.clip_GSE111900_HEL_p0.01 <- tibble_GSE111900_SRSF2_coord_info %>% 
  dplyr::mutate("chr" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):.*", replacement = "\\1"),
                "start" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):([^\\-]+)\\-.*", replacement = "\\2"),
                "end" = gsub(x = deletion_coord_hg38, pattern = "^chr([^\\:]+):([^\\-]+)\\-(.*)", replacement = "\\3")) %>%
  dplyr::filter(clip_FDR <= 0.01)

```

#### HNRNPA1 (ENCODE)

```{r}

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA1_eclip_ENCODE.GSE91534_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### HNRNPA2B1 (GSM1716538)

```{r}

`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19_filtered` <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19.bedgraph", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "height")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>%
  dplyr::filter(height > 20)

# `tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19_raw` <- read.delim(file = paste(clipseq_dir, "binding.sites_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19.bedgraph", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
#   setNames(c("chr", "start", "end", "height")) %>%
#   dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>%

# fit <- MASS::fitdistr(`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_raw`$height, densfun = "normal")

# plot(density(`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_raw`$height))
# curve(dnorm(x, mean = fit$estimate[1], sd = fit$estimate[2]), add = TRUE, col = "red")

# pnorm(20, mean = fit$estimate[1], sd = fit$estimate[2], lower.tail = FALSE)

# CONVERT FROM hg19 TO hg38 ###
`tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg38_height20` <- rtracklayer::liftOver(x = `tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg19_filtered` %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(),
                                                                                                  chain = chainfile_hg19_to_hg38) %>%
  as_tibble %>%
  dplyr::select(-group, -group_name) %>%
  setNames(c("chr", "start", "end", "width", "strand", "height")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

```

#### MBNL1 (GSE76486)

```{r}

`tibble_bedfile_MBNL1_hits.clip_GSE76486_MDA-MB-231_hg38` <- rtracklayer::import(con = paste(clipseq_dir, "binding.sites_MBNL1_hits.clip_GSE76486_MDA-MB-231_hg19.bed", sep = "")) %>% rtracklayer::liftOver(chain = chainfile_hg19_to_hg38) %>% 
  as_tibble %>%
  dplyr::select(-group, -group_name) %>%
  setNames(c("chr", "start", "end", "width", "strand", "name", "score")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

```

#### PRPF4 (ENCODE)

```{r}

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_PRPF4_eclip_ENCODE.ENCSR977OXG_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### RBM15 (ENCODE)

```{r}

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_RBM15_eclip_ENCODE.GSE92027_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_RBM15_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_RBM15_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### SFPQ (ENCODE)

```{r}

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SFPQ_eclip_ENCODE.GSE92193_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### SUGP2 (ENCODE)

```{r}

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_SUGP2_eclip_ENCODE.GSE91826_HepG2_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw[tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### TRA2A (ENCODE)

```{r}

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M"),]

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep1.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered <- read.delim(file = paste(clipseq_dir, "binding.sites_TRA2A_eclip_ENCODE.GSE91702_K562_hg38_rep2.bed", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = FALSE, check.names = FALSE) %>% as_tibble %>% 
  setNames(c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue", "peak")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} ) %>% 
  .[.$chr %in% c(1:22, "X", "Y", "M") & .$pValue > -log10(0.01),]

# find overlapping peak regions for each replicate and keep only regions that are:
# a) commmon to both replicates
# b) significantly enriched

# rep1: regions that also occur in rep2
tibble_chr_start_end_with_overlap_rep1 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

# rep2: regions that also occur in rep1
tibble_chr_start_end_with_overlap_rep2 <- 
  dplyr::bind_rows(
    # + strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw$strand == "+", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble,
    # - strand
    regioneR::overlapRegions(
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges(), 
      tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw[tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_raw$strand == "-", c("chr", "start", "end")] %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "") %>% return} ) %>% as.data.frame %>% regioneR::toGRanges()) %>%
      as_tibble
  ) %>%
  .[, c("chr", "startA", "endA")] %>%
  setNames(c("chr", "start", "end")) %>%
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )
  
# create the final filtered tibble
tibble_bedfile_TRA2A_eclip_ENCODE_K562_combined_p0.01 <- dplyr::bind_rows(
  dplyr::semi_join(tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep1_filtered, tibble_chr_start_end_with_overlap_rep1),
  dplyr::semi_join(tibble_bedfile_TRA2A_eclip_ENCODE_K562_rep2_filtered, tibble_chr_start_end_with_overlap_rep2)
)

```

#### SNRPA (GSM4512295)

```{r}

tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19_filtered <- read.delim(paste(clipseq_dir, "peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19.csv", sep = ""), sep = ",", stringsAsFactors = FALSE, header = TRUE, check.names = FALSE) %>% 
  as_tibble %>%
  dplyr::filter(l10p > -log10(0.01))

# CONVERT FROM hg19 TO hg38 ###
# + strand
tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg38_p0.01 <- 
  dplyr::bind_rows(
    rtracklayer::liftOver(
      x = tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19_filtered %>% dplyr::filter(strand == "+") %>% dplyr::select(-strand) %>% as.data.frame %>% regioneR::toGRanges(),
      chain = chainfile_hg19_to_hg38) %>% as_tibble,
    rtracklayer::liftOver(
      x = tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg19_filtered %>% dplyr::filter(strand == "-") %>% dplyr::select(-strand) %>% as.data.frame %>% regioneR::toGRanges(),
      chain = chainfile_hg19_to_hg38) %>% as_tibble
  )  %>%
  dplyr::select(-group, -group_name) %>%
  setNames(c("chr", "start", "end", "width", "strand", "l10p", "l2fc", "geneid", "genename", "region")) %>% 
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "") %>% return} )

```

### prepare geneset categories

```{r}

# prepare enrichment categories for each upstream candidate RBP

list_of_RBP_target_gene_categories_raw <- list(
  "SRSF2 HiTS_CLiP HeLa_WT GSE111900 0.01FDR" = read.delim(paste(clipseq_dir, "SRSF2_hits.clip_GSE111900/geneset_srsf2_clip_GSE111900_WT_0.01FDR.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
                                               
  "SRSF1 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR1-SRSF1.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF2 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR5-SRSF2.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF3 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR8-SRSF3.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF4 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR9-SRSF4.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF5 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR10-SRSF5.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF6 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR11-SRSF6.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF7 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR12-SRSF7.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  # "SRSF9 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR13-SRSF9.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  "SRSF11 FLASH_seq HEK293 GSE118265 PEP0.01" = read.delim(paste(FLASHseq_dir, "pureclip_peaks_SR14-SRSF11.bed_geneset_PEP0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector,
  
  "MBNL2 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl2_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL1 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl1_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper),
  "MBNL3 HiTS_CLiP MEF GSE60487 pvalue0.01" = read.delim(paste(clipseq_dir, "MBNL1.2.3_hits.clip_GSE60487/geneset_mbnl3_hits.clip_MEF_GSE60487_pvalue0.01.txt", sep = ""), header = FALSE, stringsAsFactors = FALSE) %>% unique %>% as.vector %>% lapply(toupper)
  )

list_of_RBP_target_gene_categories <- list_of_RBP_target_gene_categories_raw %>% flatten

names(list_of_RBP_target_gene_categories) <- names(list_of_RBP_target_gene_categories_raw)

```

## scRNA-Seq section

### Import Sierra DTU test results

```{r}

# Cluster-wise, simplified
tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_clusterwise_all_simplified <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_clusterwise_DTU_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_clusterwise_all_simplified <- tibble_sierra_DTU_clusterwise_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_clusterwise_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

# Pair-wise between clusters, simplified
tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble
# tibble_sierra_DTU_pairwise_clusters_all_simplified <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_scRNAseq/R_processing_results/sierra/table_DTU_pairwise_comparison_clusters_all_simplified.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE) %>% as_tibble

tibble_sierra_DTU_pairwise_clusters_all_simplified <- tibble_sierra_DTU_pairwise_clusters_all_simplified %>% 
  add_column("chr" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\1"),
             "start" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                            pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                            replacement = "\\2"),
             "end" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                          pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                          replacement = "\\3"),
             "strand" = gsub(x = tibble_sierra_DTU_pairwise_clusters_all_simplified$gene_peak_id, 
                             pattern = "^[^\\:]+\\:([^\\:]+)\\:([0-9]+)\\-([0-9]+)\\:(.*)", 
                             replacement = "\\4")) %>%
  dplyr::mutate_at(.vars = "strand", .funs = function(x) {
    lapply(x, FUN = function(x) {
      
      if (x == "-1") {
        return("-")
      } else if (x == "1") {
        return("+")
      }
      
    } ) %>% unlist %>% return
    
  } ) %>% type_convert

```

## Ago2 iCLIP dataset

```{r}

tibble_ago2_iclip_binding_sites <- read.delim("/mnt/4tb_ironwolf/miRNA_hMSC_TERT_OB_diff/iCLIP.hg38.miRNA_targets_MSC_diff_iCLIP_binding_sites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% 
  as_tibble %>% 
  dplyr::filter(chrom != "") %>%
  dplyr::mutate_at(.vars = "chrom", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} )

# split the iclip table by chromosome
list_ago2_iclip_binding_sites_by_chr <- tibble_ago2_iclip_binding_sites %>% 
  dplyr::group_split(chrom) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$chrom %>% unique) %>% unlist)
# generate list of vectors of ago2 iCLIP binding site genome coords.
list_of_vectors_ago2_iclip_binding_site_genome_coords <- purrr::map(.x = list_ago2_iclip_binding_sites_by_chr,
                                                                    .f = ~purrr::map2(.x = .x$start,
                                                                                      .y = .x$stop,
                                                                                      .f = ~.x:.y)
)

```

## Proteome section

### Import files

```{r}

# maxquant time-series data for MSC, 6h and 1d.
# list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d
load(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/R_processing_results/list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d.Rlist")

list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d <- list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d %>% purrr::map_depth(.depth = 2, .f = ~.x %>% type_convert(na = c("NA", "n/a", "", "na")))

# import the quantitative levels 
tibble_MQ_scaled_tibbles_matched_to_geneset_per_cluster <- data.table::fread(file = paste("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/phosphoproteomic_analysis/analysis_maxquant/results/R_processing_results/", "tibble_MQ_scaled_tibbles_matched_to_geneset_per_cluster.txt", sep = ""), sep = "\t", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE) %>% tibble::as_tibble()

```

### Check NMD time series patterns against protein expression

We need to plot the correlation between protein expression and PRODUCTIVE isoform READ COUNTS

where:

productive = NMD_read_count x [(1 - psi_of_NMD)/psi_of_NMD]

have to plot against read count, not just PSI, because the expression of total mRNA can also change on top of the %NMD

```{r}

tibble_jum_psi <- dplyr::bind_rows(
  wide_tibble_of_all_detailed_tables_with_na[wide_tibble_of_all_detailed_tables_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_ud", ] %>% dplyr::select(-contains(".1"), -contains(".2"), -contains(".3"), -contains("deltaPSI"), -contains("raw_count"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")], pattern = "percentage\\_usage\\.", replacement = "") %>% (function(x) {paste("psi_", type.convert(x) - 3, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  wide_tibble_of_all_detailed_tables_with_na[grep(x = wide_tibble_of_all_detailed_tables_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_ud"), ] %>% dplyr::select(-contains(".4"), -contains(".5"), -contains(".6"), -contains("deltaPSI"), -contains("raw_count"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")], pattern = "percentage\\_usage\\.", replacement = "") %>% (function(x) {paste("psi_", x, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_ud", replacement = "\\1") %>% gsub(pattern = "24h", replacement = "1d"))
) %>%
  dplyr::mutate_all(.funs = function(x) {return(gsub(x = x, pattern = "\\%", replacement = ""))} ) %>% 
  readr::type_convert() %>%
  (function(x) {x %>% tibble::add_column("psi_avg" = x %>% dplyr::select(contains("psi")) %>% rowMeans(na.rm = TRUE) %>% unlist) %>% return}) %>%
  readr::type_convert() %>%
  dplyr::select(-matches("psi\\_\\d")) %>%
  reshape2::dcast(formula = Gene + AS_event_ID + AS_structure_ID + contributing_junctions + sub_junction_ID + chr + sub_junction_start_coor + sub_junction_end_coor + sub_junction_size + sub_junction_strand ~ comparison, value.var = "psi_avg") %>%
  as_tibble

tibble_jum_inclusion_read_counts <- dplyr::bind_rows(
  wide_tibble_of_all_detailed_tables_with_na[wide_tibble_of_all_detailed_tables_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_ud", ] %>% dplyr::select(-contains(".1"), -contains(".2"), -contains(".3"), -contains("deltaPSI"), -contains("percentage_usage"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")], pattern = "raw\\_count\\.", replacement = "") %>% (function(x) {paste("inclusion_reads_", type.convert(x) - 3, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  wide_tibble_of_all_detailed_tables_with_na[grep(x = wide_tibble_of_all_detailed_tables_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_ud"), ] %>% dplyr::select(-contains(".4"), -contains(".5"), -contains(".6"), -contains("deltaPSI"), -contains("percentage_usage"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")], pattern = "raw\\_count\\.", replacement = "") %>% (function(x) {paste("inclusion_reads_", x, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_ud", replacement = "\\1") %>% gsub(pattern = "24h", replacement = "1d"))
) %>%
  dplyr::mutate_all(.funs = function(x) {return(gsub(x = x, pattern = "\\%", replacement = ""))} ) %>% 
  readr::type_convert() %>%
  (function(x) {x %>% tibble::add_column("inclusion_reads_avg" = x %>% dplyr::select(contains("inclusion_reads")) %>% rowMeans(na.rm = TRUE) %>% unlist) %>% return}) %>%
  readr::type_convert() %>%
  dplyr::select(-matches("inclusion\\_reads\\_\\d")) %>%
  reshape2::dcast(formula = Gene + AS_event_ID + AS_structure_ID + contributing_junctions + sub_junction_ID + chr + sub_junction_start_coor + sub_junction_end_coor + sub_junction_size + sub_junction_strand ~ comparison, value.var = "inclusion_reads_avg") %>%
  as_tibble

tibble_psisigma_psi <- dplyr::bind_rows(
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_MSC", ] %>% dplyr::select(-contains("comparison.1"), -contains("numerator"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.2\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[grep(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_MSC"), ] %>% dplyr::select(-contains("comparison.2"), -contains("numerator"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.1\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_MSC", replacement = "\\1"))
) %>%
  (function(x) {x %>% tibble::add_column("psi_avg" = x %>% dplyr::select(contains("absolute.psi")) %>% rowMeans(na.rm = TRUE) %>% unlist) %>% return}) %>%
  dplyr::select(-contains("absolute.psi")) %>%
  reshape2::dcast(formula = database_ID + event_region_coords + diff_exon_coords + splicemode + matched_gene_names ~ comparison, value.var = "psi_avg") %>% 
  as_tibble

tibble_psisigma_inclusion_read_counts <- dplyr::bind_rows(
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_MSC", ] %>% dplyr::select(-contains("comparison.1"), -contains("psi"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.2\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[grep(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_MSC"), ] %>% dplyr::select(-contains("comparison.2"), -contains("psi"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.1\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_MSC", replacement = "\\1"))
) %>%
  (function(x) {x %>% tibble::add_column("numerator_avg" = x %>% dplyr::select(contains("numerator")) %>% rowMeans(na.rm = TRUE) %>% unlist) %>% return}) %>%
  dplyr::select(-matches("numerator\\_\\d")) %>%
  reshape2::dcast(formula = database_ID + event_region_coords + diff_exon_coords + splicemode + matched_gene_names ~ comparison, value.var = "numerator_avg") %>% 
  as_tibble

tibble_jum_productive_read_counts <- tibble_jum_inclusion_read_counts
tibble_jum_productive_read_counts[, vector_OBseries_timepoints_edited] <- tibble::as_tibble(tibble_jum_inclusion_read_counts[, vector_OBseries_timepoints_edited] * ((100 - tibble_jum_psi[, vector_OBseries_timepoints_edited])/tibble_jum_psi[, vector_OBseries_timepoints_edited]))

tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_with_productive_read_counts <- dplyr::left_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-vector_OBseries_timepoints_edited, -chr) %>% dplyr::rename("contributing_junctions" = "contributing_junction_IDs", "chr" = "AS_event_chr") %>% dplyr::mutate("contributing_junctions" = gsub(x = `contributing_junctions`, pattern = "\\;", replacement = ",")), tibble_jum_productive_read_counts)

tibble_psisigma_productive_read_counts <- tibble_psisigma_inclusion_read_counts
tibble_psisigma_productive_read_counts[, vector_OBseries_timepoints_edited] <- tibble::as_tibble(tibble_psisigma_inclusion_read_counts[, vector_OBseries_timepoints_edited] * ((100 - tibble_psisigma_psi[, vector_OBseries_timepoints_edited])/tibble_psisigma_psi[, vector_OBseries_timepoints_edited]))

tibble_PSIsigma_scaled_PSI_timeseries_wide_with_productive_read_counts <- dplyr::left_join(tibble_PSIsigma_scaled_PSI_timeseries_wide %>% dplyr::select(-vector_OBseries_timepoints_edited), tibble_psisigma_productive_read_counts)

tibble_jum_nmd_proteome_correlation <- tibble_MQ_scaled_tibbles_matched_to_geneset_per_cluster %>%
  .[.$type == "protein_groups", ] %>% 
  split_delimited_columns_in_table(target_colname = "Gene.names", split = "\\;") %>% dplyr::rename("Gene" = "Gene.names") %>% 
  dplyr::left_join(., tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_with_productive_read_counts %>% .[.$NMD_flagged_recon == TRUE | .$contains_PTC_ref == TRUE, c("Gene", "AS_event_ID", "chr", "sub_junction_start_coor", "sub_junction_end_coor", "strand", vector_OBseries_timepoints_edited)]) %>%
  .[!is.na(.$AS_event_ID), ] %>%
  .[apply(X = .[, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud", "MSC", "6h", "1d")], MARGIN = 1, FUN = function(X) {all(is.finite(X)) %>% return} ), ]

tibble_jum_allevents_proteome_correlation <- tibble_MQ_scaled_tibbles_matched_to_geneset_per_cluster %>%
  .[.$type == "protein_groups", ] %>% 
  split_delimited_columns_in_table(target_colname = "Gene.names", split = "\\;") %>% dplyr::rename("Gene" = "Gene.names") %>% 
  dplyr::left_join(., tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_with_productive_read_counts %>% .[, c("Gene", "AS_event_ID", "chr", "sub_junction_start_coor", "sub_junction_end_coor", "strand", vector_OBseries_timepoints_edited)]) %>%
  .[!is.na(.$AS_event_ID), ] %>%
  .[apply(X = .[, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud", "MSC", "6h", "1d")], MARGIN = 1, FUN = function(X) {all(is.finite(X)) %>% return} ), ]

tibble_psisigma_nmd_proteome_correlation <- tibble_MQ_scaled_tibbles_matched_to_geneset_per_cluster %>%
  .[.$type == "protein_groups", ] %>% 
  split_delimited_columns_in_table(target_colname = "Gene.names", split = "\\;") %>% dplyr::rename("matched_gene_names" = "Gene.names") %>% 
  dplyr::left_join(., tibble_PSIsigma_scaled_PSI_timeseries_wide_with_productive_read_counts %>% .[.$NMD_flagged_recon == TRUE | .$contains_PTC_ref == TRUE, c("matched_gene_names", "database_ID", "chr", "diff_exon_start", "diff_exon_end", vector_OBseries_timepoints_edited)]) %>%
  .[!is.na(.$database_ID), ] %>%
  .[apply(X = .[, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud", "MSC", "6h", "1d")], MARGIN = 1, FUN = function(X) {all(is.finite(X)) %>% return} ), ]

tibble_psisigma_allevents_proteome_correlation <- tibble_MQ_scaled_tibbles_matched_to_geneset_per_cluster %>%
  .[.$type == "protein_groups", ] %>% 
  split_delimited_columns_in_table(target_colname = "Gene.names", split = "\\;") %>% dplyr::rename("matched_gene_names" = "Gene.names") %>% 
  dplyr::left_join(., tibble_PSIsigma_scaled_PSI_timeseries_wide_with_productive_read_counts %>% .[, c("matched_gene_names", "database_ID", "chr", "diff_exon_start", "diff_exon_end", vector_OBseries_timepoints_edited)]) %>%
  .[!is.na(.$database_ID), ] %>%
  .[apply(X = .[, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud", "MSC", "6h", "1d")], MARGIN = 1, FUN = function(X) {all(is.finite(X)) %>% return} ), ]

purrr::map(
  .x = 1:nrow(tibble_jum_nmd_proteome_correlation),
  .f = ~cor(x = tibble_jum_nmd_proteome_correlation[.x, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud")] %>% t, tibble_jum_nmd_proteome_correlation[.x, c("MSC", "6h", "1d")] %>% t)
) %>% unlist %>% density(bw = 0.05) %>% plot(main = "JUM NMD correlation with proteome")

purrr::map(
  .x = 1:nrow(tibble_jum_allevents_proteome_correlation),
  .f = ~cor(x = tibble_jum_allevents_proteome_correlation[.x, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud")] %>% t, tibble_jum_allevents_proteome_correlation[.x, c("MSC", "6h", "1d")] %>% t)
) %>% unlist %>% density(bw = 0.05) %>% plot(main = "JUM all events correlation with proteome")

purrr::map(
  .x = 1:nrow(tibble_psisigma_nmd_proteome_correlation),
  .f = ~cor(x = tibble_psisigma_nmd_proteome_correlation[.x, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud")] %>% t, tibble_psisigma_nmd_proteome_correlation[.x, c("MSC", "6h", "1d")] %>% t)
) %>% unlist %>% density(bw = 0.05) %>% plot(main = "PSI-Sigma NMD correlation with proteome")

purrr::map(
  .x = 1:nrow(tibble_psisigma_allevents_proteome_correlation),
  .f = ~cor(x = tibble_psisigma_allevents_proteome_correlation[.x, c("mean|ud_vs_ud", "mean|6h_vs_ud", "mean|1d_vs_ud")] %>% t, tibble_psisigma_allevents_proteome_correlation[.x, c("MSC", "6h", "1d")] %>% t)
) %>% unlist %>% density(bw = 0.05) %>% plot(main = "PSI-Sigma all events correlation with proteome")

```

### Check the residue of dbPTM annotated phosphosites

We are going to confirm that the TREMBL ids used are correct.

```{r}

# plan(list(tweak(multiprocess, workers = 4),
#           tweak(multiprocess, workers = 16)))
# 
# # plan(multiprocess)
# # options(mc.cores = 8)
# 
# # import dbPTM info
# # Z:/dbPTM_download/extract/allPTM_human.txt
# tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# 
# # import the Trembl fasta file
# tibble_trembl_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_trembl_humanonly.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
#   furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
#   unlist(use.names = TRUE) %>%
#   tibble::enframe(name = "fasta_header", value = "sequence")
# # import the swissprot canonical fasta file
# list_sp.canonical_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_sprot_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE)
# 
# tibble_sp.canonical_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_sprot_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
#   furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
#   unlist(use.names = TRUE) %>%
#   tibble::enframe(name = "fasta_header", value = "sequence")
# # import the swissprot isoforms fasta file
# tibble_sp.isoforms_fasta_allhuman <- seqinr::read.fasta(file = "/mnt/Tertiary/sharedfolder/hg38_ensembl_reference/proteome_fasta/uniprot_sprot_isoforms_human.fasta", forceDNAtolower = FALSE, seqtype = "AA", whole.header = TRUE) %>%
#   furrr::future_map(.f = ~.x %>% paste(collapse = ""), .progress = TRUE) %>%
#   unlist(use.names = TRUE) %>%
#   tibble::enframe(name = "fasta_header", value = "sequence")
# 
# # extract the entry ID column
# # tibble_sp.canonical_fasta_allhuman
# # tibble_sp.isoforms_fasta_allhuman
# # tibble_trembl_fasta_allhuman
# tibble_sp.trembl_fasta_allhuman_processed <- dplyr::bind_rows(tibble_sp.canonical_fasta_allhuman, tibble_sp.isoforms_fasta_allhuman, tibble_trembl_fasta_allhuman) %>% 
#   dplyr::mutate("uniprotkb_entry" = gsub(x = `fasta_header`, pattern = ".*\\|(.*)\\|.*", replacement = "\\1"))
# 
# # table join 
# tibble_sp.trembl_fasta_with_dbPTM_annotation <- dplyr::left_join(tibble_sp.trembl_fasta_allhuman_processed, tibble_dbPTM_allhuman_annotations, by = "uniprotkb_entry") %>% .[-which(is.na(.$PTM_type)), ]
# 
# # retrieve amino acid residue for each PTM type
# list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type <- tibble_sp.trembl_fasta_with_dbPTM_annotation %>% 
#   dplyr::group_split(PTM_type) %>%
#   set_names(nm = purrr::map(.x = ., .f = ~.x$PTM_type %>% unique) %>% unlist)
# 
# # map thru the list
# list_sp.trembl_residues_per_PTM_type <- furrr::future_map(
#   .x = list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type,
#   .f = function(a1) {
#     
#     # DEBUG ###
#     # a1 <- list_sp.trembl_fasta_with_dbPTM_annotation_split_by_PTM_type$Phosphorylation
#     ###########
#     
#     list_with_modified_residue <- furrr::future_map(
#       .x = a1 %>% array_tree,
#       .f = function(b1) {
#         
#         # DEBUG ###
#         # b1 <- a1 %>% array_tree %>% .[[1]]
#         ###########
#         
#         vector_uniprot_AA_sequence <- b1$sequence %>% strsplit(split = "") %>% unlist
#         
#         modified_residue_minus_1 <- vector_uniprot_AA_sequence[(b1$modified_residue_position %>% type.convert) - 1]
#         
#         modified_residue <- vector_uniprot_AA_sequence[(b1$modified_residue_position %>% type.convert)]
#         
#         modified_residue_plus_1 <- vector_uniprot_AA_sequence[(b1$modified_residue_position %>% type.convert) + 1]
#         
#         return(purrr::splice(b1,
#                              "modified_residue_minus_1" = modified_residue_minus_1,
#                              "modified_residue" = modified_residue,
#                              "modified_residue_plus_1" = modified_residue_plus_1) %>%
#                  as_tibble)
#         
#       }, .progress = TRUE)
#     
#     tibble_with_modified_residue <- list_with_modified_residue %>% rbindlist %>% as_tibble
#     
#     return(tibble_with_modified_residue)
#     
#   }, .progress = TRUE) 
# 
# # list_of_tally_tibbles_per_residue_minus_1 <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue_minus_1) %>% dplyr::summarise("tally_minus_1" = n()) %>% dplyr::arrange(desc(tally_minus_1)))
# list_of_tally_tibbles_per_residue <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally)))
# # list_of_tally_tibbles_per_residue_plus_1 <- list_sp.trembl_residues_per_PTM_type %>% purrr::map(~.x %>% dplyr::group_by(modified_residue_plus_1) %>% dplyr::summarise("tally_plus_1" = n()) %>% dplyr::arrange(desc(tally_plus_1)))

```

#### filter incorrect trembl and uniprot entries from dbPTM database.

```{r}

# list_residues_to_keep <- list(
#   "Acetylation" = c("K", "A", "S"), 
#   "Amidation" = LETTERS, 
#   "C-linked Glycosylation" = c("W"), 
#   "Carbamidation" = c("C"), 
#   "Carboxylation" = c("K"), 
#   "Citrullination" = c("R"), 
#   "Crotonylation" = c("K"), 
#   "Gamma-carboxyglutamic acid" = c("E"), 
#   "Glutarylation" = c("K"), 
#   "Glutathionylation" = c("C"), 
#   "GPI-anchor" = LETTERS, 
#   "Hydroxylation" = c("P", "K", "N"), 
#   "Lipoylation" = c("K"), 
#   "Malonylation" = c("K"), 
#   "Methylation" = c("R", "K"), 
#   "Myristoylation" = c("G"), 
#   "N-linked Glycosylation" = c("N"), 
#   "Neddylation" = c("K"), 
#   "Nitration" = c("Y"), 
#   "O-linked Glycosylation" = c("T", "S"), 
#   "Oxidation" = c("M"), 
#   "Palmitoylation" = c("C"), 
#   "Phosphorylation" = c("S", "T", "Y"), 
#   "Pyrrolidone carboxylic acid" = c("Q"), 
#   "Pyruvate" = c("S"), 
#   "S-linked Glycosylation" = c("C"), 
#   "S-nitrosylation" = c("C"), 
#   "S-Nitrosylation" = c("C"), 
#   "Succinylation" = c("K"), 
#   "Sulfation" = c("Y"), 
#   "Sumoylation" = c("K"), 
#   "Ubiquitination" = c("K", "L")
# )
# 
# list_dbPTM_filtered_entries_with_sp.trembl <- furrr::future_map2(
#   .x = list_sp.trembl_residues_per_PTM_type,
#   .y = list_residues_to_keep[names(list_sp.trembl_residues_per_PTM_type)],
#   .f = function(a1, a2) {
#     
#     output_tibble <- a1[a1$modified_residue %in% a2, ]
#     
#     return(output_tibble)
#     
#   }, .progress = TRUE)
# 
# # check whether the filtering worked
# list_of_tally_tibbles_per_residue_filtered <- list_dbPTM_filtered_entries_with_sp.trembl %>% purrr::map(~.x %>% dplyr::group_by(modified_residue) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally)))
# 
# # retrieve the filtered dbPTM information
# tibble_dbPTM_filtered_entries <- list_dbPTM_filtered_entries_with_sp.trembl %>% purrr::map(~.x %>% dplyr::select(-fasta_header, -sequence, -modified_residue_minus_1, -modified_residue,-modified_residue_plus_1)) %>%
#   rbindlist %>% as_tibble
# 
# # write the filtered dbPTM table
# write.table(x = tibble_dbPTM_filtered_entries, file = "/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

### Import all the non-homolog and non-superfamily entries from Interpro

```{r}

tibble_non_family_interpro_entries <- c("interpro_active.site_entries.tsv", "interpro_binding.site_entries.tsv", "interpro_conserved.site_entries.tsv", "interpro_domain_entries.tsv", "interpro_PTM_entries.tsv", "interpro_repeat_entries.tsv") %>% 
  purrr::map(.f = ~read.delim(paste(reference_data_dir, .x, sep = ""), sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble) %>% rbindlist %>% as_tibble

```

### Import the validated junc.exons as well as the validated phosphosites

```{r}

# tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_2020.PO4_valid_phosphosites <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

tibble_2020.PO4_2012.proteome_valid_junc.exons <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_confirmed_junc.exons_checked_against_sp.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/table_brief.info_unconfirmed_junc.exons.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# we have to use all the non-validating PSI-Sigma exons because although they don't validate the RNA exon, they validate any coding regions contained in the differential exon.
tibble_2020.PO4_2012.proteome_valid_junc.exons_coding <- dplyr::bind_rows(
  tibble_2020.PO4_2012.proteome_valid_junc.exons[grep(x = tibble_2020.PO4_2012.proteome_valid_junc.exons$Leading.razor.protein, pattern = "JUM", ignore.case = TRUE), ],
  tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons[grep(x = tibble_2020.PO4_2012.proteome_unconfirmed_junc.exons$Leading.razor.protein, pattern = "PSISigma", ignore.case = TRUE), ]
)

tibble_2020.PO4_valid_phosphosites <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_maxquant/R_processing_results/genome.relative.positions_2020_phosphoproteome_phosphosites.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble


```

#### Import the FASTA supplementary information

```{r}

tibble_fasta_supp_info_exons_differential_ensembl <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_differential_strawberry <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_database_generation/PSISigma_differential_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_exons_constitutive_ensembl <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_ensembl_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_exons_constitutive_strawberry <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_database_generation/PSISigma_constitutive_strawberry_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

tibble_fasta_supp_info_junctions_differential <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_differential_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character) 
tibble_fasta_supp_info_junctions_constitutive <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/proteome_validation/results_database_generation/JUM_junctions_constitutive_3FT_3FT.summary.info.txt", sep = "\t", row.names = NULL, header = TRUE) %>% as_tibble %>% dplyr::mutate_if(is.factor, as.character)

# bind rows
tibble_fasta_supp_info_junctions <- dplyr::bind_rows(
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive
                                           )

tibble_fasta_supp_info_exons <- dplyr::bind_rows(
  tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry
                                           )

tibble_fasta_supp_info <- dplyr::bind_rows(
  tibble_fasta_supp_info_exons_differential_ensembl,
                                           tibble_fasta_supp_info_exons_differential_strawberry,
                                           tibble_fasta_supp_info_exons_constitutive_ensembl,
                                           tibble_fasta_supp_info_exons_constitutive_strawberry,
                                           tibble_fasta_supp_info_junctions_differential,
                                           tibble_fasta_supp_info_junctions_constitutive
                                           )

```

## SNP and disease section

### import GWAS catalog

```{r}

tibble_ebi_gwas_catalog <- read_tsv(file = "/mnt/4tb_ironwolf/eQTL_catalogue/gwas_catalog_v1.0.2-associations_e98_r2020-05-03.tsv", col_types = cols(.default = "c")) %>% 
  type_convert %>%
  dplyr::filter(CHR_ID %>% is.na == FALSE)

## Join the GWAS catalog with ensembl variation database

## Memo: we NEED this because we need to retrieve calculated consequences

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog$CHR_ID %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog$CHR_POS %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog$SNPS %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a5" = tibble_ebi_gwas_catalog$CONTEXT %>% strsplit(split = "\\;") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("unique", "length"))) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog[setdiff(1:nrow(tibble_ebi_gwas_catalog), grep(x = paste(tibble_ebi_gwas_catalog$CHR_POS, tibble_ebi_gwas_catalog$`STRONGEST SNP-RISK ALLELE`, tibble_ebi_gwas_catalog$SNPS, tibble_ebi_gwas_catalog$CONTEXT), pattern = "\\;")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog[setdiff(1:nrow(tibble_ebi_gwas_catalog), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\;"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("CHR_ID", "CHR_POS", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\;") %>% dplyr::mutate_all(as.character))

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "\\,") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("length"))) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "\\,")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\,"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\,") %>% dplyr::mutate_all(as.character))

rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "\\_") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("unique", "length"))) %>% unlist %>% which


tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "\\_")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "\\_"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "\\_") %>% dplyr::mutate_all(as.character))

# finally split by "x"'s due to gene interaction entries
rows_unequal_delimiting <- future_pmap(.l = list(
  "a1" = tibble_ebi_gwas_catalog_deduped$CHR_ID %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a2" = tibble_ebi_gwas_catalog_deduped$CHR_POS %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a3" = tibble_ebi_gwas_catalog_deduped$`REGION` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a4" = tibble_ebi_gwas_catalog_deduped$`REPORTED GENE(S)` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a5" = tibble_ebi_gwas_catalog_deduped$`MAPPED_GENE` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a6" = tibble_ebi_gwas_catalog_deduped$`STRONGEST SNP-RISK ALLELE` %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a7" = tibble_ebi_gwas_catalog_deduped$SNPS %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length"))),
  "a8" = tibble_ebi_gwas_catalog_deduped$CONTEXT %>% strsplit(split = "x") %>% future_map(.f = ~.x %>% length, .progress = TRUE, .options = future_options(globals = c("length")))
), .f = ~(c(...)[c(...) != 1] %>% unique %>% length) > 1, .progress = TRUE, .options = future_options(globals = c("unique", "length"))) %>% unlist %>% which

tibble_ebi_gwas_catalog_deduped <- dplyr::bind_rows(tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), grep(x = tibble_ebi_gwas_catalog_deduped$SNPS, pattern = "x")), ] %>% dplyr::mutate_all(as.character),
                                                    tibble_ebi_gwas_catalog_deduped[setdiff(1:nrow(tibble_ebi_gwas_catalog_deduped), rows_unequal_delimiting), ] %>% .[grep(x = .$SNPS, pattern = "x"), ] %>% 
  split_delimited_columns_in_table(target_colname = c("CHR_ID", "CHR_POS", "REGION", "REPORTED GENE(S)", "MAPPED_GENE", "STRONGEST SNP-RISK ALLELE", "SNPS", "CONTEXT"), split = "x") %>% dplyr::mutate_all(as.character))

tibble_ebi_gwas_catalog_deduped <- tibble_ebi_gwas_catalog_deduped %>% dplyr::mutate_all(.funs = trimws)

# list-ify by chromosome
list_tibble_ebi_gwas_catalog_by_chr <- tibble_ebi_gwas_catalog_deduped %>% 
  dplyr::mutate_at(.vars = "CHR_ID", .funs = trimws) %>%
  dplyr::group_split(CHR_ID) %>%
  set_names(nm = purrr::map(.x = ., .f = ~.x$`CHR_ID` %>% unique) %>% unlist)

```

# JUM, PSI-Sigma and MAJIQ analysis

## Get time series profiles and of psi and inclusion reads of validation candidates

```{r}

# find greatest psi differences
tibble_jum_psi_test <- dplyr::bind_rows(
  wide_tibble_of_all_detailed_tables_with_na[wide_tibble_of_all_detailed_tables_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_ud", ] %>% dplyr::select(-contains(".1"), -contains(".2"), -contains(".3"), -contains("deltaPSI"), -contains("raw_count"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")], pattern = "percentage\\_usage\\.", replacement = "") %>% (function(x) {paste("psi_", type.convert(x) - 3, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  wide_tibble_of_all_detailed_tables_with_na[grep(x = wide_tibble_of_all_detailed_tables_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_ud"), ] %>% dplyr::select(-contains(".4"), -contains(".5"), -contains(".6"), -contains("deltaPSI"), -contains("raw_count"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "percentage\\_usage\\.")], pattern = "percentage\\_usage\\.", replacement = "") %>% (function(x) {paste("psi_", x, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_ud", replacement = "\\1") %>% gsub(pattern = "24h", replacement = "1d"))
) %>% 
  dplyr::mutate_all(.funs = function(x) {return(gsub(x = x, pattern = "\\%", replacement = ""))} ) %>%
  readr::type_convert() %>%
  (function(x) {
    
    purrr::map(.x = c(1, 2, 3),
             .f = function(a1) {
               
               x %>% 
                 reshape2::dcast(formula = Gene + AS_event_ID + AS_structure_ID + contributing_junctions + sub_junction_ID + chr + sub_junction_start_coor + sub_junction_end_coor + sub_junction_size + sub_junction_strand ~ paste(comparison, "_", a1, sep = ""), value.var = paste("psi_", a1, sep = "")) %>% 
                 dplyr::mutate(!!as.name(paste("min_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(min(X %>% na.omit %>% .[is.finite(.)]))}), !!as.name(paste("max_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit %>% .[is.finite(.)]))})) %>% 
                 dplyr::mutate(!!as.name(paste("range_", a1, sep = "")) := !!as.name(paste("max_", a1, sep = "")) - !!as.name(paste("min_", a1, sep = ""))) %>% 
                 return
               
             } ) %>% return
    
  } ) %>%
  purrr::reduce(dplyr::left_join) %>%
  as_tibble %>% 
  dplyr::select(-contains("max"), -contains("min"), -contains("range")) %>%
  reshape2::melt(id.vars = c("Gene", "AS_event_ID", "AS_structure_ID", "contributing_junctions", "sub_junction_ID", "chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand"), variable.name = "timepoint_replicate", value.name = "psi") %>%
  as_tibble %>%
  tidyr::separate(col = "timepoint_replicate", into = c("timepoint", "replicate"), sep = "\\_")

tibble_jum_psi_ggplot <- tibble_jum_psi_test %>% .[.$Gene %in% c("DNM2", "SEC16A", "ACIN1", "PDGFRA", "NFATC4", "HMGA1", "TEAD1", "RUNX2", "TCF3", "SFPQ", "KIF13A", "MBNL1", "MACF1", "KAT2A", "CTNNB1"), ] %>% dplyr::group_by(Gene, AS_event_ID, AS_structure_ID, contributing_junctions, sub_junction_ID, chr, sub_junction_start_coor, sub_junction_end_coor, sub_junction_size, sub_junction_strand, timepoint) %>% dplyr::summarise("psi_avg" = mean(`psi` %>% na.omit)) %>% dplyr::inner_join(., tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("AS_event_ID", "splicemode")])

ggplot2::ggplot() +
  geom_line(data = tibble_jum_psi_ggplot %>% .[.$AS_structure_ID == "3_Junction_498051_Junction_498064_Junction_498073_Junction_498081_Junction_498086_Junction_498089_Junction_498091" & .$sub_junction_start_coor == 54229415 & .$sub_junction_end_coor == 54258755, ], mapping = aes(x = `timepoint`, y = `psi_avg`, group = paste(Gene, AS_event_ID, AS_structure_ID, contributing_junctions, sub_junction_ID, chr, sub_junction_start_coor, sub_junction_end_coor, sub_junction_size, sub_junction_strand))) +
  facet_wrap( ~ AS_event_ID, scales = "free", labeller = labeller(AS_event_ID = tibble_jum_psi_ggplot %>% dplyr::ungroup() %>% dplyr::distinct(AS_event_ID, .keep_all = TRUE) %>% .$Gene %>% (function(x) {names(x) <- tibble_jum_psi_ggplot$AS_event_ID %>% unique; return(x)} ))) +
  scale_x_discrete(breaks = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  ggtitle("JUM PSI profiles")

tibble_jum_inclusion_reads_test <- dplyr::bind_rows(
  wide_tibble_of_all_detailed_tables_with_na[wide_tibble_of_all_detailed_tables_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_ud", ] %>% dplyr::select(-contains(".1"), -contains(".2"), -contains(".3"), -contains("deltaPSI"), -contains("percentage_usage"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")], pattern = "raw\\_count\\.", replacement = "") %>% (function(x) {paste("inclusion_reads_", type.convert(x) - 3, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  wide_tibble_of_all_detailed_tables_with_na[grep(x = wide_tibble_of_all_detailed_tables_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_ud"), ] %>% dplyr::select(-contains(".4"), -contains(".5"), -contains(".6"), -contains("deltaPSI"), -contains("percentage_usage"), -contains("log"), -contains("LRT"), -contains("dispersion"), -contains("BH")) %>% (function(x) {colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")] <- gsub(x = colnames(x)[grepl(x = colnames(x), pattern = "raw\\_count\\.")], pattern = "raw\\_count\\.", replacement = "") %>% (function(x) {paste("inclusion_reads_", x, sep = "") %>% return} ); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_ud", replacement = "\\1") %>% gsub(pattern = "24h", replacement = "1d"))
) %>% 
  dplyr::mutate_all(.funs = function(x) {return(gsub(x = x, pattern = "\\%", replacement = ""))} ) %>%
  readr::type_convert() %>%
  (function(x) {
    
    purrr::map(.x = c(1, 2, 3),
             .f = function(a1) {
               
               x %>% 
                 reshape2::dcast(formula = Gene + AS_event_ID + AS_structure_ID + contributing_junctions + sub_junction_ID + chr + sub_junction_start_coor + sub_junction_end_coor + sub_junction_size + sub_junction_strand ~ paste(comparison, "_", a1, sep = ""), value.var = paste("inclusion_reads_", a1, sep = "")) %>% 
                 dplyr::mutate(!!as.name(paste("min_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(min(X %>% na.omit %>% .[is.finite(.)]))}), !!as.name(paste("max_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit %>% .[is.finite(.)]))})) %>% 
                 dplyr::mutate(!!as.name(paste("range_", a1, sep = "")) := !!as.name(paste("max_", a1, sep = "")) - !!as.name(paste("min_", a1, sep = ""))) %>% 
                 return
               
             } ) %>% return
    
  } ) %>%
  purrr::reduce(dplyr::left_join) %>%
  as_tibble %>% 
  dplyr::select(-contains("max"), -contains("min"), -contains("range")) %>%
  reshape2::melt(id.vars = c("Gene", "AS_event_ID", "AS_structure_ID", "contributing_junctions", "sub_junction_ID", "chr", "sub_junction_start_coor", "sub_junction_end_coor", "sub_junction_size", "sub_junction_strand"), variable.name = "timepoint_replicate", value.name = "inclusion_reads") %>%
  as_tibble %>%
  tidyr::separate(col = "timepoint_replicate", into = c("timepoint", "replicate"), sep = "\\_")

tibble_jum_inclusion_reads_ggplot <- tibble_jum_inclusion_reads_test %>% .[.$Gene %in% c("DNM2", "SEC16A", "ACIN1", "PDGFRA", "NFATC4", "HMGA1", "TEAD1", "RUNX2", "TCF3", "SFPQ", "KIF13A", "MBNL1", "MACF1", "KAT2A", "CTNNB1"), ] %>% dplyr::group_by(Gene, AS_event_ID, AS_structure_ID, contributing_junctions, sub_junction_ID, chr, sub_junction_start_coor, sub_junction_end_coor, sub_junction_size, sub_junction_strand, timepoint) %>% dplyr::summarise("inclusion_reads_avg" = mean(`inclusion_reads` %>% na.omit)) %>% dplyr::inner_join(., tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("AS_event_ID", "splicemode")])

ggplot2::ggplot() +
  geom_line(data = tibble_jum_inclusion_reads_ggplot %>% .[.$AS_structure_ID == "3_Junction_498051_Junction_498064_Junction_498073_Junction_498081_Junction_498086_Junction_498089_Junction_498091" & .$sub_junction_start_coor == 54229415 & .$sub_junction_end_coor == 54258755, ], mapping = aes(x = `timepoint`, y = `inclusion_reads_avg`, group = paste(Gene, AS_event_ID, AS_structure_ID, contributing_junctions, sub_junction_ID, chr, sub_junction_start_coor, sub_junction_end_coor, sub_junction_size, sub_junction_strand))) +
  facet_wrap( ~ AS_event_ID, scales = "free", labeller = labeller(AS_event_ID = tibble_jum_inclusion_reads_ggplot %>% dplyr::ungroup() %>% dplyr::distinct(AS_event_ID, .keep_all = TRUE) %>% .$Gene %>% (function(x) {names(x) <- tibble_jum_inclusion_reads_ggplot$AS_event_ID %>% unique; return(x)} ))) +
  scale_x_discrete(breaks = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  ggtitle("JUM inclusion reads")

# find greatest psi differences
tibble_psisigma_psi_test <- dplyr::bind_rows(
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_MSC", ] %>% dplyr::select(-contains("comparison.1"), -contains("numerator"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.2\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[grep(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_MSC"), ] %>% dplyr::select(-contains("comparison.2"), -contains("numerator"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.1\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_MSC", replacement = "\\1"))
) %>% 
  (function(x) {
    
    purrr::map(.x = c(1, 2, 3),
             .f = function(a1) {
               
               x %>% 
                 reshape2::dcast(formula = database_ID + event_region_coords + diff_exon_coords + splicemode + matched_gene_names ~ paste(comparison, "_", a1, sep = ""), value.var = paste("absolute.psi_", a1, sep = "")) %>% 
                 dplyr::mutate(!!as.name(paste("min_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(min(X %>% na.omit %>% .[is.finite(.)]))}), !!as.name(paste("max_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit %>% .[is.finite(.)]))})) %>% 
                 dplyr::mutate(!!as.name(paste("range_", a1, sep = "")) := !!as.name(paste("max_", a1, sep = "")) - !!as.name(paste("min_", a1, sep = ""))) %>% 
                 return
               
             } ) %>% return
    
  } ) %>%
  purrr::reduce(dplyr::left_join) %>%
  as_tibble %>% 
  dplyr::select(-contains("max"), -contains("min"), -contains("range")) %>%
  reshape2::melt(id.vars = c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names"), variable.name = "timepoint_replicate", value.name = "psi") %>%
  as_tibble %>%
  tidyr::separate(col = "timepoint_replicate", into = c("timepoint", "replicate"), sep = "\\_") %>%
  dplyr::mutate("event_id" = gsub(x = database_ID, pattern = "(.*)_.*$", replacement = "\\1"))
  
tibble_psisigma_psi_ggplot <- tibble_psisigma_psi_test %>% .[.$matched_gene_names %in% c("DNM2", "SEC16A", "ACIN1", "PDGFRA", "NFATC4", "HMGA1", "TEAD1", "RUNX2", "TCF3", "SFPQ", "KIF13A", "MBNL1", "MACF1", "KAT2A", "CTNNB1"), ] %>% dplyr::group_by(database_ID, event_region_coords, diff_exon_coords, splicemode, matched_gene_names, timepoint, event_id) %>% dplyr::summarise("psi_avg" = mean(`psi` %>% na.omit))

ggplot2::ggplot() +
  geom_line(data = tibble_psisigma_psi_ggplot %>% .[.$database_ID == "14_24376555_24377637_S_TSS.ENST00000250373_1", ], mapping = aes(x = `timepoint`, y = `psi_avg`, group = paste(database_ID, event_region_coords, diff_exon_coords, splicemode, matched_gene_names))) +
  facet_wrap( ~ event_id, scales = "free", labeller = labeller(event_id = tibble_psisigma_psi_ggplot %>% dplyr::ungroup() %>% dplyr::distinct(event_id, .keep_all = TRUE) %>% .$matched_gene_names %>% (function(x) {names(x) <- tibble_psisigma_psi_ggplot$event_id %>% unique; return(x)} ))) +
  scale_x_discrete(breaks = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  ggtitle("PSI-Sigma PSI profiles")

tibble_psisigma_numerator_test <- dplyr::bind_rows(
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_MSC", ] %>% dplyr::select(-contains("comparison.1"), -contains("average.psi"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.2\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[grep(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_MSC"), ] %>% dplyr::select(-contains("comparison.2"), -contains("average.psi"), -contains("denominator"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.1\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_MSC", replacement = "\\1"))
) %>% 
  (function(x) {
    
    purrr::map(.x = c(1, 2, 3),
             .f = function(a1) {
               
               x %>% 
                 reshape2::dcast(formula = database_ID + event_region_coords + diff_exon_coords + splicemode + matched_gene_names ~ paste(comparison, "_", a1, sep = ""), value.var = paste("numerator_", a1, sep = "")) %>% 
                 dplyr::mutate(!!as.name(paste("min_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(min(X %>% na.omit %>% .[is.finite(.)]))}), !!as.name(paste("max_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit %>% .[is.finite(.)]))})) %>% 
                 dplyr::mutate(!!as.name(paste("range_", a1, sep = "")) := !!as.name(paste("max_", a1, sep = "")) - !!as.name(paste("min_", a1, sep = ""))) %>% 
                 return
               
             } ) %>% return
    
  } ) %>%
  purrr::reduce(dplyr::left_join) %>%
  as_tibble %>% 
  dplyr::select(-contains("max"), -contains("min"), -contains("range")) %>%
  reshape2::melt(id.vars = c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names"), variable.name = "timepoint_replicate", value.name = "psi") %>%
  as_tibble %>%
  tidyr::separate(col = "timepoint_replicate", into = c("timepoint", "replicate"), sep = "\\_") %>%
  dplyr::mutate("event_id" = gsub(x = database_ID, pattern = "(.*)_.*$", replacement = "\\1"))
  
tibble_psisigma_numerator_ggplot <- tibble_psisigma_numerator_test %>% .[.$matched_gene_names %in% c("DNM2", "SEC16A", "ACIN1", "PDGFRA", "NFATC4", "HMGA1", "TEAD1", "RUNX2", "TCF3", "SFPQ", "KIF13A", "MBNL1", "MACF1", "KAT2A", "CTNNB1"), ] %>% dplyr::group_by(database_ID, event_region_coords, diff_exon_coords, splicemode, matched_gene_names, timepoint, event_id) %>% dplyr::summarise("psi_avg" = mean(`psi` %>% na.omit))

ggplot2::ggplot() +
  geom_line(data = tibble_psisigma_numerator_ggplot %>% .[.$database_ID == "14_24376555_24377637_S_TSS.ENST00000250373_1", ], mapping = aes(x = `timepoint`, y = `psi_avg`, group = paste(database_ID, event_region_coords, diff_exon_coords, splicemode, matched_gene_names))) +
  facet_wrap( ~ event_id, scales = "free", labeller = labeller(event_id = tibble_psisigma_numerator_ggplot %>% dplyr::ungroup() %>% dplyr::distinct(event_id, .keep_all = TRUE) %>% .$matched_gene_names %>% (function(x) {names(x) <- tibble_psisigma_numerator_ggplot$event_id %>% unique; return(x)} ))) +
  scale_x_discrete(breaks = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  ggtitle("PSI-Sigma inclusion read counts")

tibble_psisigma_denominator_test <- dplyr::bind_rows(
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison == "BM_MSC_to_OB_9d_vs_BM_MSC_to_OB_MSC", ] %>% dplyr::select(-contains("comparison.1"), -contains("numerator"), -contains("average.psi"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.2\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = "MSC"),
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[grep(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$comparison, pattern = ".*\\_vs\\_BM\\_MSC\\_to\\_OB\\_MSC"), ] %>% dplyr::select(-contains("comparison.2"), -contains("numerator"), -contains("average.psi"), -contains("_ER_")) %>% (function(x) {colnames(x) <- gsub(x = colnames(x), pattern = "comparison.1\\_", replacement = ""); return(x)} ) %>% dplyr::mutate("comparison" = gsub(x = `comparison`, pattern = "BM_MSC_to_OB_(.*)_vs_BM_MSC_to_OB_MSC", replacement = "\\1"))
) %>% 
  (function(x) {
    
    purrr::map(.x = c(1, 2, 3),
             .f = function(a1) {
               
               x %>% 
                 reshape2::dcast(formula = database_ID + event_region_coords + diff_exon_coords + splicemode + matched_gene_names ~ paste(comparison, "_", a1, sep = ""), value.var = paste("denominator_", a1, sep = "")) %>% 
                 dplyr::mutate(!!as.name(paste("min_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(min(X %>% na.omit %>% .[is.finite(.)]))}), !!as.name(paste("max_", a1, sep = "")) := apply(X = .[, paste(c("MSC", "1d", "6h", "12h", "3d", "6d", "9d", "12d"), "_", a1, sep = "")], MARGIN = 1, FUN = function(X) {return(max(X %>% na.omit %>% .[is.finite(.)]))})) %>% 
                 dplyr::mutate(!!as.name(paste("range_", a1, sep = "")) := !!as.name(paste("max_", a1, sep = "")) - !!as.name(paste("min_", a1, sep = ""))) %>% 
                 return
               
             } ) %>% return
    
  } ) %>%
  purrr::reduce(dplyr::left_join) %>%
  as_tibble %>% 
  dplyr::select(-contains("max"), -contains("min"), -contains("range")) %>%
  reshape2::melt(id.vars = c("database_ID", "event_region_coords", "diff_exon_coords", "splicemode", "matched_gene_names"), variable.name = "timepoint_replicate", value.name = "psi") %>%
  as_tibble %>%
  tidyr::separate(col = "timepoint_replicate", into = c("timepoint", "replicate"), sep = "\\_") %>%
  dplyr::mutate("event_id" = gsub(x = database_ID, pattern = "(.*)_.*$", replacement = "\\1"))
  
tibble_psisigma_denominator_ggplot <- tibble_psisigma_denominator_test %>% .[.$matched_gene_names %in% c("DNM2", "SEC16A", "ACIN1", "PDGFRA", "NFATC4", "HMGA1", "TEAD1", "RUNX2", "TCF3", "SFPQ", "KIF13A", "MBNL1", "MACF1", "KAT2A", "CTNNB1"), ] %>% dplyr::group_by(database_ID, event_region_coords, diff_exon_coords, splicemode, matched_gene_names, timepoint, event_id) %>% dplyr::summarise("psi_avg" = mean(`psi` %>% na.omit))

ggplot2::ggplot() +
  geom_line(data = tibble_psisigma_denominator_ggplot, mapping = aes(x = `timepoint`, y = `psi_avg`, group = paste(database_ID, event_region_coords, diff_exon_coords, splicemode, matched_gene_names))) +
  facet_wrap( ~ event_id, scales = "free", labeller = labeller(event_id = tibble_psisigma_denominator_ggplot %>% dplyr::ungroup() %>% dplyr::distinct(event_id, .keep_all = TRUE) %>% .$matched_gene_names %>% (function(x) {names(x) <- tibble_psisigma_denominator_ggplot$event_id %>% unique; return(x)} ))) +
  scale_x_discrete(breaks = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), limits = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  ggtitle("PSI-Sigma inclusion read counts")

```

## Calculate the number of junction/exons found in common

### Calculate intersections

STRATEGY: use one table to look up other table. one-directional evidence is required and sufficient for intersection.

#### FUNCTION TO CONVERT JUM AS_EVENT_ID TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

JUM_AS.event.ID_to_chr_strand_start_end <- function(tibble) {
  
  vec_AS.event.ID_unique <- tibble$AS_event_ID %>% unique
  
  vec_chr <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\2")
  vec_start <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\3")
  vec_end <- gsub(x = vec_AS.event.ID_unique, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*)_([0-9]{1,10})$", replacement = "\\5")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
  
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end))
  
}

```

#### FUNCTION TO CONVERT PSI-SIGMA DIFF_EXON_COORDS TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

PSIsigma_diff.exon.coords_to_chr_strand_start_end <- function(tibble) {
  
  vec_event.region.coords <- tibble$event_region_coords
  
  vec_chr <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\1")
  vec_strand <- tibble$matched_strand
  vec_start <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\2")
  vec_end <- gsub(x = vec_event.region.coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})$", replacement = "\\3")
  
  vec_identifier <- paste(vec_chr, ":", vec_start, "-", vec_end, ":", vec_strand, sep = "")
    
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end) %>% unique)
  
}

```

#### FUNCTION TO CONVERT MAJIQ VSR_COORDS TO CHR STRAND START END

- will drop non-unique entries
- f: tibble => tibble

```{r}

majiq_junc_coords_to_chr_strand_start_end <- function(tibble) {
  
  vector_vsr_coords <- tibble$VSR_coords
  
  vec_chr <- gsub(x = vector_vsr_coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})\\:(.*)$", replacement = "\\1")
  vec_strand <- gsub(x = vector_vsr_coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})\\:(.*)$", replacement = "\\4")
  vec_start <- gsub(x = vector_vsr_coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})\\:(.*)$", replacement = "\\2")
  vec_end <- gsub(x = vector_vsr_coords, pattern = "^([^\\:]+)\\:([0-9]{1,10})\\-([0-9]{1,10})\\:(.*)$", replacement = "\\3")
  
  vec_identifier <- vector_vsr_coords
    
  return(tibble("identifier" = vec_identifier,
                "chr" = vec_chr,
                "strand" = vec_strand,
                "start" = vec_start,
                "end" = vec_end) %>% unique)
  
}

```

#### create generic function to do this job.

```{r}

calculate_intersections_from_chr_strand_start_end <- function(tibble_1, tibble_2, tibble_1_tolerance_left, tibble_1_tolerance_right) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na
  # tibble_1_tolerance_left <- 2
  # tibble_1_tolerance_right <- 2
  ###########
  
  tibble_1 <<- tibble_1
  tibble_2 <<- tibble_2
  
  # list-ify tibble_1
  list_tibble_1_array.tree <- tibble_1 %>% array_tree
  # set L1 names as identifier names
  names(list_tibble_1_array.tree) <- tibble_1$identifier
  
  # match each element of tibble_1 to tibble_2 and see if there is a valid subset found.
  list_tibble_1_to_2_matches <- future_map(.x = list_tibble_1_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_tibble_1_array.tree[[3]]
    ###########
    
    subset <- tibble_2[tibble_2$chr == .x$chr %>% paste %>% trimws, ] %>% 
      .[.$strand == .x$strand %>% paste %>% trimws, ] %>% 
      .[(.$start < (.x$end %>% paste %>% trimws %>% as.numeric) + tibble_1_tolerance_right) & (.$end > (.x$start %>% paste %>% trimws %>% as.numeric) - tibble_1_tolerance_left), ]
    
    if (nrow(subset) == 0) {
      return("no_overlap")
    } else {
      return(subset)
    }
    
  }, .progress = TRUE)
  
  # extract the list indices which had valid overlap
  vector_list.indices_with_valid_overlap <- list_tibble_1_to_2_matches %>% purrr::map(~all(.x == "no_overlap") == FALSE) %>% unlist %>% which
  # return aggregate number of overlap
  number_of_entries_with_valid_overlap <- vector_list.indices_with_valid_overlap %>% length
  # return summary list of matching table entries
  list_overlapped_table_entries <- future_imap(.x = list_tibble_1_to_2_matches[vector_list.indices_with_valid_overlap], .f = ~list("tibble_1_entry" = tibble_1[tibble_1$identifier == .y, ],
                                                                                                                                   "tibble_2_entry" = .x), .progress = TRUE)
  
  return(list("number_of_entries_tibble_1" = nrow(tibble_1),
              "number_of_entries_tibble_2" = nrow(tibble_2),
              "number_of_common_entries" = number_of_entries_with_valid_overlap,
              "detailed_result" = list_overlapped_table_entries))
  
}

```

#### run the intersections

```{r}

options(mc.cores = 16)

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na%>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_all_junctions_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_PSIsigma_all_exons_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na$number_of_common_entries, "\n"))

# constitutive JUM vs. constitutive PSI-Sigma
JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM constitutive (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma constitutive, (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq differential vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_differential_with_na %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq differential (", majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq differential vs. JUM differential/dpsi0.15/qvalue0.01/with_na
majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_differential_with_na %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq differential (", majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_1, ") vs. JUM differential/dpsi0.15/qvalue0.01/with_na, (", majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq constitutive vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
majiq_constitutive_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_constitutive %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq constitutive (", majiq_constitutive_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", majiq_constitutive_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", majiq_constitutive_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq constitutive vs. JUM differential/dpsi0.15/qvalue0.01/with_na
majiq_constitutive_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_constitutive %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq constitutive (", majiq_constitutive_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_1, ") vs. JUM differential/dpsi0.15/qvalue0.01/with_na, (", majiq_constitutive_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons found in common are: ", majiq_constitutive_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_common_entries, "\n"))

# three way overlap
regioneR::overlapRegions(A = regioneR::commonRegions(A = tibble_majiq_differential_with_na %>% majiq_junc_coords_to_chr_strand_start_end %>% .$identifier %>% gsub(pattern = "^(.*)\\:.*", replacement = "\\1") %>% regioneR::toGRanges(), B = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end %>% .$identifier %>% gsub(pattern = "^(.*)\\:.*", replacement = "\\1") %>% regioneR::toGRanges()), B = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% JUM_AS.event.ID_to_chr_strand_start_end %>% .$identifier %>% gsub(pattern = "^(.*)\\:.*", replacement = "\\1") %>% regioneR::toGRanges()) %>% nrow

```

#### repeat the intersections with only genes in common

```{r}

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM differential/dpsi0.15/qvalue0.01/with_na vs. PSIsigma all exons/with_na
JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::select(-matched_gene_names) %>% rename_column_exact(target_column = "Gene", output_colname = "matched_gene_names"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM differential/dpsi0.15/qvalue0.01/with_na (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_differential_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, tibble_JUM_all_junctions_with_na %>% dplyr::rename("matched_gene_name" = "Gene"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# JUM all junctions/with_na vs. PSIsigma all exons/with_na
JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_all_junctions_with_na, tibble_PSIsigma_all_exons_with_na %>% rename_column_exact(target_column = "matched_gene_names", output_colname = "Gene"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    dplyr::semi_join(tibble_PSIsigma_all_exons_with_na, tibble_JUM_all_junctions_with_na %>% dplyr::rename("matched_gene_name" = "Gene"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM all junctions/with_na (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma all exons/with_na, (", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_all_junctions_with_na_vs_PSIsigma_all_exons_with_na_common.genes$number_of_common_entries, "\n"))

# constitutive JUM vs. constitutive PSI-Sigma
JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes <-
  calculate_intersections_from_chr_strand_start_end(dplyr::semi_join(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na, tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% dplyr::rename("Gene" = "matched_gene_names"), by = "Gene") %>% JUM_AS.event.ID_to_chr_strand_start_end,
                                                    dplyr::semi_join(tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na, tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::select(-matched_gene_names) %>% dplyr::rename("matched_gene_names" = "Gene"), by = "matched_gene_names") %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("JUM constitutive (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_1, ") vs. PSIsigma constitutive, (", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", JUM_constitutive_dpsi0.15_qvalue0.01_with_na_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na_common.genes$number_of_common_entries, "\n"))

# majiq differential vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_differential_with_na %>% dplyr::rename("matched_gene_names" = "gene_name") %>% dplyr::semi_join(., tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[, "matched_gene_names"]) %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% dplyr::rename("gene_name" = "matched_gene_names") %>% dplyr::semi_join(., tibble_majiq_differential_with_na[, "gene_name"]) %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq differential (", majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na, (", majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", majiq_differential_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq differential vs. JUM differential/dpsi0.15/qvalue0.01/with_na
majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_differential_with_na %>% dplyr::rename("Gene" = "gene_name") %>% dplyr::semi_join(., tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, "Gene"]) %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::rename("gene_name" = "Gene") %>% dplyr::semi_join(., tibble_majiq_differential_with_na[, "gene_name"]) %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq differential (", majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_1, ") vs. JUM differential/dpsi0.15/qvalue0.01/with_na, (", majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", majiq_differential_vs_JUM_differential_dpsi0.15_qvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq constitutive vs. PSIsigma differential/dpsi0.10/pvalue0.01/with_na
majiq_constitutive_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_constitutive %>% dplyr::rename("matched_gene_names" = "gene_name") %>% dplyr::semi_join(., tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na[, "matched_gene_names"]) %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% dplyr::rename("gene_name" = "matched_gene_names") %>% dplyr::semi_join(., tibble_majiq_constitutive[, "gene_name"]) %>% PSIsigma_diff.exon.coords_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq constitutive (", majiq_constitutive_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_1, ") vs. PSIsigma constitutive/dpsi0.10/pvalue0.01/with_na, (", majiq_constitutive_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", majiq_constitutive_vs_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$number_of_common_entries, "\n"))

# majiq constitutive vs. JUM differential/dpsi0.15/qvalue0.01/with_na
majiq_constitutive_vs_JUM_constitutive_dpsi0.15_qvalue0.01_with_na <-
  calculate_intersections_from_chr_strand_start_end(tibble_majiq_constitutive %>% dplyr::rename("Gene" = "gene_name") %>% dplyr::semi_join(., tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[, "Gene"]) %>% majiq_junc_coords_to_chr_strand_start_end,
                                                    tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::rename("gene_name" = "Gene") %>% dplyr::semi_join(., tibble_majiq_constitutive[, "gene_name"]) %>% JUM_AS.event.ID_to_chr_strand_start_end, 
                                                    tibble_1_tolerance_left = 2, tibble_1_tolerance_right = 2)

cat(magenta("majiq constitutive (", majiq_constitutive_vs_JUM_constitutive_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_1, ") vs. JUM constitutive/dpsi0.15/qvalue0.01/with_na, (", majiq_constitutive_vs_JUM_constitutive_dpsi0.15_qvalue0.01_with_na$number_of_entries_tibble_2, ") , the number of junctions/exons IN COMMON GENES found in common are: ", majiq_constitutive_vs_JUM_constitutive_dpsi0.15_qvalue0.01_with_na$number_of_common_entries, "\n"))

```

### Calculate gene-level spliceome intersections with expression

```{r}

# solo diff. spliced/expressed genes
cat(magenta("\nRSEM/EdgeR differential genes: ", logCPM_OBseries_anysig_DEGs$external_gene_name %>% unique %>% length))
cat(magenta("\nJUM differential genes: ", tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% length))
cat(magenta("\nPSI-Sigma differential genes: ", tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% length))
cat(magenta("\nmajiq differential genes: ", tibble_majiq_differential_with_na$gene_name %>% unique %>% length))

# JUM diff spliced vs. diff. expression
cat(magenta("\nJUM differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene) %>% unique %>% length))

# PSI-Sigma diff spliced vs. diff. expression
cat(magenta("\nPSI-Sigma differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# MAJIQ diff spliced vs. diff. expression
cat(magenta("\nmajiq differential genes vs. diff. expressed genes: ", intersect(logCPM_OBseries_anysig_DEGs$external_gene_name, tibble_majiq_differential_with_na$gene_name) %>% unique %>% length))

# JUM diff spliced vs. PSI-Sigma diff spliced
cat(magenta("\nJUM differential genes vs. PSI-Sigma differential genes: ", intersect(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# majiq diff spliced vs. jum diff
cat(magenta("\nmajiq differential genes vs. jum differential genes: ", intersect(tibble_majiq_differential_with_na$gene_name, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene) %>% unique %>% length))

# majiq spliced vs. PSI-Sigma diff spliced
cat(magenta("\nmajiq differential genes vs. PSI-Sigma differential genes: ", intersect(tibble_majiq_differential_with_na$gene_name, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique %>% length))

# fetch list of ALWAYS differentially spliced genes vs. ALWAYS constitutively spliced genes
vector_genes_differentially_spliced <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique
vector_genes_constitutively_spliced <- c(tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$Gene, tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique

# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[!tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %in% logCPM_OBseries_anysig_DEGs$external_gene_name, ] %>% .$splicemode %>% table %>% plot

vector_genes_both_diff_and_cons_spliced <- intersect(vector_genes_differentially_spliced, vector_genes_constitutively_spliced)
cat("vector_genes_both_diff_and_cons_spliced:", vector_genes_both_diff_and_cons_spliced %>% length)

vector_genes_differentially_spliced_only <- setdiff(vector_genes_differentially_spliced, vector_genes_both_diff_and_cons_spliced) %>% mixedsort
cat("vector_genes_differentially_spliced_only:", vector_genes_differentially_spliced_only %>% length)
vector_genes_constitutively_spliced_only <- setdiff(vector_genes_constitutively_spliced, vector_genes_both_diff_and_cons_spliced) %>% mixedsort
cat("vector_genes_constitutively_spliced_only:", vector_genes_constitutively_spliced_only %>% length)

```

## determine the genes in common per enrichment

### FUNCTION TO LOOK FOR OVERLAPS IN EACH GO-TERM BETWEEN TWO TABLES (GOhyperGall)

```{r}

extract_common_GOTerms_GOhyperGall <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: GOID, NodeSize, Term, Ont
  colnames(tibble_1)[c(3, 4, 5, 8)] <- paste(colnames(tibble_1)[c(3, 4, 5, 8)], "_1", sep = "")
  colnames(tibble_2)[c(3, 4, 5, 8)] <- paste(colnames(tibble_2)[c(3, 4, 5, 8)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("GOID", "NodeSize", "Term", "Ont"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$SampleKeys_1)), which(is.na(joined_tibble$SampleKeys_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
  # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$SampleKeys_1, .y = joined_tibble$SampleKeys_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### FUNCTION TO LOOK FOR OVERLAPS IN EACH ENRICHMENT BETWEEN TWO TABLES (bc3net::enrichment())

```{r}

extract_common_GOTerms_bc3net <- function(tibble_1, tibble_2) {
  
  # DEBUG ###
  # tibble_1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO
  # tibble_2 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO
  ###########
  
  # rename column names in preparation for table joining
  ## columns which are the exceptions: c("TermID", "all")
  colnames(tibble_1)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_1)[c(2, 3, 4, 5, 6)], "_1", sep = "")
  colnames(tibble_2)[c(2, 3, 4, 5, 6)] <- paste(colnames(tibble_2)[c(2, 3, 4, 5, 6)], "_2", sep = "")
  
  # full join by ID columns
  joined_tibble <- dplyr::full_join(tibble_1, tibble_2, by = c("TermID"))
  # remove NA resulting from join
  ## get row indices of NA, where enrichment is present in only one but not both tibbles
  row.indices_of_na <- c(which(is.na(joined_tibble$genes_contained_1)), which(is.na(joined_tibble$genes_contained_2)))
  if (length(row.indices_of_na) != 0) {
    
    joined_tibble <- joined_tibble[-row.indices_of_na, ]
    
  }
  
    # calculate intersections
  joined_tibble_with_intersections <- joined_tibble %>% 
    add_column("genes_in_common" = purrr::map2(.x = joined_tibble$genes_contained_1, .y = joined_tibble$genes_contained_2, 
                                               .f = ~dplyr::intersect(.x %>% strsplit(split = " ") %>% unlist, 
                                                                      .y %>% strsplit(split = " ") %>% unlist) %>% paste(collapse = " ")) %>% unlist) %>%
    add_column("genes_in_common_count" = .$genes_in_common %>% purrr::map(~strsplit(.x, split = " ") %>% unlist %>% length) %>% unlist)
  
  # finally sort the tibble by the number of genes in common
  joined_tibble_with_intersections_sorted <- joined_tibble_with_intersections %>% dplyr::arrange(desc(genes_in_common_count))
  
  return(joined_tibble_with_intersections_sorted)
  
}

```

### calculate intersections

```{r}

tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO <-
  extract_common_GOTerms_GOhyperGall(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO, 
                                     tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO)

write.table(tibble_GOTerm_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_all.GO_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_all.GO, 
            paste(results_dir, "intersection_GOTerm_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM <-
  extract_common_GOTerms_bc3net(tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM, 
                                tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM)

write.table(tibble_PFAM_intersection_tibble_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_PFAM_vs_tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na_PFAM, 
            paste(results_dir, "intersection_PFAM_JUM_differential_dpsi0.15_qvalue0.01_anysig_with_na_vs_PSIsigma_differential_dpsi0.10_pvalue0.01_anysig_with_na.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

```

## Do GO enrichment (anysig) on both combined.

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

### hypergeometric test for GO terms

```{r}

# create vector of differential genes
vector_differential_genes_anysig_with_na <- c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, 
                                              tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% 
  strsplit(split = ",") %>% unlist %>% unique

# count number of differential genes
number.of.genes_differential_anysig_with_na <- vector_differential_genes_anysig_with_na %>% length

cat("\n", number.of.genes_differential_anysig_with_na, "unique annotated genes differentially spliced between any two time points during the time course of osteogenic differentiation")

# create list of GO categories
list_GO_categories <- c("MF", "BP", "CC") %>% array_tree

# map GO test
list_of_GO_test_tibbles_anysig_with_na_raw <- purrr::map(.x = list_GO_categories, .f = ~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = vector_differential_genes_anysig_with_na, Nannot = 2) %>% GOHyperGAll_benjamini_correction %>% type_convert) %>% set_names(list_GO_categories)

# filter out the top ~30 most significant GO terms for each node
list_of_GO_test_tibbles_anysig_with_na_top.hits <- purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_raw, .f = ~dplyr::arrange(.x, Phyper) %>% head(n = 900) %>% dplyr::filter(NodeSize < 1500) %>% dplyr::mutate_at(.vars = "Term", .funs = function(x) {stringr::str_trunc(string = x, side = "right", width = 78) %>% return}))

# print out the top hits of the GO enrichment
purrr::map(.x = list_of_GO_test_tibbles_anysig_with_na_top.hits, .f = ~.x %>% print)

# collapse into a long tibble for plot
long_tibble_GO_test_anysig_with_na_top.hits <- list_of_GO_test_tibbles_anysig_with_na_top.hits %>% rbindlist %>% as_tibble

```

#### bar graph of GO terms

```{r}

# OB series

ggplot(long_tibble_GO_test_anysig_with_na_top.hits, aes(x = reorder(Term, -Phyper), y = -log10(Phyper))) +
  geom_col(aes(fill = SampleMatch)) +
  scale_fill_distiller(name = "Number of genes enriched", type = "seq", palette = "Purples", direction = 1, aesthetics = "fill", na.value = "yellow") +
  geom_hline(yintercept = -log10(0.05), lty = 2) +
  coord_flip() +
  facet_wrap(Ont ~ ., ncol = 3, scales = "free_y") +
  ggtitle(paste("Top 900 significantly over-represented GO terms for OB series for JUM and PSI-Sigma combined")) +
  xlab("GO term") +
  ylab(expression(log["10"](P))) +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype="solid", colour ="black"), text = element_text(family ="Helvetica")) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) +
 ggsave(filename = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 200, units = "cm", limitsize = FALSE) 

# write table of top 30 results
write.table(x = long_tibble_GO_test_anysig_with_na_top.hits, file = paste(results_dir, "top_900_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of every enrichment
write.table(x = list_of_GO_test_tibbles_anysig_with_na_raw %>% purrr::map(~dplyr::arrange(.x, Phyper)) %>% rbindlist, file = paste(results_dir, "top_inf_GOterms_OB_series_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
# write table of geneset
write.table(x = vector_differential_genes_anysig_with_na, file = paste(results_dir, "geneset_OBseries_combined_JUM_PSIsigma_anysig_with_na.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
  
```

#### explore the kinases 

```{r}

vector_all_kinase_genes <- long_tibble_GO_test_anysig_with_na_top.hits[long_tibble_GO_test_anysig_with_na_top.hits$Term == "protein kinase activity", "SampleKeys"] %>% unlist %>% strsplit(split = " ") %>% unlist

# convert to ENSG
vector_all_kinase_ENSG <- getBM(attributes = "ensembl_gene_id", filters = "external_gene_name", values = vector_all_kinase_genes, mart = ensembl_mart) %>% unlist

# subset JUM and PSI-Sigma tibbles by kinase genes
tibble_JUM_differential_kinase_only <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %in% vector_all_kinase_genes, ]

tibble_JUM_differential_kinase_only %>% dplyr::group_by(splicemode) %>% dplyr::summarise(n())

tibble_PSIsigma_differential_kinase_only <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %in% vector_all_kinase_genes, ]

tibble_PSIsigma_differential_kinase_only %>% dplyr::distinct(database_ID, event_region_coords, diff_exon_coords, .keep_all = TRUE) %>% dplyr::group_by(splicemode) %>% dplyr::summarise(n())

# look at exon/junction ontology

tibble_JUM_junction_ontology_transcripts_kinase_only <- tibble_JUM_junction_ontology_transcripts[tibble_JUM_junction_ontology_transcripts$Gene %in% vector_all_kinase_genes, ] %>% split_delimited_columns_in_table(target_colname = "transcript_features", split = ",") %>% dplyr::group_by(transcript_features) %>% dplyr::summarise(n())
tibble_JUM_junction_ontology_biomart_kinase_only <- tibble_JUM_junction_ontology_biomart[tibble_JUM_junction_ontology_biomart$Gene %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::group_by(Gene) %>% dplyr::summarise("any_mobidblite" = mobidblite %>% is.na %>% all == FALSE, "any_seg" = mobidblite %>% is.na %>% all == FALSE, "any_interpro" = interpro %in% tibble_non_family_interpro_entries$Accession %>% any, "kinase_domain")

tibble_JUM_junction_ontology_biomart[tibble_JUM_junction_ontology_biomart$Gene %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::distinct(AS_event_ID, Name) %>% dplyr::group_by(Name) %>% dplyr::summarise(n())



tibble_JUM_junction_ontology_PTMs_kinase_only <- tibble_JUM_junction_ontology_PTMs[tibble_JUM_junction_ontology_PTMs$Gene %in% vector_all_kinase_genes, ] %>% dplyr::group_by(PTM_type) %>% dplyr::summarise(n())

tibble_PSIsigma_exon_ontology_transcripts_kinase_only <- tibble_PSIsigma_exon_ontology_transcripts[tibble_PSIsigma_exon_ontology_transcripts$matched_gene_names %in% vector_all_kinase_genes, ] %>% split_delimited_columns_in_table(target_colname = "tibble_overlapping_parent_transcript_features", split = ",") %>% dplyr::group_by(tibble_overlapping_parent_transcript_features) %>% dplyr::summarise(n())
tibble_PSIsigma_exon_ontology_biomart_kinase_only <- tibble_PSIsigma_exon_ontology_biomart[tibble_PSIsigma_exon_ontology_biomart$matched_gene_names %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::group_by(matched_gene_names) %>% dplyr::summarise("any_mobidblite" = mobidblite %>% is.na %>% all == FALSE, "any_seg" = mobidblite %>% is.na %>% all == FALSE, "any_interpro" = interpro %in% tibble_non_family_interpro_entries$Accession %>% any)


tibble_PSIsigma_exon_ontology_biomart[tibble_PSIsigma_exon_ontology_biomart$matched_gene_names %in% vector_all_kinase_genes, ] %>% dplyr::left_join(., tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% dplyr::rename("interpro" = "Accession")) %>% dplyr::distinct(event_region_coords, diff_exon_coords, Name) %>% dplyr::group_by(Name) %>% dplyr::summarise(n())


tibble_PSIsigma_exon_ontology_PTMs_kinase_only <- tibble_PSIsigma_exon_ontology_PTMs[tibble_PSIsigma_exon_ontology_PTMs$matched_gene_names %in% vector_all_kinase_genes, ] %>% dplyr::group_by(PTM_type) %>% dplyr::summarise(n())

tibble_RNAi_RSA_results <- read.delim(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/MSC.to.OB_kinase.siRNA.screen/analysis_RSA/results/R_processing/RSA_results_summary.txt", header = TRUE, row.names = NULL, stringsAsFactors = FALSE, sep = "\t") %>% as_tibble

# match the RNAi dataset to the kinases identified as differentially spliced
tibble_RNAi_results_diffspliced <- tibble_RNAi_RSA_results[tibble_RNAi_RSA_results$ensembl_gene_id %in% vector_all_kinase_ENSG, ] %>% dplyr::mutate("avg_bothscreens" = (`avg_screen_1` + `avg_screen_2`)/2)

# PVALUE vs. expression PLOT
# plot the negative regulators
ggplot_rnai_negregs <- ggplot(data = tibble_RNAi_results_diffspliced, aes(x = `avg_bothscreens`, y = -`logP_negregs_both.screens`, ggplotlylabel = Gene, colour = (logP_negregs_screen.1 < log10(0.05) | logP_negregs_screen.2 < log10(0.05)), shape = (logP_negregs_screen.1 < log10(0.05) & logP_negregs_screen.2 < log10(0.05)), alpha = (logP_negregs_screen.1 < log10(0.05) & logP_negregs_screen.2 < log10(0.05)))) +
  geom_point() +
  scale_colour_manual(name = "anysig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c("red", "grey75")) +
  scale_shape_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(16, 1)) +
  scale_alpha_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(1, 0.33)) +
  ggtitle("negregs") +
  # scale_x_continuous(breaks = seq(0.6, 1.8, 0.2), limits = c(0.6, 1.8)) +
  xlab("Knockdown fold change in ALP") +
  xlim(c(0.75, 1.75)) +
  ylab("-log10P") +
  ylim(c(0, 4.5)) +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"), panel.grid.major = element_blank(), panel.grid.minor = element_blank())

ggplot_rnai_negregs + 
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_negregs.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 3.5, units = "cm") +
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_negregs.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 3.5, units = "cm")

ggplotly(ggplot_rnai_negregs, tooltip = "ggplotlylabel") %>% htmlwidgets::saveWidget(widget = ., file = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_negregs.html", sep = ""), selfcontained = FALSE)

# plot the positive regulators
ggplot_rnai_posregs <- ggplot(data = tibble_RNAi_results_diffspliced, aes(x = `avg_bothscreens`, y = -`logP_posregs_both.screens`, ggplotlylabel = Gene, colour = (logP_posregs_screen.1 < log10(0.05) | logP_posregs_screen.2 < log10(0.05)), shape = (logP_posregs_screen.1 < log10(0.05) & logP_posregs_screen.2 < log10(0.05)), alpha = (logP_posregs_screen.1 < log10(0.05) & logP_posregs_screen.2 < log10(0.05)))) +
  geom_point() +
  scale_colour_manual(name = "anysig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c("blue", "grey75")) +
  scale_shape_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(16, 1)) +
  scale_alpha_manual(name = "bothsig", limits = c(TRUE, FALSE), breaks = c(TRUE, FALSE), values = c(1, 0.33)) +
  ggtitle("posregs") +
  # scale_x_continuous(breaks = seq(0.7, 1.7, 0.3), limits = c(0.7, 1.7)) +
  xlab("Knockdown fold change in ALP") +
  xlim(c(0.75, 1.75)) +
  ylab("-log10P") +
  ylim(c(0, 4.5)) +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"), panel.grid.major = element_blank(), panel.grid.minor = element_blank())

ggplot_rnai_posregs +
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_posregs.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 3.5, units = "cm") +
  ggsave(filename = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_posregs.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 3.5, units = "cm")

ggplotly(ggplot_rnai_posregs, tooltip = "ggplotlylabel") %>% htmlwidgets::saveWidget(widget = ., file = paste(results_dir, "RNAi_diffspliced_pvalue_vs_expression_scatterplot_posregs.html", sep = ""), selfcontained = FALSE)

options(mc.cores = 144)

# permtest for negregs significance
permtest <- future_map(.x = 1:100000, .f = function(a1) {
  
  set.seed(a1)
  
  tibble_RNAi_RSA_results[sample(1:nrow(tibble_RNAi_RSA_results), size = 59), "logP_negregs_both.screens"] %>% unlist %>% 
    return
  
}, .progress = TRUE )

rand_avg <- mean(permtest %>% unlist)
rand_stdev <- sd(permtest %>% unlist)

```

## plot the interpro and PTM results from JUM and PSI-Sigma together 

### interpro

```{r}

tibble_combined_interpro_RNAlevel <- dplyr::full_join(tibble_JUM_junction_ontology_biomart_plots, tibble_PSIsigma_exon_ontology_biomart_plots, by = c("interpro_id", "interpro_description", "interpro_identifier")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  na.omit %>%
  tail(n = 15) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("interpro_id", "interpro_description", "interpro_identifier"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_interpro_RNAlevel, aes(x = `interpro_description`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_interpro_RNAlevel$tally %>% max * 1.3)) +
  ggtitle("Top 10 interpro domains, JUM and PSI-Sigma, differential") +
  xlab("Interpro domain") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 15, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 15, units = "cm")

```

### PTMs

```{r}

tibble_combined_PTMs_RNAlevel <- dplyr::full_join(tibble_JUM_junction_ontology_PTMs_plots, tibble_PSIsigma_exon_ontology_PTMs_plots, by = c("PTM_type")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("PTM_type"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_PTMs_RNAlevel, aes(x = `PTM_type`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_PTMs_RNAlevel$tally %>% max(na.rm = TRUE) * 1.3)) +
  ggtitle("Top 10 PTMs, JUM and PSI-Sigma, differential") +
  xlab("PTM type") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 14, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 14, units = "cm")

```

## find out why JUM and PSI-Sigma's PTM matching results are different - not necessary anymore!

```{r}

# join the PTM results onto the differential tables
# tibble_JUM_differential_PTM_ontology_with_info <- dplyr::left_join(tibble_JUM_junction_ontology_PTMs, tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na, by = c("AS_event_ID", "splicemode")) %>% dplyr::distinct(AS_event_ID, splicemode, .keep_all = TRUE)
# tibble_PSIsigma_differential_PTM_ontology_with_info <- dplyr::left_join(tibble_PSIsigma_exon_ontology_PTMs, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na, by = c("diff_exon_coords", "splicemode")) %>% dplyr::distinct(diff_exon_coords, splicemode, .keep_all = TRUE)

```

### investigate dbPTM distribution of phosphosities vs. ubsites - not necessary anymore!

```{r}

# plot(density(tibble_dbPTM_allhuman_annotations %>% dplyr::filter(PTM_type == "Phosphorylation") %>% .$modified_residue_position))

# retrieve protein length annotations from ensembl
# tibble_uniprotkb_to_protein_length <- getBM(filters = "uniprot_gn_id", values = tibble_dbPTM_allhuman_annotations$uniprotkb_entry, attributes = "cds_length", mart = ensembl_mart)

```

## Look for coordinate-level overlap between CLIP-Seq sites and differential/constitutive VSRs.

### set match tolerances

```{r}

# size of RBP footprint or splicing enhancer/silencer site
RBP_footprint_start <- 0
RBP_footprint_end <- 0

# window upstream/downstream beyond the VSR to account for exonic SS/SEs
VSR_tolerance_start <- 100
VSR_tolerance_end <- 100

```

### extract chr start end from the VSR coordinates for both JUM and PSI-Sigma

```{r}

tibble_AS.event.IDs_chr_start_end_differential <- tibble(
  "AS_event_ID" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode) %>%
  unique
  
  tibble_AS.event.IDs_chr_start_end_constitutive <- tibble(
  "AS_event_ID" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode) %>%
  unique

tibble_psisigma_differential_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

tibble_psisigma_constitutive_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

```

### Determine overlap

```{r}

plan(list(tweak(multiprocess, workers = 32),
          tweak(multiprocess, workers = 8)))

list_clipseq_tibbles <- list(
  "SRSF2 HITS-CLIP GSE111900" = tibble_peakfile_SRSF2_hits.clip_GSE111900_HEL_p0.01,
  "HNRNPA1 eCLIP ENCODE" = tibble_bedfile_HNRNPA1_eclip_ENCODE_K562_combined_p0.01,
  "HNRNPA2B1 HITS-CLIP GSM1716538" = `tibble_bedfile_HNRNPA2B1_hits.clip_GSM1716538_MDA-MB-231_hg38_height20`,
  "MBNL1 HITS-CLIP GSE76486" = `tibble_bedfile_MBNL1_hits.clip_GSE76486_MDA-MB-231_hg38`,
  "PRPF4 eCLIP ENCODE" = tibble_bedfile_PRPF4_eclip_ENCODE_HepG2_combined_p0.01,
  "RBM15 eCLIP ENCODE" = tibble_bedfile_RBM15_eclip_ENCODE_HepG2_combined_p0.01,
  "SFPQ eCLIP ENCODE" = tibble_bedfile_SFPQ_eclip_ENCODE_HepG2_combined_p0.01,
  "SUGP2 eCLIP ENCODE" = tibble_bedfile_SUGP2_eclip_ENCODE_HepG2_combined_p0.01,
  "TRA2A eCLIP ENCODE" = tibble_bedfile_TRA2A_eclip_ENCODE_K562_combined_p0.01,
  "SNRPA eCLIP GSM4512295" = tibble_peakfile_SNRPA_eclip_GSM4512295_HEK293T_hg38_p0.01
) %>% purrr::map(.x = ., .f = ~.x %>% dplyr::mutate_at(.vars = "chr", .funs = function(x) {x[which(x == "M")] <- "MT"; return(x)} ))

list_clipseq_tibbles <- purrr::splice(list_FLASHseq_tibbles_hg38, 
                                      list_clipseq_tibbles)


# cross JUM/PSI-sigma diff/const. with each of the CLIP-Seq peakfiles.
list_clipseq_peakfiles_x_jum_psisigma_tibbles <- purrr::cross2(
  .x = list_clipseq_tibbles,
  .y = list(
    dplyr::bind_rows(tibble_AS.event.IDs_chr_start_end_differential, tibble_psisigma_differential_chr_start_end),
    dplyr::bind_rows(tibble_AS.event.IDs_chr_start_end_constitutive, tibble_psisigma_constitutive_chr_start_end)
  )
)

# also cross names for traceability
list_clipseq_peakfiles_x_jum_psisigma_tibbles_names <- purrr::cross2(
  .x = names(list_clipseq_tibbles),
  .y = list(
    "JUM_and_PSIsigma_differential",
    "JUM_and_PSIsigma_constitutive"
  )
)

# calculate overlap
list_overlaps_clipseq_peakfiles_x_jum_psisigma <- furrr::future_map2(
  .x = list_clipseq_peakfiles_x_jum_psisigma_tibbles,
  .y = list_clipseq_peakfiles_x_jum_psisigma_tibbles_names,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_clipseq_peakfiles_x_jum_psisigma_tibbles[[1]]
    # a2 <- list_clipseq_peakfiles_x_jum_psisigma_tibbles_names[[1]]
    ###########
    
    tibble_clipseq_regions <- a1[[1]]
    
    ## loop thru each SF and look for overlap with CLIP-Seq region within a tolerance range
    ## list-ify the SF chr and coords.
    list_query_VSR_coord_array.tree <- a1[[2]][, c("chr", "start", "end")] %>% array_tree
    
    ## parallel loop thru each list-ified SF to find whether there is a match with an entry in the CLIP-Seq data.
    vector_matched_VSR_with_CLIP_seq_logical <- future_map(.x = list_query_VSR_coord_array.tree,
                                                           .f = function(b1) {
                                                             
                                                             # DEBUG ###
                                                             # b1 <- list_query_VSR_coord_array.tree[[1]]
                                                             ###########
                                                             
                                                             any(tibble_clipseq_regions$chr == b1$chr & 
                                                                   (tibble_clipseq_regions$start %>% type.convert) <= ((b1$end %>% type.convert) + VSR_tolerance_end) &
                                                                   (tibble_clipseq_regions$end %>% type.convert) >= ((b1$start %>% type.convert) - VSR_tolerance_start)) %>% return
                                                             
                                                           }, .progress = TRUE, .options = future_options(globals = c("tibble_clipseq_regions", "VSR_tolerance_start", "VSR_tolerance_end")) ) %>% unlist
    
    # filter the original coord table by those that overlapped with clip-seq data.
    tibble_VSRs_with_overlap <- a1[[2]][which(vector_matched_VSR_with_CLIP_seq_logical), ]
    
    # for the VSRs with overlap, extract the clipseq regions that matched
    list_tibble_VSRs_with_overlap_with_matched_clipseq_regions <- purrr::map(
      .x = tibble_VSRs_with_overlap %>% array_tree,
      .f = function(b1) { 
        
        # DEBUG ###
        # b1 <- tibble_VSRs_with_overlap %>% array_tree %>% .[[1]]
        ###########
        
        tibble_clipseq_regions_inside_VSR <- tibble_clipseq_regions[tibble_clipseq_regions$chr == b1$chr & 
                                                                      (tibble_clipseq_regions$start %>% type.convert) <= ((b1$end %>% type.convert) + VSR_tolerance_end) &
                                                                      (tibble_clipseq_regions$end %>% type.convert) >= ((b1$start %>% type.convert) - VSR_tolerance_start), ]
        
        names(tibble_clipseq_regions_inside_VSR) <- paste("clipseq_", names(tibble_clipseq_regions_inside_VSR), sep = "")
        
        # tibblise the matched VSR tibble entry
        tibble_matched_VSR_entry <- b1 %>% as_tibble
        
        names(tibble_matched_VSR_entry) <- paste("VSR_", names(tibble_matched_VSR_entry), sep = "")
        
        # bind cols and return 
        tibble_VSR_entry_matched_to_overlapping_clipseq_entries <- dplyr::bind_cols(tibble_matched_VSR_entry, tibble_clipseq_regions_inside_VSR)
        
        return(tibble_VSR_entry_matched_to_overlapping_clipseq_entries)
        
      } )
    
    # rbind and tibblise
    tibble_VSRs_with_overlap_with_matched_clipseq_regions <- list_tibble_VSRs_with_overlap_with_matched_clipseq_regions %>% rbindlist %>% as_tibble
    
    return(list(tibble_VSRs_with_overlap, tibble_VSRs_with_overlap_with_matched_clipseq_regions) %>% 
             set_names(c(paste(a2[[2]], a2[[1]], "tibble_VSRs_with_overlap", sep = "|"),
                         paste(a2[[2]], a2[[1]], "tibble_VSRs_with_overlap_with_matched_clipseq_regions", sep = "|"))))
    
  }, .progress = TRUE, .options = future_options(globals = c("VSR_tolerance_start", "VSR_tolerance_end")) )

list_overlaps_clipseq_peakfiles_x_jum_psisigma <- list_overlaps_clipseq_peakfiles_x_jum_psisigma %>% purrr::flatten()

save(list_overlaps_clipseq_peakfiles_x_jum_psisigma, file = paste(results_dir, "list_overlaps_clipseq_peakfiles_x_jum_psisigma.Rlist", sep = ""))

```

### Match the VSR coordinates back to the combinedexpr PSI timeseries tables, find the clusters regulated by each SF

```{r}

wide_tibble_consensus_combinedexpr_clusters <- read.delim(file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_wide.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# table join back onto the JUM/PSIsigma combinedexpr tables.
list_JUM_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table <- list_overlaps_clipseq_peakfiles_x_jum_psisigma[grep(x = names(list_overlaps_clipseq_peakfiles_x_jum_psisigma), pattern = "differential.*tibble_VSRs_with_overlap$")] %>% purrr::map(~dplyr::semi_join(wide_tibble_consensus_combinedexpr_clusters ,.x %>% dplyr::rename("category" = "splicemode") %>% .[!is.na(.$AS_event_ID), ], by = c("AS_event_ID", "category")))

list_PSIsigma_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table <- list_overlaps_clipseq_peakfiles_x_jum_psisigma[grep(x = names(list_overlaps_clipseq_peakfiles_x_jum_psisigma), pattern = "differential.*tibble_VSRs_with_overlap$")] %>% purrr::map(~dplyr::semi_join(wide_tibble_consensus_combinedexpr_clusters, .x %>% dplyr::rename("category" = "splicemode") %>% .[!is.na(.$event_region_coords), ], by = c("event_region_coords", "category")))

# combine the lists of tibbles
list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table <- purrr::map2(.x = list_JUM_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table, .y = list_PSIsigma_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table, .f = ~dplyr::bind_rows(.x, .y))

# do a headcount of the number of targets per cluster
list_JUM_PSIsigma_combined_diff_targets_per_cluster <- purrr::map(.x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table, .f = ~.x %>% dplyr::group_by(cluster) %>% dplyr::summarise("no_targets_per_cluster" = `id` %>% unique %>% length) %>% dplyr::arrange(desc(no_targets_per_cluster)))

# extract genesets
list_geneset_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq <- list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% purrr::map(~.x$gene %>% unique %>% mixedsort)

```

results of previous chunk:
SRSF1 (DS 2, 3): <NOTHING>
SRSF2 (DE 4) (DS 1, 2, 7): HNRNPA1, HNRNPH1, SRRM2, SRSF1/5
SRSF3 (DS 2): HNRNP2AB1, SNRNP70, SRRM2, SRSF1/2, TRA2B
SRSF5 (DS 1): HNRNPH1, SRRM2, SRSF2
SRSF6 (DS 1, 2, 4, 7): HNRNPA2B1, HNRNPH1, PRPF4B, SFPQ, SRSF1/2/11
SRSF11 (DS 1, 5, 8, 10, 12): CIRBP, HNRNPA2B1, HNRNPH1, RBM6/25/39, SFPQ, SRRM2, SRSF2, U2AF1L4

HNRNPA1 (DE 4) (DS 4): HNRNPA1, HNRNPA2B1, SRSF6, TRA2A/B
HNRNPA2B1 (DE 4) (DS 1, 2, 4, 5): HNRNPA1, HNRNPA2B1, HNRNPDL, HNRNPH1, RBM39, SFPQ, SRSF5/6, TRA2A

MBNL1 (DS 1, 2, 3, 6, 7, 13, 14): MBNL1, SNRNP70, TRA2A

PRPF4 (DE 6): RBM6, SRRM2

RBM15 (DE 6): MBNL1, RBM6

SFPQ (DE 4) (DS 1, 7): HNRNPH1, RBM6, SFPQ, SRRM2, TRA2A/B

TRA2A (DS 1, 3, 4, 9): SFPQ, SNRNP70, SRRM2, SRSF1/2, TRA2A/B

SNRPA (DE 4): HNRNPA1, HNRNPA2B1, SNRNP70, SRSF6, TRA2A/B

NOTE: we will have to consider BOTH cluster AND anti-clusters because we can't make any assumptions about the positive/negative regulation of splicing by splicing factors.

### GO analysis of genes targeted by SF

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

# map GO test
## NOTE: we are going to consider only gene targets that co-clustered with the SFs.
## therefore map alongside the cluster specifications
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms <- future_pmap(
  .l = list(
    "a1" = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table[!grepl(x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")], 
    "a2" = list(
      "JUM_and_PSIsigma_differential|SRSF1 FLASH GSE118265" = c(2, 3, 4, 6),
      "JUM_and_PSIsigma_differential|SRSF2 FLASH GSE118265" = c(4, 2),
      "JUM_and_PSIsigma_differential|SRSF3 FLASH GSE118265" = c(4, 2),
      "JUM_and_PSIsigma_differential|SRSF5 FLASH GSE118265" = c(7, 1),
      "JUM_and_PSIsigma_differential|SRSF6 FLASH GSE118265" = c(1, 2, 4, 7),
      "JUM_and_PSIsigma_differential|SRSF11 FLASH GSE118265" = c(5, 12),
      "JUM_and_PSIsigma_differential|HNRNPA1 eCLIP ENCODE" = c(4, 2),
      "JUM_and_PSIsigma_differential|HNRNPA2B1 HITS-CLIP GSM1716538" = c(4, 2),
      "JUM_and_PSIsigma_differential|MBNL1 HITS-CLIP GSE76486" = c(2, 7, 1, 4),
      "JUM_and_PSIsigma_differential|PRPF4 eCLIP ENCODE" = c(3, 6),
      "JUM_and_PSIsigma_differential|RBM15 eCLIP ENCODE" = c(3, 6),
      "JUM_and_PSIsigma_differential|SFPQ eCLIP ENCODE" = c(4, 2),
      "JUM_and_PSIsigma_differential|SUGP2 eCLIP ENCODE" = c(3, 2, 4, 5, 6, 12, 13, 14),
      "JUM_and_PSIsigma_differential|TRA2A eCLIP ENCODE" = c(1, 4, 2, 7),
      "JUM_and_PSIsigma_differential|SNRPA eCLIP GSM4512295" = c(4, 2)
    ), 
    "a3" = names(list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table[!grepl(x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")])
  ),
  .f = function(a1, a2, a3) {
    
    target_entries <- a1[a1$cluster %in% a2, ]
    
    geneset <- a1[a1$cluster %in% a2, "gene"] %>% unlist %>% unique %>% mixedsort
    
    list_GO_tables <- future_map(.x = c("MF", "BP", "CC"),
               .f = function(b1) {
                 
                 cat(a3, "\n")
                 
                 systemPipeR::GOHyperGAll(catdb = catdb, gocat = b1, sample = geneset, Nannot = 2) %>% GOHyperGAll_benjamini_correction(FDR_cutoff = 1) %>% type_convert %>% as_tibble
                 
               }, .options = future_options(globals = c("systemPipeR::GOHyperGAll", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble"))) %>% set_names(c("MF", "BP", "CC"))
    
    return(list(
      "target_entries" = target_entries,
      "geneset" = geneset,
      "list_GO_tables" = list_GO_tables
    ))
    
  }, .progress = TRUE, .options = future_options(globals = c("systemPipeR::GOHyperGAll", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble"))) %>% 
  set_names(names(list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table[!grepl(x = list_JUM_PSIsigma_combined_diff_VSR_overlapping_clip_seq_matched_to_combinedexpr_table %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")]))

# extract the GO term tables and geneset
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms %>% purrr::map(~.x$list_GO_tables)
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms %>% purrr::map(~.x$geneset)
list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_geneset_targets_and_GOterms %>% purrr::map(~.x$target_entries)

# plot the GO terms into a a cute rectangular heatmap
## rbind the GO enrichmnent tables
long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms <- purrr::map2(
  .x = list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms,
  .y = names(list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms),
  .f = function(a1, a2) {
    
    a1 %>% 
      purrr::reduce(dplyr::bind_rows) %>%
      add_column("sample" = a2) %>%
      return
    
  } ) %>% purrr::reduce(dplyr::bind_rows)

## filter out samples we don't need
long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms <- long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms %>% 
  dplyr::mutate_at(.vars = "sample", .funs = function(x) {gsub(x = x, pattern = "^(.*)\\|(.*)\\|(.*)", replacement = "\\2")} ) 

## ggplot
### set the order of sample
vector_clipseq_sample_order_for_ggplot <- long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms$sample %>% unique %>% mixedsort
### set the order of GO terms
vector_clipseq_goterm_order_for_ggplot <- c(
  # BP
  "mRNA splicing, via spliceosome", "histone modification", "focal adhesion assembly", "mitotic cell cycle phase transition",
  # MF
  "chromatin binding", "transcription coregulator activity", "protein kinase regulator activity",
  # CC
  "focal adhesion", "actin cytoskeleton"
  ) %>% rev

ggplot(long_tibble_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_GOterms) +
  geom_tile(aes(x = sample, y = Term, fill = Padj)) +
  facet_wrap(facets = ~Ont, scales = "free", ncol = 1) +
  ggtitle(paste("Heatmap of GO Terms for public CLIP-Seq targets (differential)", sep = "")) +
  scale_x_discrete(breaks = vector_clipseq_sample_order_for_ggplot, labels = vector_clipseq_sample_order_for_ggplot, limits = vector_clipseq_sample_order_for_ggplot, position = "top") +
  scale_y_discrete(breaks = vector_clipseq_goterm_order_for_ggplot, labels = vector_clipseq_goterm_order_for_ggplot, limits = vector_clipseq_goterm_order_for_ggplot) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black", "black"), values = c(0, 0.5, 0.94, 0.95, 1), trans = "reverse") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 0, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_combinedexpr_diff_public_clipseq_GOterms.pdf", sep = ""), device = "pdf", dpi = 600, width = 17, height = 25, units = "cm", limitsize = FALSE) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_combinedexpr_diff_public_clipseq_GOterms.svg", sep = ""), device = "svg", dpi = 600, width = 17, height = 25, units = "cm", limitsize = FALSE)

```

## JUM/PSI-Sigma and Ago2 iCLIP

### determine gene-level overlap between differentially spliced genes and Ago2 iCLIP

```{r}

# JUM
## convert transcript_ids to gene_stable_id
# vector_JUM_gene_stable_ids <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$matched_ref_transcript_names %>% strsplit(split = "\\;") %>% purrr::map(~.x %>% type.convert %>% na.omit) %>% future_map(.f = ~tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$transcript_stable_ID %in% .x), "gene_stable_ID"] %>% unlist, .progress = TRUE) %>% unlist

vector_JUM_gene_names <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique

vector_JUM_gene_stable_ids <- tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$gene_name %in% vector_JUM_gene_names), "gene_stable_ID"] %>% unlist %>% unique


tibble_ago2_iclip_binding_sites_JUM_genes <- tibble_ago2_iclip_binding_sites %>% dplyr::filter(`3'UTR` %in% vector_JUM_gene_names |
                                                                                                 `5'UTR` %in% vector_JUM_gene_names |
                                                                                                 `CDS` %in% vector_JUM_gene_names |
                                                                                                 `antisense_gene` %in% vector_JUM_gene_names |
                                                                                                 `lncRNA` %in% vector_JUM_gene_stable_ids)

# PSI-Sigma
## convert transcript_ids to gene_stable_id
vector_PSIsigma_gene_names <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% strsplit(split = "\\,") %>% unlist %>% type.convert %>% unique

vector_PSIsigma_gene_stable_ids <- tibble_ensembl_gene_name_transcript_stable_id_mapping[which(tibble_ensembl_gene_name_transcript_stable_id_mapping$gene_name %in% vector_PSIsigma_gene_names), "gene_stable_ID"] %>% unlist %>% unique

tibble_ago2_iclip_binding_sites_PSIsigma_genes <- tibble_ago2_iclip_binding_sites %>% dplyr::filter(`3'UTR` %in% vector_PSIsigma_gene_names |
                                                                                                 `5'UTR` %in% vector_PSIsigma_gene_names |
                                                                                                 `CDS` %in% vector_PSIsigma_gene_names |
                                                                                                 `antisense_gene` %in% vector_PSIsigma_gene_names |
                                                                                                 `lncRNA` %in% vector_PSIsigma_gene_stable_ids)

```

### determine if there's any VSR-level overlap between differential regions/exons and Ago2 iCLIP

```{r}

# JUM
## create list of vectors of differential positions (genomic coords)
list_of_vectors_JUM_differential_exon_positions <- tibble_JUM_junction_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_JUM <- future_map2(.x = list_of_vectors_JUM_differential_exon_positions,
                                                                      .y = tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree,
                                                                      .f = function(a1, a2) {
                                                                        
                                                                        # DEBUG ###
                                                                        # a1 <- list_of_vectors_JUM_differential_exon_positions[[1]]
                                                                        # a2 <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree %>% .[[1]]
                                                                        ###########
                                                                        
                                                                        # get chromosome
                                                                        current_chr <- gsub(x = a2$AS_event_ID, pattern = "^([^\\_]+)\\_.*", replacement = "\\1")
                                                                        
                                                                        # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                        vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_ago2_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                        
                                                                        # retrieve iCLIP entries based on logical index
                                                                        tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                        
                                                                        return(purrr::splice(a2,
                                                                                             "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                      }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_JUM_pruned <- list_matched_iCLIP_entries_per_differential_region_JUM %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_JUM_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_JUM_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("AS_event_ID", "splicemode", "Gene")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

# write table
write.table(x = tibble_differential_region_JUM_with_iclip_ago2, file = paste(results_dir, "tibble_differential_region_JUM_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# PSI-Sigma
## create list of vectors of differential positions (genomic coords)
list_of_vectors_PSIsigma_differential_exon_positions <- tibble_PSIsigma_exon_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_PSIsigma <- future_map2(.x = list_of_vectors_PSIsigma_differential_exon_positions,
                                                                           .y = tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")] %>% array_tree,
                                                                           .f = function(a1, a2) {
                                                                             
                                                                             # DEBUG ###
                                                                             # a1 <- list_of_vectors_PSIsigma_differential_exon_positions[[1]]
                                                                             # a2 <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")] %>% array_tree %>% .[[1]]
                                                                             ###########
                                                                             
                                                                             # get chromosome
                                                                             current_chr <- gsub(x = a2$diff_exon_coords, pattern = "^([^\\:]+)\\:.*", replacement = "\\1")
                                                                             
                                                                             # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                             vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_ago2_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                             
                                                                             # retrieve iCLIP entries based on logical index
                                                                             tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                             
                                                                             return(purrr::splice(a2,
                                                                                                  "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                           }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_PSIsigma_pruned <- list_matched_iCLIP_entries_per_differential_region_PSIsigma %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_PSIsigma_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_PSIsigma_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("diff_exon_coords", "splicemode", "matched_gene_names", "matched_strand")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

# write table
write.table(x = tibble_differential_region_PSIsigma_with_iclip_ago2, file = paste(results_dir, "tibble_differential_region_PSIsigma_with_iclip_ago2.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## Draw a consensus SOM which merges JUM and PSI-Sigma together.

### Tally up the number of repeated VSRs per gene.

```{r}

tibble_exon_tally_per_gene_PSIsigma <- tibble_PSIsigma_5x5_som_clustered %>% 
  split_delimited_column_in_table(input_table = ., target_colname = "matched_gene_names", split = ",") %>%
  dplyr::distinct(matched_gene_names, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(event_region_coords, .keep_all = TRUE) %>%
  dplyr::group_by(matched_gene_names) %>% 
  dplyr::summarise("PSIsigma_tally" = n()) %>%
  dplyr::arrange(desc(PSIsigma_tally)) %>%
  dplyr::rename("Gene" = "matched_gene_names")

ggplot(data = tibble_exon_tally_per_gene_PSIsigma %>% na.omit, aes(x = PSIsigma_tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("PSI-Sigma tally, diff_exon_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

tibble_AS_event_ID_tally_per_gene_JUM <- tibble_JUM_5x5_som_clustered %>% 
  dplyr::distinct(Gene, cluster, .keep_all = TRUE) %>%
  dplyr::distinct(AS_event_ID, .keep_all = TRUE) %>%
  dplyr::group_by(Gene) %>% 
  dplyr::summarise("JUM_tally" = n()) %>%
  dplyr::arrange(desc(JUM_tally))

ggplot(data = tibble_AS_event_ID_tally_per_gene_JUM %>% na.omit, aes(x = JUM_tally)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_nudge(x = 0, y = 5), angle = 90) +
  scale_x_reverse() +
  ggtitle("JUM tally, AS_event_ID per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

# merge the two tallies together for co-plotting
tibble_AS_event_ID_tally_per_gene_combined <- dplyr::full_join(tibble_AS_event_ID_tally_per_gene_JUM, tibble_exon_tally_per_gene_PSIsigma, by = "Gene")

tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")][is.na(tibble_AS_event_ID_tally_per_gene_combined[, c("JUM_tally", "PSIsigma_tally")])] <- 0

# melt into long form for combined ggplot
long_tibble_AS_event_ID_tally_per_gene_combined <- tibble_AS_event_ID_tally_per_gene_combined %>%
  na.omit %>%
  reshape2::melt(id.vars = "Gene", value.name = "tally", variable.name = "tool") %>% as_tibble

long_tibble_AS_event_ID_tally_per_gene_combined[, "tally"] <- long_tibble_AS_event_ID_tally_per_gene_combined$tally %>% as.character

write.table(x = long_tibble_AS_event_ID_tally_per_gene_combined, file = paste(results_dir, "long_tibble_VSR_tally_per_gene_combined.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
write.table(x = tibble_AS_event_ID_tally_per_gene_combined, file = paste(results_dir, "wide_tibble_VSR_tally_per_gene_combined.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# create tally frequency
long_tibble_AS_event_ID_tally_per_gene_combined_tally <- long_tibble_AS_event_ID_tally_per_gene_combined %>% 
  dplyr::group_by(tool, tally) %>% 
  dplyr::summarise("frequency" = n()) %>% 
  # tidyr complete for consistent bar width
  tidyr::complete(tool, tally)

# combined tally plot
ggplot(data = long_tibble_AS_event_ID_tally_per_gene_combined_tally, aes(x = tally, y = frequency, fill = tool)) +
  geom_bar(stat = "identity", position = position_dodge(width = 1)) +
  geom_text(stat = "identity", aes(label = frequency), position = position_dodge(width = 1), angle = 90, hjust = -0.1) +
  scale_x_discrete(breaks = c(1 : max(long_tibble_AS_event_ID_tally_per_gene_combined$tally)) %>% as.character, limits = c(1 : max(long_tibble_AS_event_ID_tally_per_gene_combined$tally)) %>% as.character) +
  scale_fill_manual(breaks = c("JUM_tally", "PSIsigma_tally"), labels = c("JUM", "PSI-Sigma"), values = c("purple3", "firebrick4")) +
  ylim(c(0, 900)) +
  ggtitle("Combined tally, AS_event_ID/event_region_coords per gene") +
  ylab("Frequency") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_highest_LSVs_per_gene_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 6, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_highest_LSVs_per_gene_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 6, units = "cm")

```

### preprocessing of tables in preparation for mixing

```{r}

# create unique ID that can be traced.
tibble_PSIsigma_scaled_PSI_timeseries_wide_processed <- tibble_PSIsigma_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("PSIsigma", .$matched_gene_names, .$database_ID, .$event_region_coords, .$diff_exon_coords, .$splicemode, sep = "|")) %>%
  dplyr::select(id, vector_OBseries_timepoints_edited)

tibble_JUM_scaled_PSI_timeseries_wide_processed <- tibble_JUM_scaled_PSI_timeseries_wide %>% 
  add_column("id" = paste("JUM", .$Gene, .$AS_event_ID, .$sub_junction_start_coor, .$sub_junction_end_coor, .$splicemode, sep = "|")) %>%
  dplyr::select(id, c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d"))

# join
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- dplyr::bind_rows(tibble_PSIsigma_scaled_PSI_timeseries_wide_processed, tibble_JUM_scaled_PSI_timeseries_wide_processed)

# rescale values
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### Skim off the top and bottom most included exons/LSVs to get biomarkers at each timepoint.

```{r}

# melt into long form
long_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% reshape2::melt(id.vars = "id", variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# subset by timepoint
list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint <- purrr::map(.x = long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint %>% unique,
                                                                               .f = ~long_tibble_JUM_PSIsigma_PSI_timeseries_merged[long_tibble_JUM_PSIsigma_PSI_timeseries_merged$timepoint == .x, ])

# take the items with scaled PSI greater/less than +/-1.
# rbind and tibblise
list_biomarkers_JUM_PSIsigma_per_timepoint <- list(
  "inclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value >= 1)),
  "exclusion" = list_long_tibble_JUM_PSIsigma_PSI_timeseries_merged_by_timepoint %>% purrr::map(~dplyr::filter(.x, scaled_PSI_value <= -1))
) %>% purrr::map(~rbindlist(.x) %>% as_tibble)

# create tally of counts to determine which markers are unique
# splice in unique counts
list_biomarkers_JUM_PSIsigma_per_timepoint <- list_biomarkers_JUM_PSIsigma_per_timepoint %>% 
  purrr::map(~dplyr::left_join(.x, .x %>% dplyr::group_by(id) %>% dplyr::summarise("uniqueness_tally" = n()))) %>%
  purrr::splice(
    "unique_inclusion" = .$inclusion %>% dplyr::filter(uniqueness_tally == 1),
    "unique_exclusion" = .$exclusion %>% dplyr::filter(uniqueness_tally == 1)
  )

# save the list
save(list_biomarkers_JUM_PSIsigma_per_timepoint, file = paste(results_dir, "list_biomarkers_JUM_PSIsigma_per_timepoint.Rlist", sep = ""))

```

### TRADITIONAL SOM

#### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

OB_xdim <- 5
OB_ydim <- 5

number_of_som_clusters <- OB_xdim * OB_ydim

# remove na
wide_tibble_JUM_PSIsigma_PSI_timeseries_merged <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% add_column("id" = rownames(.)) %>% na.omit %>% .$id, ]

somdata_5_by_5_OBseries <- som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, vector_OBseries_timepoints_edited] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_table_of_final_SOM_summary_5_by_5_OBseries <- cbind(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, c("id", vector_OBseries_timepoints_edited)], cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_table_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("id", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### THE GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_grid(quotient_facet.y ~ remainder_facet.x) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "SOM of PSI values for JUM and PSI-Sigma")) +
  scale_x_discrete(limits = c("MSC", "6h", "12h", "24h", "3d", "6d", "9d", "12d"), labels = c("MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")) +
  xlab("Time-point") +
  ylab("Scaled PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 33, height = 20, units = "cm") +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 33, height = 20, units = "cm")

write.table(x = wide_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

options(mc.cores = 32)

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("wide_tibble_JUM_PSIsigma_PSI_timeseries_merged", "dplyr", "som")) ) %>% as.data.frame

wide_tibble_JUM_PSIsigma_PSI_timeseries_merged[, "id"] <- paste(1:nrow(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged), wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id, sep = "_")

# use "id" column as rownames
rownames(wide_table_som_sweep_clusters) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

rm(list_matchtest_som_sweep_byisoform)

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 72)
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for clustering by PSI\nOB spliceome: JUM and PSI-Sigma", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combined_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED LEVELS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combined_.*seedeverynode.tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, wide_tibble_JUM_PSIsigma_PSI_timeseries_merged %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1"), pattern = "\\|", n = 6) %>% as_tibble %>% setNames(c("S1", "S2", "S3", "S4", "S5", "S6")),
                                                             wide_tibble_consensus_clusters_MQ_ratios) %>%
  # preallocate columns
  add_column("method" = "NA",
             "gene" = "NA", 
             "item_id" = "NA", 
             "category" = "NA", 
             "sub_junction_start" = "NA",
             "sub_junction_end" = "NA", 
             "matched_strand" = "NA", .after = "S6")

# shuffle the ids around
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S1"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S2"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S2"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S1"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "item_id"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S4"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S6"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S3"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_start"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_end"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "matched_strand"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios <- wide_tibble_consensus_clusters_MQ_ratios %>%
  dplyr::select(-S1, -S2, -S3, -S4, -S5, -S6) %>% 
  type_convert %>%
  dplyr::mutate_at(.vars = "cluster", as.character)

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

cat("\nnumber of unique items originally: ", gsub(x = wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id, pattern = "^[^_]+_(.*)", replacement = "\\1") %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1") %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
vector_items_chucked_out <- setdiff(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged$id %>% unique, wide_tibble_consensus_clusters_MQ_ratios$id %>% unique)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("method", "gene", "item_id", "category", "sub_junction_start", "sub_junction_end", "matched_strand", "cluster", "id"), variable.name = "timepoint", value.name = "scaled_PSI") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_PSI" = mean(scaled_PSI))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_PSI, group = paste(id)), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_PSI, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI\n",
                "JUM and PSI-Sigma\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled MQ ratios") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_timeseries_PSI_profiles_combined_JUM_PSIsigma_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster, separate and summed PSI

#### preparation of separate data frames containing gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "table_JUM_PSisigma_consensus_combined_GOterms.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

## ggplot
### set the order of sample
vector_combined_JUM_PSIsigma_cluster_order_for_ggplot <- c(1, 2, 3, 4, 5, 6, 7, 10, 11, 14, 15) %>% as.character
### set the order of GO terms
vector_combined_JUM_PSIsigma_goterm_order_for_ggplot <- c(
  # BP
  "cell cycle", "mRNA splicing, via spliceosome", "histone modification", "post-Golgi vesicle-mediated transport", "regulation of autophagy of mitochondrion",
  # MF
  "extracellular matrix structural constituent", "cell adhesion molecule binding", "transcription factor binding", "transcription coregulator activity", "protein kinase activity", "GTPase binding",
  # CC
  "focal adhesion", "actin cytoskeleton", "cell cortex", "microtubule cytoskeleton"
  ) %>% rev

ggplot(tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma) +
  geom_tile(aes(x = cluster, y = Term, fill = Phyper, color = (Padj <= 0.05) %>% as.character), size = 0.5) +
  # facet_wrap(facets = ~Ont, scales = "free", ncol = 1) +
  ggtitle(paste("Heatmap of GO Terms for JUM/PSI-Sigma combined consensus clusters(differential)", sep = "")) +
  scale_x_discrete(breaks = vector_combined_JUM_PSIsigma_cluster_order_for_ggplot, labels = vector_combined_JUM_PSIsigma_cluster_order_for_ggplot, limits = vector_combined_JUM_PSIsigma_cluster_order_for_ggplot, position = "top") +
  scale_y_discrete(breaks = vector_combined_JUM_PSIsigma_goterm_order_for_ggplot, labels = vector_combined_JUM_PSIsigma_goterm_order_for_ggplot, limits = vector_combined_JUM_PSIsigma_goterm_order_for_ggplot) +
  scale_fill_gradientn(colours = c("white", "yellow", "red", "black", "black"), values = c(0, 0.5, 0.94, 0.96, 1), trans = "reverse") + 
  scale_colour_manual(limits = c("TRUE", "FALSE"), breaks = c("TRUE", "FALSE"), labels = c("Padj <= 0.05", "Padj > 0.05"), values = c("green", "white")) + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 0, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_consensus_combined_GOterms.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 8, units = "cm", limitsize = FALSE) +
  ggsave(filename = paste(results_dir, "heatmap_JUM_PSisigma_consensus_combined_GOterms.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 8, units = "cm", limitsize = FALSE)

```

### Family enrichment of each SOM cluster

Separate and sum PSI

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(.x = list_of_genesets_by_cluster, .y = names(list_of_genesets_by_cluster), .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column("cluster" = .y), .progress = TRUE)

# tibble of everything PFAM results
tibble_consensus.SOM_family.enrichment_clusterwise <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

# save PFAM family tables (all)
write.table(x = tibble_consensus.SOM_family.enrichment_clusterwise, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combined_JUM_PSIsigma_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination

list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- purrr::map(.x = list_of_vectors_genesets_per_consensus.SOM_cluster_diffsplicedonly, .f = ~future_map(.x = .x, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE))

# filter gene ontology tables for top hits
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map_depth(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .depth = 2, .ragged = FALSE, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))

# add cluster number into each tibble and combine into single tibble
list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .f = ~purrr::map2(.x = .x, .y = names(.x), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Upstream RBP") +
  ylab("Number of genes targeted by RBP") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_upstreamRBP.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

## Compare GO terms from DEGs with GO terms from DSGs

### generate GO enrichment table for DSGs combined and table join the tibbles

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

tibble_RSEM_edgeR_DEGs_all_GO

tibble_JUM_PSISigma_DSGs_all_GO <- c("MF", "BP", "CC") %>% purrr::map(~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = c(tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene, tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names) %>% unique, Nannot = 2)) %>% rbindlist %>% as_tibble

tibble_RSEM_edgeR_DEGs_all_GO_2 <- tibble_RSEM_edgeR_DEGs_all_GO %>% dplyr::rename("SampleKeys_DEG" = "SampleKeys", "Phyper_DEG" = "Phyper", "Padj_DEG" = "Padj", "SampleMatch_DEG" = "SampleMatch")
tibble_JUM_PSISigma_DSGs_all_GO_2 <- tibble_JUM_PSISigma_DSGs_all_GO %>% dplyr::rename("SampleKeys_DSG" = "SampleKeys", "Phyper_DSG" = "Phyper", "Padj_DSG" = "Padj", "SampleMatch_DSG" = "SampleMatch")

tibble_hyperGO_DSGs_DEGs_joined <- dplyr::inner_join(tibble_RSEM_edgeR_DEGs_all_GO_2, tibble_JUM_PSISigma_DSGs_all_GO_2)

tibble_hyperGO_DSGs_DEGs_joined_filtered <- tibble_hyperGO_DSGs_DEGs_joined %>% dplyr::filter(Phyper_DEG <= 0.05 | Phyper_DSG <= 0.05)

tibble_hyperGO_DSGs_DEGs_joined_filtered <- tibble_hyperGO_DSGs_DEGs_joined_filtered[order(purrr::map2(.x = tibble_hyperGO_DSGs_DEGs_joined_filtered$Padj_DEG, .y = tibble_hyperGO_DSGs_DEGs_joined_filtered$Padj_DSG, .f = ~sqrt(.x * .y)) %>% unlist %>% type.convert), ]

```

## Consensus SOM: Expression co-clustering with JUM and PSI-Sigma

### extract the RBPs, lncRNAs and snRNAs etc... from expression data and combine with PSI data

```{r}

options(mc.cores = 32)

# reorder the columns to make them chronological
logCPM_OBseries_anysig_DEGs <- logCPM_OBseries_anysig_DEGs[, c("ensembl_gene_id", "external_gene_name", "logCPM_BM_MSC_to_OB_ud_avg", "logCPM_BM_MSC_to_OB_6h_avg", "logCPM_BM_MSC_to_OB_12h_avg", "logCPM_BM_MSC_to_OB_24h_avg", "logCPM_BM_MSC_to_OB_3d_avg", "logCPM_BM_MSC_to_OB_6d_avg", "logCPM_BM_MSC_to_OB_9d_avg", "logCPM_BM_MSC_to_OB_12d_avg")]

colnames(logCPM_OBseries_anysig_DEGs) <- c("ensembl_gene_id", "external_gene_name", "MSC", "6h", "12h", "1d", "3d", "6d", "9d", "12d")

# subset CPM table by biological role
## import mapping table
tibble_ENSG_to_GOterm_and_biotype_mapping <- read.delim(file = paste(reference_data_dir, "table_ENSG_to_GOterm_and_biotype_mapping.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL, check.names = FALSE) %>% as_tibble %>%
  setNames(nm = c("ensembl_gene_id", "go_term_name", "transcript_biotype"))

  # RBPs
column_RBP_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$go_term_name == "RNA binding" | tibble_ENSG_to_GOterm_and_biotype_mapping$go_term_name == "spliceosomal complex", "ensembl_gene_id"]

logCPM_OBseries_RBP <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_RBP_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("RBP", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # lncRNA
column_lncRNA_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$transcript_biotype == "lncRNA", "ensembl_gene_id"]

logCPM_OBseries_lncRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_lncRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("lncRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # snRNA
column_snRNA_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$transcript_biotype == "snRNA", "ensembl_gene_id"]

logCPM_OBseries_snRNA <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_snRNA_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("snRNA", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

  # all TF complex 
column_TFcomplex_genes_OBseries <- tibble_ENSG_to_GOterm_and_biotype_mapping[tibble_ENSG_to_GOterm_and_biotype_mapping$transcript_biotype == "protein_coding" & tibble_ENSG_to_GOterm_and_biotype_mapping$go_term_name == "transcription factor complex", "ensembl_gene_id"]

logCPM_OBseries_TFcomplex <- dplyr::semi_join(logCPM_OBseries_anysig_DEGs, column_TFcomplex_genes_OBseries, by = "ensembl_gene_id") %>%
  add_column(., diff_exon_coords = paste("TF complex", .$ensembl_gene_id, sep = "_"), splicemode = "RNASeq", .after = 2)

# combine all the individual logCPM tables into one subsetted expression dataset
logCPM_OBseries_subset <- dplyr::bind_rows(logCPM_OBseries_RBP, logCPM_OBseries_lncRNA, logCPM_OBseries_snRNA, logCPM_OBseries_TFcomplex)

# get rid of ENSG id
logCPM_OBseries_subset <- logCPM_OBseries_subset[, -1]

# rename column before next join

colnames(logCPM_OBseries_subset)[1] <- "matched_gene_names"

# add id column and get rid of the rest
logCPM_OBseries_subset <- logCPM_OBseries_subset %>% 
  add_column("id" = paste(.$matched_gene_names, .$splicemode, .$diff_exon_coords, sep = "|")) %>%
  .[, c("id", vector_OBseries_timepoints_edited)]

# combine logCPM and PSI values
tibble_combinedexpr_logCPM_PSI_unscaled <- dplyr::bind_rows(wide_tibble_JUM_PSIsigma_PSI_timeseries_merged, logCPM_OBseries_subset)

tibble_combinedexpr_logCPM_PSI_scaled <- tibble_combinedexpr_logCPM_PSI_unscaled

# scale values
tibble_combinedexpr_logCPM_PSI_scaled[, vector_OBseries_timepoints_edited] <- tibble_combinedexpr_logCPM_PSI_scaled[, vector_OBseries_timepoints_edited] %>% genescale(m = ., axis = 1, method = "Z")

```

### params

```{r}

mutual_consensus_cutoff <- 0.5

# SET THESE TWO. script will sweep using the "dot product" of the two ranges.
xdim_range_combinedexpr <- c(2, 3, 2, 4, 2, 5, 3, 2, 2, 7, 4, 8, 2, 9, 5, 2, 2, 11, 6, 3, 2, 13, 7, 2, 5, 10, 8, 16, 2, 17)
ydim_range_combinedexpr <- c(3, 2, 4, 2, 5, 2, 4, 6, 7, 2, 4, 2, 9, 2, 4, 10, 11, 2, 4, 8, 13, 2, 4, 14, 6, 3, 4, 2, 17, 2)
# evaluate coverage
plot(density(purrr::map2(xdim_range_combinedexpr, ydim_range_combinedexpr, ~.x * .y) %>% unlist, bw = 0.1), main = "Coverage of SOM sweep")

set.seed(7)

random_seed_numbers <- sample(1:1E5, 5, replace = FALSE)

list_seeds_and_dimensions_to_loop <- purrr::map2(.x = xdim_range_combinedexpr, .y = ydim_range_combinedexpr, .f = ~list(.x, .y)) %>% purrr::cross2(., random_seed_numbers) %>% purrr::map(~flatten(.x))

```

### execute ensemble SOM and create consensus matrix

```{r}

# EXECUTE CONSENSUS SOM 
wide_table_som_sweep_clusters <- future_imap(.x = list_seeds_and_dimensions_to_loop, .f = function(.x, .y) {
  
  # DEBUG ###
  # .x <- list_seeds_and_dimensions_to_loop[[1]]
  ###########
  
  cat("\nprocessing", .y)
  
  set.seed(.x[[3]])
  
  som(tibble_combinedexpr_logCPM_PSI_scaled %>% dplyr::select(-id) %>% as.matrix, grid = somgrid(xdim = .x[[1]], ydim = .x[[2]], topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE, dist.fcts = "sumofsquares") %>% .[["unit.classif"]] %>% tibble::enframe(., name = NULL)
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_combinedexpr_logCPM_PSI_scaled", "dplyr", "genescale", "som")) ) %>% as.data.frame

# use "id" column as rownames
tibble_combinedexpr_logCPM_PSI_scaled[, "id"] <- paste(1:nrow(tibble_combinedexpr_logCPM_PSI_scaled), tibble_combinedexpr_logCPM_PSI_scaled$id, sep = "_")

rownames(wide_table_som_sweep_clusters) <- tibble_combinedexpr_logCPM_PSI_scaled$id

# pairwise test between all items for every sweep to see if they were co-occurring
list_matchtest_som_sweep_byisoform <- purrr::map(wide_table_som_sweep_clusters %>% array_tree, ~unlist(.x)) %>% 
  future_map(.f = ~apply(X = wide_table_som_sweep_clusters, MARGIN = 1, FUN = function(X){.x == X}), .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters")))

# calculate percentage consensus pairwise between any two items.
list_percentage_consensus_per_item <- future_map(list_matchtest_som_sweep_byisoform, ~apply(X = .x, MARGIN = 2, FUN = function(X){sum(X)/length(X)}) %>% t(.) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("apply", "wide_table_som_sweep_clusters", "as_tibble", "dplyr")))

rm(list_matchtest_som_sweep_byisoform)

# rbind to obtain consensus matrix
matrix_consensus_matrix <- list_percentage_consensus_per_item %>% rbindlist %>% as.matrix
rownames(matrix_consensus_matrix) <- tibble_combinedexpr_logCPM_PSI_scaled$id

# re-order the consensus matrix
matrix_consensus_matrix_dist_result <- matrix_consensus_matrix %>% parallelDist::parDist(method = "euclidean", threads = 64)
matrix_consensus_matrix_hclust_result <- fastcluster::hclust(matrix_consensus_matrix_dist_result, method = "ward.D2")
matrix_consensus_matrix_dendrogram <- as.dendrogram(matrix_consensus_matrix_hclust_result)
# take rowmeans: cols/rows should get darker as you move right/down
matrix_consensus_matrix_rowmeans <- rowMeans(matrix_consensus_matrix, na.rm = T)
# matrix_consensus_matrix_PCA_loadings_byrow <- prcomp(matrix_consensus_matrix) %>% .[["rotation"]] %>% .[, 1]
# matrix_consensus_matrix_singular_vectors_byrow <- apply(matrix_consensus_matrix, 1 , FUN = function(X) {svd(X) %>% .$d})

matrix_consensus_matrix_dendrogram_reordered <- reorder(matrix_consensus_matrix_dendrogram, matrix_consensus_matrix_rowmeans)

save(matrix_consensus_matrix_dendrogram_reordered, file = paste(results_dir, "matrix_consensus_combinedexpr_matrix_dendrogram_reordered.matrix", sep = ""))

ggdendrogram(matrix_consensus_matrix_dendrogram_reordered) +
  theme(axis.text.x = element_text(size = 2), axis.title.x = element_text(margin = margin(r = 300)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "dendrogram_som_consensus_matrix_combinedexpr_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 200, height = 150, units = "cm", limitsize = FALSE)

# retrieve the order of rows from the dendrogram
matrix_consensus_matrix_dendrogram_reordered_order <- matrix_consensus_matrix_dendrogram_reordered %>% unlist
# implement reorder
tibble_consensus_matrix_reordered <- matrix_consensus_matrix[matrix_consensus_matrix_dendrogram_reordered_order, matrix_consensus_matrix_dendrogram_reordered_order] %>% as_tibble(rownames = "id")

# write the consensus matrix table to file
write.table(x = tibble_consensus_matrix_reordered, file = paste(results_dir, "heatmap_som_consensus_matrix_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)
save(tibble_consensus_matrix_reordered, file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_reordered.tibble", sep = ""))
load(file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_reordered.tibble", sep = ""))

# tibble_consensus_matrix_reordered <- read.delim(file = paste(results_dir, "heatmap_som_consensus_matrix_combined_JUM_PSIsigma.txt", sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% as_tibble

# melt table for ggplot
tibble_consensus_matrix_long <- reshape2::melt(tibble_consensus_matrix_reordered, id = c("id"), value.name = "cocluster_percentage") %>% type_convert %>% as_tibble %>% mutate_at(.vars = c("id", "variable"), as.character)

save(tibble_consensus_matrix_long, file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_long.tibble", sep = ""))
load(file = paste(results_dir, "tibble_combinedexpr_consensus_matrix_long.tibble", sep = ""))

ggplot(tibble_consensus_matrix_long, aes(fill = cocluster_percentage)) +
  geom_tile(aes(x = id, y = variable)) +
  ggtitle(paste("Consensus matrix for co-clustering by PSI and logCPM\nJUM and PSI-Sigma + RSEM/EdgeR", sep = "")) +
  scale_x_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_y_discrete(breaks = tibble_consensus_matrix_reordered$id, labels = tibble_consensus_matrix_reordered$id, limits = tibble_consensus_matrix_reordered$id) +
  scale_fill_gradientn(colours = c("lightblue2", "white", "yellow", "red", "black"), values = c(0, 0.25, 0.5, 0.75, 1)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 0.25, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, axis.text.y = element_text(size = 0.25, lineheight = 0.75, colour = "black"), axis.title.x = element_text(margin = margin(r = 300)), axis.title.y = element_text(margin = margin(r = 50)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "heatmap_som_combinedexpr_consensus_matrix_combined_JUM_PSIsigma.tiff", sep = ""), device = "tiff", dpi = 600, width = 30, height = 25, units = "cm", limitsize = FALSE)

# CLUSTER DETERMINATION #####
# loop along the consensus matrix variables
list_ids_for_looping <- tibble_consensus_matrix_reordered$id %>% unique %>% array_tree

# debugging purposes only 
# list_ids_for_looping <- list_ids_for_looping[c(1:50, 1000:1050)]

# for every item, retrieve its friends above a specified "mutual_consensus_cutoff"
list_cooccurring_items <- future_map(.x = list_ids_for_looping, .f = ~tibble_consensus_matrix_long[tibble_consensus_matrix_long$variable == .x & tibble_consensus_matrix_long$cocluster_percentage >= mutual_consensus_cutoff, "id"], .progress = TRUE, .options = future_options(globals = c("tibble_consensus_matrix_long", "mutual_consensus_cutoff")))

names(list_cooccurring_items) <- list_ids_for_looping

# take pairwise intersections ###
pairwise_comparisons_between_items <- combn(list_ids_for_looping %>% unlist, m = 2) %>% t %>% as_tibble
colnames(pairwise_comparisons_between_items) <- c("comparison_1", "comparison_2")

# each level 1 element is a comparison of each pairwise intersection
vector_comparison_1 <- pairwise_comparisons_between_items$comparison_1
vector_comparison_2 <- pairwise_comparisons_between_items$comparison_2

# NOTE: EACH L1 ELEMENT OF THE LIST MUST BE A TIBBLE. IF IT ISN'T THE WHOLE THING IS STUFFED.

list_itemwise_intersection <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::intersect(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::intersect"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_intersection")

list_itemwise_setdiff <- future_map2(.x = vector_comparison_1, .y = vector_comparison_2, .f = ~dplyr::setdiff(list_cooccurring_items[[.x]], list_cooccurring_items[[.y]]) %>% nrow, .progress = TRUE, .options = future_options(globals = c("list_cooccurring_items", "dplyr::setdiff"))) %>% unlist %>% as.data.frame %>% as_tibble %>% setNames("coclustering_setdiff")

# append the intersection and setdiff metrics onto the tibble of pairwise comparisons. this will be the edge table!!
tibble_pairwise_edges_unfiltered <- bind_cols(pairwise_comparisons_between_items %>% as_tibble, list_itemwise_intersection[, 1], list_itemwise_setdiff[, 1])

tibble_pairwise_edges_unfiltered <- add_column(tibble_pairwise_edges_unfiltered, "jaccard" = tibble_pairwise_edges_unfiltered$coclustering_intersection/(tibble_pairwise_edges_unfiltered$coclustering_setdiff + tibble_pairwise_edges_unfiltered$coclustering_intersection))

write.table(x = tibble_pairwise_edges_unfiltered, file = paste(results_dir, "consensus_edge_table_anyintersection_consensus0.5_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# tibble_pairwise_edges_unfiltered <- read_delim(paste(results_directory_figures, "list_genes_or_isoforms_from_combinedexpr_itemwise_anyintersection_consensus0.5.txt", sep = ""), delim = "\t")

# filter for pairwise neighbours in common > 0
tibble_pairwise_edges_filtered <- tibble_pairwise_edges_unfiltered[tibble_pairwise_edges_unfiltered$coclustering_intersection > 0, ]

save(tibble_pairwise_edges_filtered, file = paste(results_dir, "tibble_pairwise_edges_combinedexpr_filtered.tibble", sep = ""))

pdf(file = paste(results_dir, "densityplot_PNC_distribution_combinedexpr_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$coclustering_intersection %>% as.numeric), 
     main = paste("Density distribution of pairwise neighbours in common", sep = "\n"))
dev.off()

pdf(file = paste(results_dir, "densityplot_jaccard_distribution_combinedexpr_JUM_PSIsigma.pdf", sep = ""), width = 20, height = 15)
plot(density(tibble_pairwise_edges_filtered$jaccard %>% as.numeric), 
     main = paste("Density distribution of jaccard similarity", sep = "\n"))
dev.off()

write.table(x = tibble_pairwise_edges_filtered, file = paste(results_dir, "consensus_edge_table_intersection1_consensus0.5_combinedexpr_JUM_PSIsigma.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### GO TO CYTOSCAPE HERE

### RETURN FROM CYTOSCAPE, CREATE CLUSTERED SCALED MQ RATIOS

```{r}

# grep the corresponding cluster table from file
filename_of_clusterGO_result <- list.files(path = results_dir, pattern = paste("consensus_combinedexpr_.*seedeverynode.tab$", sep = ""))

tibble_cytoscape_result <- read.delim(paste(results_dir, filename_of_clusterGO_result, sep = ""), sep = "\t", header = TRUE, row.names = NULL) %>% setNames(c("cluster", "id")) %>% as_tibble

tibble_cytoscape_result[, "cluster"] <- gsub(x = tibble_cytoscape_result$cluster, pattern = "Cluster ", replacement = "")

tibble_cytoscape_result <- tibble_cytoscape_result %>% type_convert

# split the cytoscape cluster result into a list, clusterwise
list_cytoscape_cluster_results <- purrr::map(.x = tibble_cytoscape_result$cluster %>% unique, .f = ~tibble_cytoscape_result[tibble_cytoscape_result$cluster == .x, ] %>% dplyr::mutate_at(.vars = "id", as.character))

# bind the standardised PSI information to the cluster information
list_MQ_ratios_scaled_clustered <- purrr::map(.x = list_cytoscape_cluster_results, .f = ~dplyr::left_join(.x, tibble_combinedexpr_logCPM_PSI_scaled %>% type_convert %>% dplyr::mutate_at(.vars = "id", as.character), by = "id"))

wide_tibble_consensus_clusters_MQ_ratios <- list_MQ_ratios_scaled_clustered %>% purrr::reduce(dplyr::bind_rows)

cat("\nnumber of unique items originally: ", tibble_combinedexpr_logCPM_PSI_scaled$id %>% unique %>% length)
cat("\nnumber of unique items after ClusterONE: ", wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% length)

# get a list of items which were chucked out by clusterONE
tibble_items_chucked_out <- dplyr::anti_join(tibble_combinedexpr_logCPM_PSI_scaled$id %>% unique %>% tibble::enframe(name = NULL, value = "id"),
                                             wide_tibble_consensus_clusters_MQ_ratios$id %>% unique %>% tibble::enframe(name = NULL, value = "id"), by = "id")

# write the items that got chucked out
write.table(x = tibble_items_chucked_out, file = paste(results_dir, "consensus_combinedexpr_items_chucked_out.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

# remove TSS from PSI-Sigma ids
wide_tibble_consensus_clusters_MQ_ratios[, "id"] <- gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "TSS\\|", replacement = "")
# i fucked up the delimiting for expression
wide_tibble_consensus_clusters_MQ_ratios[, "id"] <- gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "_ENSG", replacement = "\\|ENSG")

# demultiplex the id column
wide_tibble_consensus_clusters_MQ_ratios <- dplyr::bind_cols(stringr::str_split_fixed(string = gsub(x = wide_tibble_consensus_clusters_MQ_ratios$id, pattern = "^[^_]+_(.*)", replacement = "\\1"), pattern = "\\|", n = 10) %>% as_tibble %>% setNames(c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10")),
                                                             wide_tibble_consensus_clusters_MQ_ratios) %>%
  # preallocate columns
  add_column("method" = "NA",
             "gene" = "NA", 
             "database_ID" = "NA", 
             "event_region_coords" = "NA", 
             "diff_exon_coords" = "NA", 
             "AS_event_ID" = "NA",
             "ENSG_ID" = "NA",
             "category" = "NA", 
             "sub_junction_start" = "NA",
             "sub_junction_end" = "NA", .after = "S10")

# shuffle the ids around
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S1"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "method"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S2"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S2"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "gene"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S1"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "AS_event_ID"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "database_ID"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S3"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "event_region_coords"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "diff_exon_coords"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "PSIsigma"), "S5"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "ENSG_ID"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S4"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM|PSIsigma"), "S6"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "category"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S2, pattern = "RNASeq"), "S3"]

wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_start"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S4"]
wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "sub_junction_end"] <- wide_tibble_consensus_clusters_MQ_ratios[grep(x = wide_tibble_consensus_clusters_MQ_ratios$S1, pattern = "JUM"), "S5"]

wide_tibble_consensus_clusters_MQ_ratios <- wide_tibble_consensus_clusters_MQ_ratios %>%
  dplyr::select(-S1, -S2, -S3, -S4, -S5, -S6, -S7, -S8, -S9, -S10) %>% 
  type_convert %>%
  dplyr::mutate_at(.vars = "cluster", as.character)

# reorder the cluster factor for correct facet order
wide_tibble_consensus_clusters_MQ_ratios[, "cluster"] <- factor(wide_tibble_consensus_clusters_MQ_ratios$cluster %>% mixedsort, levels = wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% mixedsort)

### convert the som table to a long form interprable by ggplot
# reshaping into long table
long_tibble_consensus_clusters_MQ_ratios <- reshape2::melt(wide_tibble_consensus_clusters_MQ_ratios, id.vars = c("id", "method", "gene", "database_ID", "event_region_coords", "diff_exon_coords", "AS_event_ID", "ENSG_ID", "category", "sub_junction_start", "sub_junction_end", "cluster"), variable.name = "timepoint", value.name = "scaled_level") %>% as_tibble

# create the tibble of average line 
long_tibble_consensus_clusters_average.line <- long_tibble_consensus_clusters_MQ_ratios %>% dplyr::group_by(cluster, timepoint) %>% 
  dplyr::summarise("avg_level" = mean(scaled_level))

# ggplot of consensus som PSI profiles
ggplot() +
  geom_line(data = long_tibble_consensus_clusters_MQ_ratios, aes(x = timepoint, y = scaled_level, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_consensus_clusters_average.line, aes(x = timepoint, y = avg_level, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap(~cluster) +
  ggtitle(paste("Time series profiles of spliceome PSI and expression logCPM\n",
                "JUM, PSI-Sigma, EdgeR/RSEM\n", sep = "")) +
  scale_x_discrete(limits = vector_OBseries_timepoints_edited, labels = vector_OBseries_timepoints_edited) +
  xlab("Time-point") +
  ylab("Scaled PSI or logCPM") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype ="solid", colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "consensus_combinedexpr_timeseries_profiles.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 20, units = "cm") +
  ggsave(filename = paste(results_dir, "consensus_combinedexpr_timeseries_profiles.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 20, units = "cm")

write.table(x = wide_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_tibble_consensus_clusters_MQ_ratios, file = paste(results_dir, "consensus_combinedexpr_timeseries_profiles_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

### Gene ontology of each SOM cluster

#### preparation of separate data frames containing DIFFSPLICED gene sets of each cluster

```{r}

# create list of SOM clusters
vector_SOM_clusters <- wide_tibble_consensus_clusters_MQ_ratios$cluster %>% unique %>% paste

list_of_wide_consensus_PSI_levels_by_cluster <- purrr::map(.x = vector_SOM_clusters, .f = ~wide_tibble_consensus_clusters_MQ_ratios[wide_tibble_consensus_clusters_MQ_ratios$cluster == .x, ]) %>% set_names(vector_SOM_clusters)

# take gene set for each cluster - all expr and PSI genes
list_of_genesets_by_cluster_diffspliced <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x[.x$method == "JUM" | .x$method == "PSIsigma", ] %>% .$gene %>% strsplit(split = ",") %>% unlist %>% unique)

# take gene set of differntially expressed genes
list_of_genesets_by_cluster_DEG <- purrr::map(.x = list_of_wide_consensus_PSI_levels_by_cluster, .f = ~.x[.x$method == "RNASeq", ] %>% .$gene %>% strsplit(split = ",") %>% unlist %>% unique)

```

#### GO enrichment

##### differentially spliced geneset

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster_diffspliced, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster_diffspliced %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combinedexpr_diffspliced.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

##### differentially expressed geneset

```{r}

# let's try to do all enrichment at once using purrr
# generate combinations of gene sets and GO categories
list_of_combinations_of_genesets_and_GOterms <- cross2(.x = list_of_genesets_by_cluster_DEG, .y = list("MF", "BP", "CC"))
# generate corresponding names and table nrows
list_of_combinations_of_genesets_and_GOterms_names <- cross2(.x = list_of_genesets_by_cluster_DEG %>% names, .y = list("MF", "BP", "CC"))

# gene ontology for each combination
list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise <- future_map2(.x = list_of_combinations_of_genesets_and_GOterms,
                                                                       .y = list_of_combinations_of_genesets_and_GOterms_names,
                                                                       .f = function(a1, a2) {
                                                                         
                                                                         # DEBUG ###
                                                                         # a1 <- list_of_combinations_of_genesets_and_GOterms[[28]]
                                                                         # a2 <- list_of_combinations_of_genesets_and_GOterms_names[[28]]
                                                                         ###########
                                                                         
                                                                         cat("\nnow processing: ", a2[[1]], a2[[2]])
                                                                         
                                                                         GOHyperGAll(catdb = catdb, gocat = a2[[2]], Nannot = 2, sample = a1[[1]]) %>% GOHyperGAll_benjamini_correction %>% type_convert %>% as_tibble %>% add_column("cluster" = a2[[1]]) %>% return
                                                                         
                                                                       } , .progress = TRUE, .options = future_options(globals = c("GOHyperGAll", "catdb", "GOHyperGAll_benjamini_correction", "type_convert", "as_tibble", "add_column")))

# rbind and tibblise
tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma <- list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus.SOM_hyperGOresult_clusterwise_combined_JUM_PSIsigma, file = paste(results_dir, "tibble_consensus.SOM_hyperGOresult_clusterwise_combinedexpr_DEGs.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# ggplot
# get list indices of the GO result tibbles that house the separate PSI info.
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~ggplot(.x, aes(x = reorder(Term, -SampleMatch), y = SampleMatch)) +
  geom_col(aes(fill = log10(Padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented ", .y[[2]], " GO terms for each consensus cluster in OB series (", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("GO term") +
  ylab("Number of genes in GO term") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_DEGs_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_DEGs_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))
   
purrr::map2(.x = list_of_tibbles_consensus.SOM_hyperGOresult_clusterwise_top.hits, .y = list_of_combinations_of_consensus.SOM_genes_and_GOterms_names, .f = ~write.table(x = .x, file = paste(results_dir, "consensus_som_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y[[1]] %>% strsplit(split = "_") %>% unlist %>% .[3], "_DEGs_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_", .y[[2]], "_GO.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

#### Family enrichment of each SOM cluster

##### for diffspliced geneset

```{r}

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(
  .x = list_of_genesets_by_cluster_diffspliced, 
  .y = names(list_of_genesets_by_cluster_diffspliced), 
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_of_genesets_by_cluster_diffspliced[[1]]
    # a2 <- names(list_of_genesets_by_cluster_diffspliced) %>% .[[1]]
    ###########
    
    raw_enrichment_table <- bc3net::enrichment(genes = a1, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction(FDR_cutoff = 1)
    
    raw_enrichment_table %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], a1) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column(cluster = paste(a2)) %>% return 
    
  }, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_pfam_gene_family_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))

# rbind and write table
tibble_consensus_combinedexpr_PFAM_topinf <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus_combinedexpr_PFAM_topinf, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combinedexpr_diffspliced_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

##### for DEG geneset

```{r}

list_of_tibbles_consensus.SOM_family.enrichment_clusterwise <- future_map2(
  .x = list_of_genesets_by_cluster_diffspliced, 
  .y = names(list_of_genesets_by_cluster_diffspliced), 
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_of_genesets_by_cluster_diffspliced[[1]]
    # a2 <- names(list_of_genesets_by_cluster_diffspliced) %>% .[[1]]
    ###########
    
    raw_enrichment_table <- bc3net::enrichment(genes = a1, reference = reference_geneset_universe, genesets = list_of_pfam_gene_family_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction(FDR_cutoff = 1)
    
    raw_enrichment_table %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_pfam_gene_family_categories[.$TermID %>% as.character], a1) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble %>% add_column(cluster = paste(a2)) %>% return 
    
  }, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_pfam_gene_family_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))

# rbind and write table
tibble_consensus_combinedexpr_PFAM_topinf <- list_of_tibbles_consensus.SOM_family.enrichment_clusterwise %>% rbindlist %>% as_tibble

write.table(x = tibble_consensus_combinedexpr_PFAM_topinf, file = paste(results_dir, "tibble_consensus.SOM_PFAM_clusterwise_combinedexpr_DEGs_topinf.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

# plot family enrichment per cluster
purrr::map2(.x = list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_family.enrichment_clusterwise_top.hits), .f = ~ggplot(.x, aes(x = reorder(TermID, -genes), y = genes)) +
  geom_col(aes(fill = log10(padj))) +
  scale_fill_distiller(name = expression(log["10"](P)), type = "seq", palette = "Purples", direction = -1,   aesthetics = "fill", na.value = "yellow") +
  facet_wrap(~cluster, scales = "free") +
  ggtitle(paste("Top 10 significantly over-represented PFAM families for each consensus cluster in OB series (", .y %>% strsplit(split = "_") %>% unlist %>% .[1], ")", sep = "")) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 35)) +
  xlab("Protein Family (PFAM)") +
  ylab("Number of genes in protein family") +
  # coord_cartesian(ylim = c(0, 20)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), strip.background = element_blank(), strip.text.x = element_blank(), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.pdf", sep = ""), device = "pdf", dpi = 600, width = 50, height = 30, units = "cm") +
 ggsave(filename = paste(results_dir, "consensus_som_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_exons_OBseries_any_", pvalue_or_FDR, pvalue_cutoff, "_dPSI", dpsi_cutoff, "_sweep_", min(xdim_range_combinedexpr), "x", min(ydim_range_combinedexpr), "_to_", max(xdim_range_combinedexpr), "x", max(ydim_range_combinedexpr), "_PFAM_families.svg", sep = ""), device = "svg", dpi = 600, width = 50, height = 30, units = "cm"))

purrr::map2(.x = list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_SOM_family.enrichment_clusterwise_top.hits), .f = ~write.table(x = .x, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_", .y %>% strsplit(split = "_") %>% unlist %>% .[1], "_", .y %>% strsplit(split = "_") %>% unlist %>% .[3], "_OB_diff_any_", pvalue_or_FDR, pvalue_cutoff, "_any_deltaPSI_greaterthan_", dpsi_cutoff, "_PFAM_families.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE))

```

### enrichment of upstream RBPs - clusterwise, per gene - DEPRECATED

```{r}

# note: elements will look like: sep.PSI/MF, sum.PSI/MF, sep.PSI/BP, sum.PSI/BP etc...
# gene ontology for each combination
# 
# list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise <- future_map(.x = list_of_genesets_by_cluster, .f = ~bc3net::enrichment(genes = .x, reference = reference_geneset_universe, genesets = list_of_RBP_target_gene_categories, adj = "BH", verbose = FALSE) %>% bc3net_benjamini_correction %>% cbind(., genes_contained = filtering_genehits_from_background_catalogue(list_of_RBP_target_gene_categories[.$TermID %>% as.character], .x) %>% lapply(toString) %>% paste(sep = ", ") %>% unlist) %>% type_convert %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("bc3net::enrichment", "reference_geneset_universe", "list_of_RBP_target_gene_categories", "bc3net_benjamini_correction", "filtering_genehits_from_background_catalogue", "type_convert", "as_tibble")))
# 
# # filter gene ontology tables for top hits
# list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise, .f = ~dplyr::arrange(.x, pval) %>% head(n = 10))
# 
# # add cluster number into each tibble and combine into single tibble
# tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits <- purrr::map2(.x = list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, .y = names(list_of_tibbles_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits), .f = ~cbind(.x, "cluster" = .y)) %>% rbindlist %>% as_tibble
# 
# # reorder cluster as factor
# tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits[, "cluster"] <- factor(tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits$cluster, levels = tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits$cluster %>% unique %>% mixedsort)
# 
# # plot RBP enrichment per cluster
# ggplot(tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits %>% dplyr::arrange(pval), aes(x = reorder(TermID, pval), y = -log10(pval), size = (padj < 0.05) %>% as.character)) +
#   geom_col(aes(fill = genes), colour = "black") +
#   scale_fill_distiller(name = "Number of genes targeted by RBP", type = "seq", palette = "Spectral", direction = -1, aesthetics = "fill", na.value = "yellow") +
#   scale_size_discrete(name = "FDR", breaks = c("TRUE", "FALSE"), limits = c("TRUE", "FALSE"), labels = c("< 0.05", "> 0.05"), range = c(0.1, 0)) +
#   geom_hline(yintercept = -log10(0.05), lty = 2, col = "red") +
#   facet_wrap(~cluster, scales = "free") +
#   ggtitle(paste("Top 10 significantly over-represented upstream RBPs for each consensus cluster in OB series\nJUM, PSI-Sigma, RSEM/EdgeR", sep = "")) +
#   scale_x_discrete(labels = function(x) str_wrap(x, width = 20)) +
#   xlab("Upstream RBP") +
#   ylab(expression(log["10"](p))) +
#   # coord_cartesian(ylim = c(0, 20)) +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5, lineheight = 0.75, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
#  ggsave(filename = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.pdf", sep = ""), device = "pdf", dpi = 600, width = 30, height = 20, units = "cm") +
#  ggsave(filename = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.svg", sep = ""), device = "svg", dpi = 600, width = 30, height = 20, units = "cm")
# 
# write.table(x = tibble_consensus.SOM_upstream.RBP.enrichment_clusterwise_top.hits, file = paste(results_dir, "consensus.SOM_upstreamRBP_clusterwise_combinedexpr_top10.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

# JUM, PSI-Sigma and proteome/phosphoproteome.

## co-clustering of expr and phospho/proteome by MSC, 6h and 1d.

We will not use consensus clustering here. Instead, we will be using plain old SOMs. This is because we only have 3 timepoints to work with.

### merge all 4 datasets.

```{r}

# combine into a tibble
tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d <- dplyr::bind_rows(
  tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na_ud.6h.1d_only %>% 
    dplyr::mutate("id" = paste("JUM", `Gene`, `AS_event_ID`, `splicemode`, `sub_junction_start_coor`, `sub_junction_end_coor`, sep = "|")) %>%
    .[, c("id", "MSC", "6h", "1d")],
  tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na_ud.6h.1d_only %>%
    dplyr::mutate("id" = paste("PSISigma", `matched_gene_names`, `database_ID`, `splicemode`, `event_region_coords`, `diff_exon_coords`, sep = "|")) %>%
    .[, c("id", "MSC", "6h", "1d")],
  # protein_groups
  list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d$con_sp.hsa.canonical.isoforms$protein_groups %>%
    dplyr::mutate("id" = paste("protein_groups", `Gene.names`, `Protein.IDs`, sep = "|")) %>% 
    .[, c("id", "MSC", "6h", "1d")],
  # phosphosites
  list_significant_MQ_scaled_tibbles_matched_to_geneset_per_cluster_MSC_6h_1d$con_sp.hsa.canonical.isoforms$phosphosites %>%
    dplyr::mutate("id" = paste("phosphosites|", `Gene.names`, "|", `Protein`, "|Position.in.peptide", `Position.in.peptide`, sep = "")) %>% 
    .[, c("id", "MSC", "6h", "1d")],
)

```

### TRADITIONAL SOM

#### construction of a 5x5 SOM

```{r}

som_seed_number <- 7

set.seed(som_seed_number)

OB_xdim <- 4
OB_ydim <- 3

number_of_som_clusters <- OB_xdim * OB_ydim

tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d_scaled <- tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d

# rescale values
tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] <- tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] %>% genescale(m = ., axis = 1, method = "Z")

# remove na
tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d <- tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] %>% add_column("id" = rownames(.)) %>% na.omit %>% .$id, ]

somdata_5_by_5_OBseries <- som(tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("MSC", "6h", "1d")] %>% as.matrix, grid = somgrid(xdim = OB_xdim, ydim = OB_ydim, topo = "rectangular", toroidal = FALSE), rlen = 100, keep.data = TRUE)

wide_tibble_of_final_SOM_summary_5_by_5_OBseries <- cbind(tibble_JUM_PSISigma_proteome_phosphoproteome_MSC.6h.1d[, c("id", c("MSC", "6h", "1d"))], cluster = somdata_5_by_5_OBseries[["unit.classif"]]) %>% as_tibble

```

#### convert the som table to a long form interprable by ggplot

Steps:

0. Melt wide table into long form
1. Subtract 1 from the cluster number
2. x-facet is the remainder when mod 5
3. y-facet is the quotient when mod 5
4. in ggplot, the numbers go from 1-5 from top left to top right, then 6-10 on second row left-right... 25 will be bottom right.

```{r}

# OB series #####

# reshaping into long table

long_table_of_final_SOM_summary_5_by_5_OBseries <- reshape2::melt(wide_tibble_of_final_SOM_summary_5_by_5_OBseries, id.vars = c("id", "cluster"), variable.name = "timepoint", value.name = "scaled_PSI_value") %>% as_tibble

# calculating the facet coordinates for 5x5 plot in ggplot

long_table_of_final_SOM_summary_5_by_5_OBseries[, "cluster_minus_1"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster - 1

long_table_of_final_SOM_summary_5_by_5_OBseries[, "remainder_facet.x"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %% 5

long_table_of_final_SOM_summary_5_by_5_OBseries[, "quotient_facet.y"] <- long_table_of_final_SOM_summary_5_by_5_OBseries$cluster_minus_1 %/% 5

# also create a tibble for the average line for each cluster
long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line <- long_table_of_final_SOM_summary_5_by_5_OBseries %>% dplyr::group_by(cluster, timepoint, cluster_minus_1, remainder_facet.x, quotient_facet.y) %>% 
  dplyr::summarise("avg_PSI_value" = mean(scaled_PSI_value))

```

#### THE GGPLOT

all the genes

```{r}

# OB series

ggplot() +
  geom_line(data = long_table_of_final_SOM_summary_5_by_5_OBseries, aes(x = timepoint, y = scaled_PSI_value, group = id), alpha = 0.33) +
  geom_line(data = long_tibble_of_final_SOM_summary_5_by_5_OBseries_average.line, aes(x = timepoint, y = avg_PSI_value, group = cluster), colour = "white", size = 1) +
  scale_colour_manual(values = c("black")) +
  facet_wrap( ~ cluster) +
  ggtitle(paste(OB_xdim, "x", OB_ydim, "\nSOM of PSI (JUM/PSI-Sigma), expr (MQ protein_groups), phosphosites")) +
  scale_x_discrete(limits = c("MSC", "6h", "1d"), labels = c("MSC", "6h", "1d")) +
  xlab("Time-point") +
  ylab("Scaled PSI Level") +
  # guides(colour = FALSE) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family="Helvetica")) +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

write.table(x = wide_tibble_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome_wide.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

write.table(x = long_table_of_final_SOM_summary_5_by_5_OBseries, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome_long.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```
#### GO analysis per cluster

##### catdb

```{r}

load(paste(reference_data_dir, "polyA_RNAseq_GO_background_GOTERM.catdb", sep = ""))

```

##### execute GO analysis

```{r}

# we can look at either what the RNA targets are OR what the proteins/phosphosites are.

# group_split the wide SOM tibble by cluster
list_final_SOM_summary_5_by_5_OBseries <- wide_tibble_of_final_SOM_summary_5_by_5_OBseries %>%
  dplyr::group_split(cluster) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$cluster %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 3)))

# loop thru each cluster x targets/proteins x GO category
# note: this purrr returns nothing.
tibble_SOM_combined_PSI_phospho_proteome_GOterms_per_cluster <- furrr::future_map2(
  .x = list_final_SOM_summary_5_by_5_OBseries,
  .y = names(list_final_SOM_summary_5_by_5_OBseries),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_final_SOM_summary_5_by_5_OBseries[[1]]
    ###########
    
    # extract genesets
    list_genesets <- list(
      "JUM_PSISigma" = a1[grep(x = a1$id, pattern = "JUM|PSISigma"), ] %>% gsub(x = .$id, pattern = "^([^\\|]+)\\|([^\\|]+).*", replacement = "\\2") %>% unique %>% .[. != "NA"],
      "protein_groups_phosphosites" = a1[grep(x = a1$id, pattern = "protein_groups|phosphosites"), ] %>% gsub(x = .$id, pattern = "^([^\\|]+)\\|([^\\|]+).*", replacement = "\\2") %>% unique %>% .[. != "NA"]
    )
    
    furrr::future_map2(
      .x = list_genesets,
      .y = names(list_genesets),
      .f = function(b1, b2) {
        
        furrr::future_map(
          .x = c("BP", "MF", "CC"),
          .f = function(c1) {
            
            GOHyperGAll(catdb = catdb, gocat = c1, Nannot = 2, sample = b1) %>% GOHyperGAll_benjamini_correction %>% return
            
          } ) %>% rbindlist %>% add_column("data_origin" = b2) %>% return
        
      } ) %>% rbindlist %>% add_column("cluster" = a2) %>% return
    
  }, .progress = TRUE) %>% rbindlist %>% as_tibble

write.table(x = tibble_SOM_combined_PSI_phospho_proteome_GOterms_per_cluster, file = paste(results_dir, OB_xdim, "x", OB_ydim, "_SOM_combined_PSI_phospho_proteome_wide_GOterms_per_cluster.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

```

## JUM: Filter the junction/exon ontology by validated junc.exons
### Match the validated JUM junction identifiers to the junction ID

```{r}

# generate mapping of final_identifiers to junction_ID
UNION_junc_coor_table_with_junction_identifier <- read.delim(paste(UNION_junc_coor_path), sep = "\t", stringsAsFactors = FALSE, col.names = c("chr", "start", "end", "strand", "junction_ID"), check.names = FALSE) %>% 
  as_tibble %>%
  dplyr::mutate("junction_identifier" = paste(chr, ":", start, "-", end, ":", strand, sep = "") %>% gsub(pattern = "(.*)0$", replacement = "\\1*"))

tibble_JUM_valid_junc.exons_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_2012.proteome_valid_junc.exons_coding %>%
                                                               dplyr::rename("final_identifier" = "Leading.razor.protein") %>% 
                                                               dplyr::mutate("junction_identifier" = gsub(x = final_identifier, pattern = "JUM_.*junction_", replacement = "")),
                                                             UNION_junc_coor_table_with_junction_identifier,
                                                             by = "junction_identifier")



```

### calculate statistics

loop thru all the junction ontology AS_event_IDs, return the number of contributing junctions that were validated in the proteome.

```{r}

list_number_of_contributing_junctions_validated <- tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique %>% strsplit(split = ",") %>% 
  purrr::map(.f = ~purrr::map(.x = .x, .f = ~any(.x == tibble_JUM_valid_junc.exons_with_junc_ID$junction_ID %>% unique %>% na.omit))) %>% set_names(tibble_JUM_junction_ontology_supp_info$contributing_junctions %>% unique) %>%
  purrr::keep(.p = ~any(.x == TRUE)) %>%
  purrr::map(.f = ~which(.x == TRUE) %>% length)

```

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_JUM_junction_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_JUM_junction_ontology_supp_info,
                                                                                names(list_number_of_contributing_junctions_validated) %>% tibble::enframe(value = "contributing_junctions"), 
                                                                                by = "contributing_junctions")

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# JUM ###
tibble_JUM_junction_ontology_transcripts_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_transcripts, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_biomart_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_biomart, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")
tibble_JUM_junction_ontology_PTMs_filtered <- dplyr::semi_join(tibble_JUM_junction_ontology_PTMs, tibble_JUM_junction_ontology_supp_info_filtered_by_proteome, by = "AS_event_ID")

```

#### stats summary of JUM junction ontology

```{r}

# PROTEIN-LEVEL
# vector_unique_interpro_ids <- tibble_JUM_junction_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(AS_event_ID) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per AS_event_ID
tibble_interpro_id_tally_per_ASeventID <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(Gene %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched AS_event_ID mapping
tibble_interpro_ID_to_matched_ASeventID_mapping <- tibble_JUM_junction_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("AS_event_IDs" = paste(AS_event_ID %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "AS_event_IDs"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")
tibble_interpro_id_tally_per_ASeventID <- dplyr::right_join(tibble_interpro_ID_to_matched_ASeventID_mapping, tibble_interpro_id_tally_per_ASeventID, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of JUM VSRs")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_ASeventID %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_JUM_anysig_with_na_filtered_by_proteome.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique VSRs with any sort of protein-level annotation: ", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length, " (", tibble_JUM_junction_ontology_biomart_filtered$AS_event_ID %>% unique %>% length *100/length(tibble_JUM_junction_ontology_transcripts$AS_event_ID %>% unique), "% of those which have any transcript annotation)")

message("total percent of unique VSRs overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique VSRs overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique VSRs overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_filtered_by_proteome_JUM_tally <- tibble_JUM_junction_ontology_PTMs_filtered %>% 
  dplyr::distinct(AS_event_ID, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_filtered_by_proteome_JUM_tally, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "purple3") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nJUM")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_filtered_by_proteome_JUM_tally$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_JUM_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## PSI-Sigma: Filter the junction/exon ontology by validated diff_exon_coords

### filter the junction ontology by the validated proteome. get valid AS_event_IDs

```{r}

tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_supp_info,
                                                                                tibble_2020.PO4_2012.proteome_valid_junc.exons_coding %>% 
                                                                                  dplyr::mutate("event_region_coords" = gsub(x = Leading.razor.protein, pattern = "^.*_VSR_([^\\_]+)_exon_(.*)$", replacement = "\\1"),
                                                                                                "diff_exon_coords" = gsub(x = Leading.razor.protein, pattern = "^.*_VSR_([^\\_]+)_exon_(.*)$", replacement = "\\2")), 
                                                                                by = c("event_region_coords", "diff_exon_coords"))

# CONDUCT ENRICHMENT
tibble_hyperGO_confirmed_junc.exons <- dplyr::bind_rows(GOHyperGAll(catdb = catdb, gocat = "MF", sample = tibble_2020.PO4_2012.proteome_valid_junc.exons_coding[grep(x = tibble_2020.PO4_2012.proteome_valid_junc.exons_coding$Leading.razor.protein, pattern = "differential"), ] %>% .$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "BP", sample = tibble_2020.PO4_2012.proteome_valid_junc.exons_coding[grep(x = tibble_2020.PO4_2012.proteome_valid_junc.exons_coding$Leading.razor.protein, pattern = "differential"), ] %>% .$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction,
                                                        GOHyperGAll(catdb = catdb, gocat = "CC", sample = tibble_2020.PO4_2012.proteome_valid_junc.exons_coding[grep(x = tibble_2020.PO4_2012.proteome_valid_junc.exons_coding$Leading.razor.protein, pattern = "differential"), ] %>% .$gene_name %>% strsplit(split = ",") %>% unlist, Nannot = 2) %>% GOHyperGAll_benjamini_correction) %>% as_tibble

write.table(results_dir, file = paste(R_processing_results_dir, "table_hyperGO_confirmed_junc.exons.txt", sep = ""), sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)

# plot goterms
ggplot(data = tibble_hyperGO_confirmed_junc.exons %>% .[.$Term %in% c("focal adhesion", "autophagosome membrane", "cadherin binding", "extracellular matrix structural constituent", "actin cytoskeleton", "regulation of mRNA splicing, via spliceosome", "Golgi vesicle transport", "negative regulation of chromatin organization", "cell cycle", "positive regulation of DNA-binding transcription factor activity"), ] %>% dplyr::arrange(desc(Phyper)) %>% dplyr::mutate("Term" = factor(`Term`, levels = `Term`)), aes(x = `Term`, y = -log10(Phyper), fill = -log10(Phyper))) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  # geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1, size = 3) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_fill_fermenter("PuBu", direction = 1) +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 40)) +
  # ylim(c(0, tibble_combined_PTMs_RNAlevel_filtered_by_proteome$tally %>% max(na.rm = TRUE) * 1.3)) +
  ggtitle("GO terms, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("GO Term") +
  ylab("Phyper") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black"), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 40)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "table_hyperGO_confirmed_junc.exons.pdf", sep = ""), device = "pdf", dpi = 600, width = 15, height = 10, units = "cm")
# +
#   ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 10, units = "cm")

```

### filter by IDs for the transcript, biomart and PTM results.

for the biomart tibbles, also filter by the biomart accesssion.

```{r}

# PSI-Sigma ###
tibble_PSIsigma_exon_ontology_biomart_filtered <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_biomart, tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome, by = "diff_exon_coords")
tibble_PSIsigma_exon_ontology_PTMs_filtered <- dplyr::semi_join(tibble_PSIsigma_exon_ontology_PTMs, tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome, by = "diff_exon_coords")

```

#### stats summary of PSI-Sigma junction ontology

```{r}

# PROTEIN-LEVEL
# vector_unique_interpro_ids <- tibble_PSIsigma_exon_ontology_biomart_filtered$interpro %>% na.omit %>% unique

tibble_protein_level_summary_count <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(diff_exon_coords) %>% 
  dplyr::summarise("overlaps_interpro_domain" = all(is.na(interpro)) == FALSE & intersect(interpro, tibble_non_family_interpro_entries$Accession) %>% length != 0,
                   "unique_interpro_ids" = interpro %>% na.omit %>% unique %>% paste(collapse = ";"),
                   "overlaps_LCR" = all(is.na(seg_start)) == FALSE,
                   "overlaps_disordered_region" = all(is.na(mobidblite)) == FALSE,
                   "overlaps_ncoils" = all(is.na(ncoils_start)) == FALSE,
                   "overlaps_signalp" = all(is.na(signalp_start)) == FALSE,
                   "overlaps_tmhmm" = all(is.na(tmhmm_start)) == FALSE)

vector_unique_interpro_ids <- dplyr::semi_join(tibble_protein_level_summary_count$unique_interpro_ids %>% strsplit(split = ";") %>% unlist %>% sort %>% tibble::enframe(name = NULL, value = "vec"), tibble_non_family_interpro_entries$Accession %>% tibble::enframe(name = NULL, value = "vec"), by = "vec") %>% unlist

# create tally of each unique instance of interpro ID per diff_exon_coords
tibble_interpro_id_tally_per_diff_exon_coords <- tibble::enframe(vector_unique_interpro_ids, name = NULL, value = "interpro_id") %>% dplyr::group_by(interpro_id) %>% dplyr::summarise("tally" = n()) %>% dplyr::arrange(desc(tally))

# create interpro to matched gene mapping
tibble_interpro_ID_to_matched_gene_mapping <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("genes" = paste(matched_gene_names %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "genes"))
# create interpro to matched diff_exon_coords mapping
tibble_interpro_ID_to_matched_diff_exon_coords_mapping <- tibble_PSIsigma_exon_ontology_biomart_filtered %>% dplyr::group_by(interpro) %>% 
  dplyr::summarise("diff_exon_coords" = paste(diff_exon_coords %>% unique %>% mixedsort, collapse = ",")) %>% setNames(c("interpro_id", "diff_exon_coords"))

# fetch descriptions of interpro ID
tibble_interpro_ID_to_description_mapping <- tibble_non_family_interpro_entries[, c("Accession", "Name")] %>% setNames(c("interpro_id", "interpro_description")) %>% as_tibble
# add column for plotting
tibble_interpro_ID_to_description_mapping <- tibble_interpro_ID_to_description_mapping %>% add_column("interpro_identifier" = paste(tibble_interpro_ID_to_description_mapping$interpro_description, " (", tibble_interpro_ID_to_description_mapping$interpro_id, ")", sep = ""))
# tibble joins
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_description_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_matched_gene_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")
tibble_interpro_id_tally_per_diff_exon_coords <- dplyr::right_join(tibble_interpro_ID_to_matched_diff_exon_coords_mapping, tibble_interpro_id_tally_per_diff_exon_coords, by = "interpro_id")

# plot
ggplot(tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::arrange(desc(tally)) %>% head(90), aes(x = reorder(interpro_identifier, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  ggtitle(paste("Tally of the 90 most overlapping interpro identifiers of PSI-Sigma exons")) +
  xlab("Interpro identifier") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Number of hits") +
  # coord_cartesian(ylim = c(0, 50)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8), axis.text.y = element_text(size = 20), axis.title.y = element_text(margin = margin(r = 90)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 80, height = 10, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 80, height = 10, units = "cm") 

write.table(x = tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::arrange(desc(tally)), file = paste(results_dir, "tally_overlapping_interpro_domains_PSISigma_anysig_with_na_filtered_by_proteome.txt", sep = ""), sep = "\t", row.names = FALSE, quote = FALSE)

message("total number of unique exons with any sort of protein-level annotation: ", tibble_PSIsigma_exon_ontology_biomart_filtered$diff_exon_coords %>% unique %>% length, " (", tibble_PSIsigma_exon_ontology_biomart_filtered$diff_exon_coords %>% unique %>% length *100/length(tibble_PSIsigma_exon_ontology_transcripts$diff_exon_coords %>% unique), "% of those which have any transcript annotation)")

message("total percent of unique exons overlapping an interpro domain: ", length(which(tibble_protein_level_summary_count$overlaps_interpro_domain == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

message("total percent of unique exons overlapping a low complexity region: ", length(which(tibble_protein_level_summary_count$overlaps_LCR == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a disordered region: ", length(which(tibble_protein_level_summary_count$overlaps_disordered_region == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a coiled-coiled domain: ", length(which(tibble_protein_level_summary_count$overlaps_ncoils == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a signalp domain: ", length(which(tibble_protein_level_summary_count$overlaps_signalp == TRUE))/nrow(tibble_protein_level_summary_count) * 100)
message("total percent of unique exons overlapping a tmhmm domain: ", length(which(tibble_protein_level_summary_count$overlaps_tmhmm == TRUE))/nrow(tibble_protein_level_summary_count) * 100)

# PTM level
tibble_PTM_tally_filtered_by_proteome_PSIsigma <- tibble_PSIsigma_exon_ontology_PTMs_filtered %>% 
  dplyr::distinct(diff_exon_coords, splicemode, PTM_type) %>% 
  dplyr::group_by(PTM_type) %>% 
  dplyr::summarise("tally" = n())

# plot
ggplot(tibble_PTM_tally_filtered_by_proteome_PSIsigma, aes(x = reorder(PTM_type, -tally), y = tally)) +
  geom_col(fill = "firebrick4") +
  geom_text(stat = "identity", nudge_y = 1, aes(label = tally), angle = 90, hjust = 0) +
  ggtitle(paste("Tally of PTMs inside differentially spliced regions\nPSI-Sigma")) +
  xlab("PTM type") +
  scale_x_discrete(labels = function(x) {str_wrap(x, width = 50)}) +
  ylab("Frequency") +
  ylim(c(0, max(tibble_PTM_tally_filtered_by_proteome_PSIsigma$tally) + 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), axis.title.y = element_text(margin = margin(r = 10)), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_PSISigma_anysig_with_na_filtered_by_proteome.pdf", sep = ""), device = "pdf", dpi = 600, width = 4, height = 8, units = "cm") +
 ggsave(filename = paste(results_dir, "tally_overlapping_PTMs_PSISigma_anysig_with_na_filtered_by_proteome.svg", sep = ""), device = "svg", dpi = 600, width = 4, height = 8, units = "cm") 

```

## Combined plot of interpro/PTM filtered by proteome evidence

```{r}

### interpro

tibble_combined_interpro_RNAlevel_filtered_by_proteome <- dplyr::full_join(tibble_interpro_id_tally_per_ASeventID %>% dplyr::rename("tally_JUM" = "tally", "genes_JUM" = "genes"), 
                                                                          tibble_interpro_id_tally_per_diff_exon_coords %>% dplyr::rename("tally_PSIsigma" = "tally", "genes_PSIsigma" = "genes"), 
                                                                          by = c("interpro_id", "interpro_description", "interpro_identifier")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  na.omit %>%
  tail(n = 10) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("interpro_id", "interpro_description", "interpro_identifier"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_interpro_RNAlevel_filtered_by_proteome, aes(x = `interpro_description`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_interpro_RNAlevel_filtered_by_proteome$tally %>% max * 1.2)) +
  ggtitle("Top 10 interpro domains, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("Interpro domain") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_filtered_by_proteome_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 12, height = 10, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_interpro_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 12, height = 10, units = "cm")

### PTMs
tibble_combined_PTMs_RNAlevel_filtered_by_proteome <- dplyr::full_join(tibble_PTM_filtered_by_proteome_JUM_tally %>% dplyr::rename("tally_JUM" = "tally"), 
                                                                       tibble_PTM_tally_filtered_by_proteome_PSIsigma %>% dplyr::rename("tally_PSIsigma" = "tally"), 
                                                                       by = c("PTM_type")) %>% # arrange in descending order of geometric mean
  dplyr::arrange(purrr::map2(.x = .$tally_JUM, .y = .$tally_PSIsigma, .f = ~exp(mean(log(c(.x, .y)), na.rm = TRUE))) %>% unlist) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = c("PTM_type"), .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = colnames(.)[!colnames(.) %in% c("tally_JUM", "tally_PSIsigma")], variable.name = "tool", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool", .funs = function(x) {column <- factor(x = x, levels = c("tally_PSIsigma", "tally_JUM")); return(column)} )

ggplot(data = tibble_combined_PTMs_RNAlevel_filtered_by_proteome, aes(x = `PTM_type`, y = tally, fill = tool)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black") +
  scale_fill_manual(name = "Tool", 
                    breaks = c("tally_JUM", "tally_PSIsigma"), 
                    limits = c("tally_JUM", "tally_PSIsigma"), 
                    labels = c("JUM", "PSI-sigma"), 
                    values = c("purple3", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1, size = 3) +
  # geom_text(stat = "identity", aes(y = tally + 10 + ((floor(tally %>% log10) + 1) * 12.5), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, tibble_combined_PTMs_RNAlevel_filtered_by_proteome$tally %>% max(na.rm = TRUE) * 1.3)) +
  ggtitle("Top 10 PTMs, JUM and PSI-Sigma (proteome-filtered), differential") +
  xlab("PTM type") +
  ylab("Number of VSRs/exons") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm") +
  ggsave(filename = paste(results_dir, "tibble_combined_PTM_RNAlevel_filtered_by_proteome_without_bootstrap_significance.svg", sep = ""), device = "svg", dpi = 600, width = 10, height = 10, units = "cm")

```

## Gene ontology analysis of splicing-removed PTMs

```{r}

list_gohyper_tibbles_splicing_removed_PTMs <- c("MF", "BP", "CC") %>% purrr::map(~systemPipeR::GOHyperGAll(catdb = catdb, gocat = .x, sample = c(tibble_JUM_junction_ontology_PTMs_filtered$Gene %>% unique %>% mixedsort, tibble_PSIsigma_exon_ontology_PTMs_filtered$matched_gene_names %>% unique %>% mixedsort) %>% strsplit(split = ",") %>% unlist)) %>% set_names(c("MF", "BP", "CC"))

```

## filter the valid phosphosites by differential CDS positions.

### JUM

```{r}

# add junction ID onto the phosphosites table
tibble_JUM_valid_phosphosites_with_junc_ID <- dplyr::left_join(tibble_2020.PO4_valid_phosphosites %>% 
                                                                 dplyr::mutate("junction_identifier" = gsub(x = `final_identifier`, pattern = "JUM_.*_junction_", replacement = "")),
                                                                        UNION_junc_coor_table_with_junction_identifier[, c("junction_identifier", "junction_ID")],
                                                               by = "junction_identifier")

# loop thru each junction ID for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_JUM_valid_phosphosites_with_junc_ID$junction_ID,
  .y = tibble_JUM_valid_phosphosites_with_junc_ID$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    subset_junction_ontology_supp_info_by_identifier <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[grep(x = tibble_JUM_junction_ontology_supp_info_filtered_by_proteome$contributing_junctions, pattern = a1), ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_junction_ontology_supp_info_by_identifier$vector_genomic_coords_of_all_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_JUM_valid_phosphosites_with_overlap <- tibble_JUM_valid_phosphosites_with_junc_ID %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

tibble_validated_phosphosites_JUM <- tibble_JUM_valid_phosphosites_with_overlap %>% 
  dplyr::filter(differential_overlap == TRUE) %>% 
  dplyr::distinct(genome_relative_positions_phosphosite, .keep_all = TRUE)

write.table(tibble_validated_phosphosites_JUM, paste(results_dir, "tibble_validated_phosphosites_JUM.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

cat("\nthere are ", tibble_validated_phosphosites_JUM$genome_relative_positions_phosphosite %>% unique %>% length, " phosphosites validated in JUM AS region")

```

### PSI-Sigma

```{r}

# loop thru each identifier for phosphosites and test if the genome-relative positions intersect.
list_logical_phosphosite_intersect_differential_CDS_positions <- purrr::map2(
  .x = tibble_2020.PO4_valid_phosphosites$final_identifier,
  .y = tibble_2020.PO4_valid_phosphosites$genome_relative_positions_phosphosite %>% strsplit(split = ","),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- tibble_2020.PO4_valid_phosphosites$final_identifier %>% .[[781]]
    # a2 <- tibble_2020.PO4_valid_phosphosites$genome_relative_positions_phosphosite %>% strsplit(split = ",") %>% .[[781]]
    ###########
    
    # extract the VSR identifier and the alternative exon identifiers by strsplit
    VSR_identifier <- gsub(x = a1, pattern = "PSISigma_.*_VSR_(.*)_exon_(.*)", replacement = "\\1")
    alternative_exon_identifier <- gsub(x = a1, pattern = "PSISigma_.*_VSR_(.*)_exon_(.*)", replacement = "\\2")
    
    subset_exon_ontology_supp_info_by_identifier <-
      tibble_PSIsigma_exon_ontology_supp_info[tibble_PSIsigma_exon_ontology_supp_info$event_region_coords == VSR_identifier & 
                                                tibble_PSIsigma_exon_ontology_supp_info$diff_exon_coords == alternative_exon_identifier, ]
    
    intersecting_coords <- intersect(a2, 
                                     subset_exon_ontology_supp_info_by_identifier$list_differential_CDS_positions %>% strsplit(split = ",") %>% unlist)
    
    return(intersecting_coords %>% length)
    
  } )

# append the results of overlap as logical column back onto the phosphosite table.
tibble_PSIsigma_valid_phosphosites_with_overlap <- tibble_2020.PO4_valid_phosphosites %>% 
  add_column("differential_overlap" = list_logical_phosphosite_intersect_differential_CDS_positions %>% purrr::map(.f = ~.x != 0) %>% unlist)

tibble_validated_phosphosites_PSIsigma <- tibble_PSIsigma_valid_phosphosites_with_overlap %>% 
  dplyr::filter(differential_overlap == TRUE) %>% 
  dplyr::distinct(genome_relative_positions_phosphosite, .keep_all = TRUE)

write.table(tibble_validated_phosphosites_PSIsigma, paste(results_dir, "tibble_validated_phosphosites_PSIsigma.txt", sep = ""), sep = "\t", col.names = TRUE, row.names = FALSE, quote = FALSE)

cat("\nthere are ", tibble_validated_phosphosites_PSIsigma$genome_relative_positions_phosphosite %>% unique %>% length, " phosphosites validated in PSI-Sigma AS region")

```

## Calculate bootstrap P values of the JUM/PSI-Sigma:

- Transcript regions
- Interpro domains (ALL + proteome filtered)
- Biomart regions esp. LCR (ALL + proteome filtered)
- PTM overlap  (ALL + proteome filtered)

NOTE: For all the proteome-filtered, MUST walk along the **CDS**.

### Meaning we need to cast onto the genome, convert to Granges then convert to transcript-relative topology:

- Biomart reference regions (easiest to do)
- Biomart regions, incl. interpro domains, LCR.
- Each interpro domain
- dbPTM sites (which already includes phosphositeplus)

### set environment and GTF

```{r}

library(regioneR)
library(rtracklayer)
library(BSgenome.Hsapiens.UCSC.hg38)

tibble_ref_gtf_original <- rtracklayer::import("/mnt/LTS/reference_data/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble
# tibble_ref_gtf_original <- rtracklayer::import("Z:/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98.gtf") %>% as_tibble

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% dplyr::select(-source, -score, -gene_version, -gene_source, -transcript_version, -transcript_source, -tag, -transcript_support_level, -exon_version, -protein_version, -ccds_id) %>% unique

colnames(tibble_ref_gtf_original) <- c("chr", "start", "end", "width", "strand", "type", "phase", "gene_id", "gene_name", "gene_biotype", "transcript_id", "transcript_name", "transcript_biotype", "exon_number", "exon_id", "protein_id") 

tibble_ref_gtf_original <- tibble_ref_gtf_original %>% mutate_if(is.factor, as.character)

# import dbPTM info
# Z:/dbPTM_download/extract/allPTM_human.txt
tibble_dbPTM_allhuman_annotations <- read.delim("/mnt/Tertiary/sharedfolder/dbPTM_download/extract/allPTM_human_filtered.txt", col.names = c("_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_dbPTM_allhuman_annotations <- read.delim("Z:/dbPTM_download/extract/allPTM_human_filtered.txt", col.names = c("uniprotkb_entryname", "uniprotkb_entry", "modified_residue_position", "PTM_type", "pubmed_accessions", "context_sequence"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# import PhosphoSitePlus info
# Z:/phosphositeplus_phosphosites_human.tab
tibble_phosphositeplus_allhuman_phosphosites <- read.delim("/mnt/Tertiary/sharedfolder/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble
# tibble_phosphositeplus_allhuman_phosphosites <- read.delim("Z:/phosphositeplus_phosphosites_human.tab", col.names = c("gene_name", "protein_name", "uniprotkb_entry", "chr_locus", "modified_residue_position", "SITE_GRP_ID", "organism", "MW.kD", "domain", "site_7AA_either.side", "LT_LIT", "MS_LIT", "MS_CST", "CST_CAT"), na = c("NA", ""), sep = "\t", stringsAsFactors = FALSE) %>% as_tibble

# change the residue position column
tibble_phosphositeplus_allhuman_phosphosites[, "modified_residue_position"] <- gsub(x = tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position, pattern = "^([A-Z])([0-9]{1,5})(.*)", replacement = "\\2")

# remove rows where phosphosite is NA
row.indices_phosphosite.is.na <- which(is.na(tibble_phosphositeplus_allhuman_phosphosites$modified_residue_position))

tibble_phosphositeplus_allhuman_phosphosites <- tibble_phosphositeplus_allhuman_phosphosites[-row.indices_phosphosite.is.na, ]

# RBIND THE PTM TABLES
tibble_PTM_combined <- tibble_dbPTM_allhuman_annotations
```

### Reference preprocessing: define and map topologies, cast reference regions onto exon-relative coords.

1. define exonic and CDS relative topology mapping
2. create the effective exome/CDSome
3. convert transcript regions, biomart regions and PTM sites to exon/CDS-relative coords.

NOTE: biomart regions and PTM sites need to be pre-cast onto the genome before converting to CDS-relative coords.

#### construction of the effective transcriptome

```{r}

plan(list(tweak(multisession, workers = 8),
          tweak(multisession, workers = 4))
)

# extract exonic entries only
tibble_transcriptomic_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "transcript", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_transcriptomic_GTF_entries_unique <- tibble_transcriptomic_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutely necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_transcriptomic_GTF_entries_unique <- granges_transcriptomic_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_transcriptomic_GTF_entries <- tibble_transcriptomic_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_transcriptomic_GTF_entries) <- list_transcriptomic_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_transcriptomic_GTF_entries <- list_transcriptomic_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO TRANSCRIPT-RELATIVE TOPOLOGY MAPPING
list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping <- future_map(.x = list_transcriptomic_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_exonic_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_transcriptome_relative_end <- vec_sum_of_widths
                                                            vec_transcriptome_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("transcriptome_relative_start" = vec_transcriptome_relative_start,
                                                                                              "transcriptome_relative_end" = vec_transcriptome_relative_end)
                                                            
                                                          }, .progress = TRUE )

# create granges of the effective exome
## first get start and end based on the exon relative coords
tibble_effective_transcriptome <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$transcriptome_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_transcriptome <- toGRanges(tibble_effective_transcriptome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

```

#### construction of the effective exome AND transcript region conversion

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# extract exonic entries only
tibble_exonic_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "exon", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_exonic_GTF_entries_unique <- tibble_exonic_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutely necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_exonic_GTF_entries_unique <- granges_exonic_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_exonic_GTF_entries <- tibble_exonic_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_exonic_GTF_entries) <- list_exonic_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_exonic_GTF_entries <- list_exonic_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO TRANSCRIPT-RELATIVE TOPOLOGY MAPPING
list_exonic_GTF_entries_genome_to_exon_relative_mapping <- future_map(.x = list_exonic_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_exonic_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_transcript_relative_end <- vec_sum_of_widths
                                                            vec_transcript_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("transcript_relative_start" = vec_transcript_relative_start,
                                                                                              "transcript_relative_end" = vec_transcript_relative_end)
                                                            
                                                          }, .progress = TRUE )

# create granges of the effective exome
## first get start and end based on the exon relative coords
tibble_effective_exome <- list_exonic_GTF_entries_genome_to_exon_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$transcript_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_exome <- toGRanges(tibble_effective_exome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

# move non-exonic entries over to exome-relative coords.
## we will choose everything except for gene, transcript and selenocysteine because they span across multiple exons and hence will break the matching algorithm.
tibble_non_exonic_GTF_entries <- dplyr::bind_rows(
  tibble_ref_gtf_original[tibble_ref_gtf_original$type %in% c("CDS", "start_codon", "stop_codon", "five_prime_utr", "three_prime_utr"), ],
  tibble_ref_gtf_original[tibble_ref_gtf_original$type == "exon" & tibble_ref_gtf_original$transcript_biotype %in% c("protein_coding", "lncRNA", "miRNA"), ] )
## group-split the non-exonic entries by chromosome so we can map2 over both.
list_non_exonic_GTF_entries <- purrr::map(.x = names(list_exonic_GTF_entries_genome_to_exon_relative_mapping),
                                          .f = ~tibble_non_exonic_GTF_entries[tibble_non_exonic_GTF_entries$chr == .x, ])

## map2 over exonic and non-exonic GTF entries.
list_non_exonic_GTF_entries_exon_relative_coords <- future_map2(.x = list_exonic_GTF_entries_genome_to_exon_relative_mapping,
                                                                .y = list_non_exonic_GTF_entries,
                                                                .f = function(a1, a2) {
                                                                  
                                                                  # DEBUG ###
                                                                  # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
                                                                  # a2 <- list_non_exonic_GTF_entries[[1]]
                                                                  ###########
                                                                  
                                                                  # list-ify the non-exonic entries
                                                                  list_non_exonic_subset <- a2 %>% array_tree
                                                                  # loop thru each element, find overlapping exonic interval, subtract 
                                                                  list_non_exonic_subset_transcript_relative_coords <- future_map(
                                                                    .x = list_non_exonic_subset,
                                                                    .f = function(b1) {
                                                                      
                                                                      # DEBUG ###
                                                                      # b1 <- list_non_exonic_subset[[1]]
                                                                      ###########
                                                                      
                                                                      tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
                                                                      
                                                                      # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
                                                                      shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
                                                                      transcript_relative_start <- (b1$start %>% type.convert) - shift
                                                                      transcript_relative_end <- (b1$end %>% type.convert) - shift
                                                                      
                                                                      output_tibble <- splice(
                                                                        b1,
                                                                        "transcript_relative_start" = transcript_relative_start %>% list,
                                                                        "transcript_relative_end" = transcript_relative_end %>% list
                                                                      ) %>% as_tibble
                                                                      
                                                                      return(output_tibble)
                                                                      
                                                                    }, .progress = TRUE, .options = future_options(globals = c("a1")) )
                                                                  
                                                                }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_non_exonic_GTF_entries_exon_relative_coords <- list_non_exonic_GTF_entries_exon_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

# create granges of transcript "type" and "transcript_biotype".
## this is a little complicated because we're splitting by two rows. but basically we have to group_split the exonic and non-exonic entries separately
## the non-exonic will be split by "type" and the exonic will be split by "transcript_biotype".
## then splice the lists together.
## this is because transcript biotypes to be split can be both non-exon or exon, whereas non-exon/exon to be split are always in one transcript_biotype.
list_split_ensembl_transcript_types_and_biotypes <- purrr::splice(
  tibble_non_exonic_GTF_entries_exon_relative_coords %>% 
    dplyr::filter(type != "exon") %>%
    dplyr::group_split(type) %>%
    set_names(purrr::map(.x = ., .f = ~.x$type %>% unique)),
  tibble_non_exonic_GTF_entries_exon_relative_coords %>% 
    dplyr::filter(type == "exon") %>%
    dplyr::group_split(transcript_biotype) %>%
    set_names(purrr::map(.x = ., .f = ~.x$transcript_biotype %>% unique))
) %>% flatten

list_granges_ensembl_transcript_types <- list_split_ensembl_transcript_types_and_biotypes %>%
  purrr::map(~toGRanges(.x[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                          # turn chr column into chr1 chr2 etc...
                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                          type_convert %>% 
                          # data frame is absolutely necessary for regioneR.
                          as.data.frame))

# NOTE: not planning to do "transcript_biotype" anymore.

# list_granges_ensembl_transcript_biotypes <- tibble_ref_gtf_original %>%
#   dplyr::filter(type == "exon") %>%
#   dplyr::group_split(transcript_biotype) %>%
#   set_names(purrr::map(.x = ., .f = ~.x$transcript_biotype %>% unique)) %>%
#   purrr::map(~toGRanges(.x[, c("chr", "start", "end")] %>% 
#                           # turn chr column into chr1 chr2 etc...
#                           dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
#                           type_convert %>% 
#                           # data frame is absolutely necessary for regioneR.
#                           as.data.frame))

# list_granges_ensembl_transcript_by_type_and_biotype <- purrr::splice(list_granges_ensembl_transcript_types, list_granges_ensembl_transcript_biotypes)

```

#### construct the effective CDSome

```{r}

# extract CDS entries only
tibble_CDS_GTF_entries <- tibble_ref_gtf_original[tibble_ref_gtf_original$type == "CDS", ]
# take the union of ranges 
## rename metadata column
## convert to granges
granges_CDS_GTF_entries_unique <- tibble_CDS_GTF_entries[, c("chr", "start", "end")] %>%
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
  # turn chr column into chr1 chr2 etc...
  dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
  type_convert %>% 
  # data frame is absolutele necessary for regioneR.
  as.data.frame %>%
  toGRanges %>% 
  joinRegions(min.dist = 1)
# reform into a tibble
tibble_CDS_GTF_entries_unique <- granges_CDS_GTF_entries_unique %>% 
  as_tibble %>%
  dplyr::mutate_at(.vars = "seqnames", .funs = function(x) {gsub(x = x, pattern = "chr", replacement = "")} ) %>% 
  dplyr::rename("chr" = "seqnames")
## list-ify by chromosome and sort by start coords
list_CDS_GTF_entries <- tibble_CDS_GTF_entries_unique %>% dplyr::group_split(chr)
names(list_CDS_GTF_entries) <- list_CDS_GTF_entries %>% purrr::map(~.x$chr %>% unique) %>% unlist
list_CDS_GTF_entries <- list_CDS_GTF_entries %>% purrr::map(~.x %>% dplyr::arrange(start))

# add transcript-relative start and end. chr and width are the same.
# NOTE: THIS WILL BE THE GENOME-RELATIVE TO CDS-RELATIVE TOPOLOGY MAPPING
list_CDS_GTF_entries_genome_to_CDS_relative_mapping <- future_map(.x = list_CDS_GTF_entries,
                                                          .f = function(a1) {
                                                            
                                                            # DEBUG ###
                                                            # a1 <- list_CDS_GTF_entries[[1]]
                                                            ###########
                                                            
                                                            # create vectors of transcript-relative start and end coords by calculating the sum of widths in order
                                                            # sum of widths is the end coords.
                                                            vec_sum_of_widths <- future_map(.x = 1:nrow(a1),
                                                                                            .f = ~a1$width %>% .[1:.x] %>% sum, .progress = TRUE) %>% unlist
                                                            
                                                            vec_CDS_relative_end <- vec_sum_of_widths
                                                            vec_CDS_relative_start <- c(1, vec_sum_of_widths[1:(length(vec_sum_of_widths) - 1)] + 1)
                                                            
                                                            # add columns to tibble
                                                            final_tibble <- a1 %>% add_column("CDS_relative_start" = vec_CDS_relative_start,
                                                                                              "CDS_relative_end" = vec_CDS_relative_end)
                                                            
                                                          }, .progress = TRUE)

# create granges of the effective CDSome
## first get start and end based on the CDS relative coords
tibble_effective_CDSome <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping %>%
  purrr::map(~tibble("chr" = .x$chr %>% unique, "start" = 1, "end" = max(.x$CDS_relative_end))) %>%
  rbindlist(use.names = TRUE) %>% as_tibble
## convert to granges
granges_effective_CDSome <- toGRanges(tibble_effective_CDSome %>% 
                                       # turn chr column into chr1 chr2 etc...
                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                       type_convert %>% 
                                       # data frame is absolutely necessary for regioneR.
                                       as.data.frame)

```

### Preprocessing: convert differential positions into UNIQUE Granges and convert to exon-relative coords.

#### differential VSR regions for JUM and PSI-Sigma - cast onto effective transcriptome

```{r}

# JUM - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_VSR_genome.relative_chr.start.end <- tibble_AS.event.IDs_chr_start_end_differential %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_VSR_genome.relative_chr.start.end[tibble_JUM_differential_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      } )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_JUM_differential_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_VSR_transcriptome_relative_coords <- toGRanges(tibble_JUM_differential_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_differential_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_JUM_differential_VSR_transcriptome_relative_coords, granges_JUM_differential_VSR_transcriptome_relative_coords)

# PSI-Sigma - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end <- tibble_psisigma_differential_chr_start_end %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end[tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_PSIsigma_differential_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_VSR_transcriptome_relative_coords <- toGRanges(tibble_PSIsigma_differential_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_PSIsigma_differential_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_PSIsigma_differential_VSR_transcriptome_relative_coords, granges_PSIsigma_differential_VSR_transcriptome_relative_coords)

```

#### constitutive VSR regions for JUM and PSI-Sigma - cast onto effective transcriptome

```{r}

# JUM - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_constitutive_VSR_genome.relative_chr.start.end <- tibble_AS.event.IDs_chr_start_end_constitutive %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_constitutive_VSR_genome.relative_chr.start.end[tibble_JUM_constitutive_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_JUM_constitutive_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_constitutive_VSR_transcriptome_relative_coords <- toGRanges(tibble_JUM_constitutive_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_constitutive_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_JUM_constitutive_VSR_transcriptome_relative_coords, granges_JUM_constitutive_VSR_transcriptome_relative_coords)

# PSI-Sigma - unfiltered RNA ###
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end <- tibble_psisigma_constitutive_chr_start_end %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end[tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_constitutive_VSR_genome.relative_chr.start.end$chr %>% unique)

## map2 over transcriptome-mapping file
list_converted_transcriptome_relative_coords <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_start <- (b1$start %>% type.convert) - shift
        transcriptome_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcriptome_relative_start" = transcriptome_relative_start %>% list,
          "transcriptome_relative_end" = transcriptome_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE VSRs WHICH HAVE BEEN MAPPED ONTO TRANSCRIPTOME-RELATIVE COORDS.
tibble_PSIsigma_constitutive_VSR_transcriptome_relative_coords <- list_converted_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords <- toGRanges(tibble_PSIsigma_constitutive_VSR_transcriptome_relative_coords[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutely necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords <- regioneR::mergeRegions(granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords, granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords)

```

#### differential exonic positions

```{r}

# JUM - unfiltered RNA
## create tibble of item coords and chr
tibble_JUM_differential_exonic_coords_and_chr <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_JUM_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_unfiltered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_exonic_regions_all.RNA <- toGRanges(tibble_JUM_differential_unfiltered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutele necessary for regioneR.
                                                               as.data.frame)
# make unique regions only
granges_JUM_differential_exonic_regions_all.RNA <- regioneR::mergeRegions(granges_JUM_differential_exonic_regions_all.RNA, granges_JUM_differential_exonic_regions_all.RNA)

# PSI-Sigma - unfiltered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_exonic_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_unfiltered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_exonic_regions_all.RNA <- toGRanges(tibble_PSIsigma_differential_unfiltered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutele necessary for regioneR.
                                                       as.data.frame)
# make unique regions only
granges_PSIsigma_differential_exonic_regions_all.RNA <- regioneR::mergeRegions(granges_PSIsigma_differential_exonic_regions_all.RNA, granges_PSIsigma_differential_exonic_regions_all.RNA)

# JUM - proteome-filtered RNA
## create tibble of item coords and chr
tibble_JUM_differential_exonic_coords_and_chr <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_JUM_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_proteome_filtered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_exonic_regions_proteome.filtered.RNA <- toGRanges(tibble_JUM_differential_proteome_filtered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                                             # turn chr column into chr1 chr2 etc...
                                                                             dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                             type_convert %>% 
                                                                             # data frame is absolutele necessary for regioneR.
                                                                             as.data.frame)
# make unique regions only
granges_JUM_differential_exonic_regions_proteome.filtered.RNA <- regioneR::mergeRegions(granges_JUM_differential_exonic_regions_proteome.filtered.RNA, granges_JUM_differential_exonic_regions_proteome.filtered.RNA)

# PSI-Sigma - proteome-filtered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_exonic_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome[, c("diff_exon_coords", "vector_genomic_coords_of_all_differential_exon_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_exon_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_exon_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_exon_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$vector_genomic_coords_of_all_differential_exon_positions, 
  metadata_vector = tibble_PSIsigma_differential_exonic_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to exome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over exonic and non-exonic GTF entries.
list_converted_exome_relative_coords <- future_map2(
  .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcript_relative_start
        transcript_relative_start <- (b1$start %>% type.convert) - shift
        transcript_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "transcript_relative_start" = transcript_relative_start %>% list,
          "transcript_relative_end" = transcript_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_proteome_filtered_exon_relative_coords <- list_converted_exome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA <- toGRanges(tibble_PSIsigma_differential_proteome_filtered_exon_relative_coords[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutely necessary for regioneR.
                                                       as.data.frame)
# make unique regions only
granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA <- regioneR::mergeRegions(granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA, granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA)

```

#### differential CDS positions

```{r}

# JUM - unfiltered RNA
## create tibble of item coords and chr
tibble_JUM_differential_CDS_coords_and_chr <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_CDS_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_CDS_coords_and_chr$vector_genomic_coords_of_all_differential_CDS_positions, 
  metadata_vector = tibble_JUM_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_unfiltered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_CDS_regions_all.RNA <- toGRanges(tibble_JUM_differential_unfiltered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                               # turn chr column into chr1 chr2 etc...
                                                               dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                               type_convert %>% 
                                                               # data frame is absolutele necessary for regioneR.
                                                               as.data.frame)

# PSI-Sigma - unfiltered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_CDS_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info[, c("diff_exon_coords", "list_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "list_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "list_differential_CDS_positions") %>%
  dplyr::arrange(list_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$list_differential_CDS_positions, 
  metadata_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_unfiltered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_CDS_regions_all.RNA <- toGRanges(tibble_PSIsigma_differential_unfiltered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutele necessary for regioneR.
                                                       as.data.frame)

# JUM - proteome-filtered RNA
## create tibble of item coords and chr
tibble_JUM_differential_CDS_coords_and_chr <- tibble_JUM_junction_ontology_supp_info_filtered_by_proteome[, c("AS_event_ID", "vector_genomic_coords_of_all_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "vector_genomic_coords_of_all_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "AS_event_ID", .funs = function(x) {gsub(x = x, pattern = "^([^_]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "AS_event_ID") %>%
  unnest(cols = "vector_genomic_coords_of_all_differential_CDS_positions") %>%
  dplyr::arrange(vector_genomic_coords_of_all_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_JUM_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_JUM_differential_CDS_coords_and_chr$vector_genomic_coords_of_all_differential_CDS_positions, 
  metadata_vector = tibble_JUM_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_JUM_differential_genome.relative_chr.start.end[tibble_JUM_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_JUM_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_JUM_differential_proteome_filtered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_JUM_differential_CDS_regions_proteome.filtered.RNA <- toGRanges(tibble_JUM_differential_proteome_filtered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                                             # turn chr column into chr1 chr2 etc...
                                                                             dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                             type_convert %>% 
                                                                             # data frame is absolutele necessary for regioneR.
                                                                             as.data.frame)

# PSI-Sigma - proteome-filtered RNA
## create tibble of item coords and chr
tibble_PSIsigma_differential_CDS_coords_and_chr <- tibble_PSIsigma_exon_ontology_supp_info_filtered_by_proteome[, c("diff_exon_coords", "list_differential_CDS_positions")] %>%
  dplyr::mutate_at(.vars = "list_differential_CDS_positions", .funs = function(x) {strsplit(x, split = ",") %>% return} ) %>%
  dplyr::mutate_at(.vars = "diff_exon_coords", .funs = function(x) {gsub(x = x, pattern = "^([^\\:]+).*", replacement = "\\1") %>% return} ) %>% 
  dplyr::rename("chr" = "diff_exon_coords") %>%
  unnest(cols = "list_differential_CDS_positions") %>%
  dplyr::arrange(list_differential_CDS_positions) %>%
  na.omit
  
## convert vector of discontinuous sites into chr, start, end.
tibble_PSIsigma_differential_genome.relative_chr.start.end <- convert_vector.of.positions_to_simple.ranges(
  input_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$list_differential_CDS_positions, 
  metadata_vector = tibble_PSIsigma_differential_CDS_coords_and_chr$chr) %>% 
  # rename metadata column)
  dplyr::rename("chr" = "value") %>% 
  # filter out non-1:22/X/Y chromosome entries
  dplyr::filter(chr %in% c(1:22, "X", "Y"))

## convert to CDS-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- purrr::map(
  .x = tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique,
  .f = ~tibble_PSIsigma_differential_genome.relative_chr.start.end[tibble_PSIsigma_differential_genome.relative_chr.start.end$chr == .x, ]) %>% 
  set_names(tibble_PSIsigma_differential_genome.relative_chr.start.end$chr %>% unique)

## map2 over CDS mapping list and the input coords
list_converted_CDS_relative_coords <- future_map2(
  .x = list_CDS_GTF_entries_genome_to_CDS_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_CDS_GTF_entries_genome_to_CDS_relative_mapping[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the non-exonic entries
    list_non_exonic_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_non_exonic_subset_transcript_relative_coords <- future_map(
      .x = list_non_exonic_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_non_exonic_subset[[1]]
        ###########
        
        tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$CDS_relative_start
        CDS_relative_start <- (b1$start %>% type.convert) - shift
        CDS_relative_end <- (b1$end %>% type.convert) - shift
        
        output_tibble <- splice(
          b1,
          "CDS_relative_start" = CDS_relative_start %>% list,
          "CDS_relative_end" = CDS_relative_end %>% list
        ) %>% as_tibble
        
        return(output_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("a1")) )
    
  }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_PSIsigma_differential_proteome_filtered_CDS_relative_coords <- list_converted_CDS_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

granges_PSIsigma_differential_CDS_regions_proteome.filtered.RNA <- toGRanges(tibble_PSIsigma_differential_proteome_filtered_CDS_relative_coords[, c("chr", "CDS_relative_start", "CDS_relative_end")] %>% 
                                                       # turn chr column into chr1 chr2 etc...
                                                       dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                       type_convert %>% 
                                                       # data frame is absolutely necessary for regioneR.
                                                       as.data.frame)

```

### Preprocessing: convert topology for fixed (target) regions

#### cast the public CLIP-seq data onto transcriptome

```{r}

# create tibble combining all the CLIP-Seq data
tibble_clipseq_binding_sites_combined <- purrr::map2(.x = list_clipseq_tibbles, .y = names(list_clipseq_tibbles), .f = ~.x %>% dplyr::mutate("sample" = .y) %>% dplyr::mutate_all(as.character)) %>%
  purrr::reduce(dplyr::bind_rows)

## group-split the non-exonic entries by chromosome so we can map2 over both.
list_clipseq_binding_sites_split_by_chr <- purrr::map(.x = names(list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping),
                                                      .f = ~tibble_clipseq_binding_sites_combined[tibble_clipseq_binding_sites_combined$chr == .x, ]) %>% 
  set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)

## map2 over exonic and non-exonic GTF entries.
list_clipseq_binding_sites_transcriptome_relative_coords <- future_map2(.x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping,
                                                                        .y = list_clipseq_binding_sites_split_by_chr,
                                                                        .f = function(a1, a2) {
                                                                          
                                                                          # DEBUG ###
                                                                          # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[[1]]
                                                                          # a2 <- list_clipseq_binding_sites_split_by_chr[[1]]
                                                                          ###########
                                                                          
                                                                          # list-ify the non-exonic entries
                                                                          list_non_exonic_subset <- a2 %>% array_tree
                                                                          # loop thru each element, find overlapping exonic interval, subtract 
                                                                          list_non_exonic_subset_transcript_relative_coords <- future_map(
                                                                            .x = list_non_exonic_subset,
                                                                            .f = function(b1) {
                                                                              
                                                                              # DEBUG ###
                                                                              # b1 <- list_non_exonic_subset[[1]]
                                                                              ###########
                                                                              
                                                                              tibble_matching_exonic_entry <- a1[which(a1$start <= b1$start %>% type.convert & a1$end >= b1$end %>% type.convert), ]
                                                                              
                                                                              # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
                                                                              shift <- tibble_matching_exonic_entry$start - tibble_matching_exonic_entry$transcriptome_relative_start
                                                                              transcriptome_relative_start <- (b1$start %>% type.convert) - shift
                                                                              transcriptome_relative_end <- (b1$end %>% type.convert) - shift
                                                                              
                                                                              output_tibble <- splice(
                                                                                b1,
                                                                                "transcriptome_relative_start" = transcriptome_relative_start %>% list,
                                                                                "transcriptome_relative_end" = transcriptome_relative_end %>% list
                                                                              ) %>% as_tibble
                                                                              
                                                                              return(output_tibble)
                                                                              
                                                                            }, .progress = TRUE)
                                                                          
                                                                        }, .progress = TRUE)

# rbind and tibblise. 
# THESE WILL BE THE TRANSCRIPT-LEVEL FEATURES WHICH HAVE BEEN MAPPED ONTO TRANSCRIPT-RELATIVE COORDS.
tibble_clipseq_binding_sites_transcriptome_relative_coords <- list_clipseq_binding_sites_transcriptome_relative_coords %>% 
  purrr::map(~.x %>% rbindlist(use.names = TRUE)) %>% rbindlist(use.names = TRUE) %>% as_tibble %>% type_convert

# group_split back into each individual contributing sample
list_clipseq_binding_sites_transcriptome_relative_coords_separated_by_sample <- purrr::splice(
  tibble_clipseq_binding_sites_transcriptome_relative_coords %>% 
    dplyr::group_split(sample) %>%
    set_names(purrr::map(.x = ., .f = ~.x$sample %>% unique))
) %>% flatten

list_granges_clipseq_binding_sites_separated_by_sample <- list_clipseq_binding_sites_transcriptome_relative_coords_separated_by_sample %>%
  purrr::map(~toGRanges(.x[, c("chr", "transcriptome_relative_start", "transcriptome_relative_end")] %>% 
                          # turn chr column into chr1 chr2 etc...
                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                          type_convert %>% 
                          # data frame is absolutely necessary for regioneR.
                          as.data.frame))

```

#### get all the genome-relative positions of CDS nucleotides for every ENSP id

```{r}

# tibble_ENSP_to_genome_relative_CDS_positions <- tibble_ref_gtf_original %>% 
#   dplyr::filter(type == "CDS") %>% 
#   dplyr::group_split(protein_id) %>% 
#   future_map(.f = ~list("protein_id" = .x$protein_id %>% unique, "chr" = .x$chr %>% unique, "vec_all_parent_ENSP_CDS_positions_sorted" = purrr::map2(.x = .$start, .y = .$end, .f = ~.x:.y) %>% unlist %>% sort), .progress = TRUE, .options = future_options(globals = FALSE)) %>% 
#   future_map(.f = ~as_tibble(.x) %>% nest(data = "vec_all_parent_ENSP_CDS_positions_sorted") %>% dplyr::rename("vec_all_parent_ENSP_CDS_positions_sorted" = "data"), .progress = TRUE, .options = future_options(globals = c("as_tibble", "nest", "dplyr::rename"))) %>% 
#   rbindlist %>% as_tibble

# save(tibble_ENSP_to_genome_relative_CDS_positions, file = paste(results_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

load(file = paste(results_dir, "tibble_ENSP_to_genome_relative_CDS_positions.tibble", sep = ""))

load(file = paste(reference_data_dir, "tibble_interpro_domains_cast_onto_genome.tibble", sep = ""))

```

#### Cast biomart regions onto the genome, convert to exon*-relative topology, then convert to granges.

```{r}

# create a list of attributes to retrieve from biomart. we will loop thru this.
list_of_attributes_to_retrieve <- list("interpro" = c("ensembl_peptide_id", "interpro", "interpro_start", "interpro_end"),
                                       "ncoils" = c("ensembl_peptide_id", "ncoils_start", "ncoils_end"),
                                       "seg" = c("ensembl_peptide_id", "seg_start", "seg_end"),
                                       "signalp" = c("ensembl_peptide_id", "signalp_start", "signalp_end"),
                                       "tmhmm" = c("ensembl_peptide_id", "tmhmm_start", "tmhmm_end"),
                                       "sifts" = c("ensembl_peptide_id", "sifts_import", "sifts_import_start", "sifts_import_end"),
                                       "mobidblite" = c("ensembl_peptide_id", "mobidblite", "mobidblite_start", "mobidblite_end"))

# read tables
list_of_tibbles_biomart_domain_annotation <- future_map(.x = names(list_of_attributes_to_retrieve), .f = ~read.delim(paste(reference_data_dir, "table_biomart_ENSP_to_", .x, ".txt", sep = ""), row.names = NULL, header = TRUE, sep = "\t", stringsAsFactors = FALSE) %>% as_tibble, .progress = TRUE, .options = future_options(globals = c("as_tibble", "reference_data_dir"))) %>% 
  set_names(names(list_of_attributes_to_retrieve))

# rename columns of each nested tibble to be consistent
list_of_tibbles_biomart_domain_annotation <- list_of_tibbles_biomart_domain_annotation %>% purrr::map(.f = function(.x) {
  
  output_tibble <- .x
  
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*start$", replacement = "start")
  colnames(output_tibble) <- gsub(x = colnames(output_tibble), pattern = ".*end$", replacement = "end")
  
  return(output_tibble)
  
} )

# filter the interpro entries for the non-family entries only
list_of_tibbles_biomart_domain_annotation <- purrr::modify_at(.x = list_of_tibbles_biomart_domain_annotation,
                                                              .at = "interpro",
                                                              .f = ~dplyr::semi_join(.x, tibble_non_family_interpro_entries %>% dplyr::rename("interpro" = "Accession"), by = "interpro"))

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

list_of_tibbles_biomart_regions_cast_onto_genome <- future_imap(.x = list_of_tibbles_biomart_domain_annotation, .f = function(a1, a2) {
  
  # DEBUG ###
  # a1 <- list_of_tibbles_biomart_domain_annotation[["interpro"]]
  ###########
  
  cat("\nnow processing: ", a2, "\n")
  
  tibble_sorted_CDS_relative_positions <- a1 %>% 
    add_column("CDS_relative_coords_start" = ((3*.$start) - 2), "CDS_relative_coords_end" = (3*.$end)) %>% 
    dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
    dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
    # some ENSP ids from interpro are not in ensembl.
    dplyr::filter(is.na(chr) != TRUE) 
  
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  vec_all_genome_relative_coords_of_item <- future_map2(
    .x = tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions`, 
    .y = tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted`, 
    .f = function(b1, b2) {
      
      # DEBUG ###
      # b1 <- tibble_sorted_CDS_relative_positions$`vec_all_CDS_relative_positions` %>% .[[1]]
      # b2 <- tibble_sorted_CDS_relative_positions$`vec_all_parent_ENSP_CDS_positions_sorted` %>% .[[1]]
      ###########
      
      vec_parent_ENSP_CDS_positions <- b2 %>% unlist
      
      vec_parent_ENSP_CDS_positions[b1] %>% return
      
    }, .progress = TRUE, .options = future_options(globals = FALSE))
  
  nucleotide_width <- purrr::map(.x = vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist
  
  # add the genome-relative coords and nucleotide width in
  final_tibble_with_genome_relative_coords <- tibble_sorted_CDS_relative_positions %>% 
    add_column("vec_all_genome_relative_coords_of_item" = vec_all_genome_relative_coords_of_item,
               "nucleotide_width" = nucleotide_width)
  
}, .progress = TRUE ) 

# drop the columns of all ENSP positions. we dont need them anymore.
list_of_tibbles_biomart_regions_cast_onto_genome <- list_of_tibbles_biomart_regions_cast_onto_genome %>% purrr::map(~.x %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted))
# drop empty "chr" rows
# list_of_tibbles_biomart_regions_cast_onto_genome <- list_of_tibbles_biomart_regions_cast_onto_genome %>% purrr::map(~.x %>% dplyr::filter(is.na(chr) != TRUE))

# save(list_of_tibbles_biomart_regions_cast_onto_genome, file = paste(results_dir, "list_of_tibbles_biomart_regions_cast_onto_genome.Rlist", sep = ""))

# load(file = paste(results_dir, "list_of_tibbles_biomart_regions_cast_onto_genome.Rlist", sep = ""))

# plan(list(tweak(multiprocess, workers = 8),
#           tweak(multiprocess, workers = 8))
# )

## convert vector of discontinuous sites into chr, start, end.
list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_genome, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_biomart_regions_cast_onto_genome[[1]]
    ###########
    
    # make a tibble which maps the genome-relative coords of item with the corresponding chromosome
    tibble_genome_relative_coords_and_chr <- a1[, c("chr", "vec_all_genome_relative_coords_of_item")]
    # group split by chromosome
    list_of_tibbles_genome_relative_coords_by_chr <- tibble_genome_relative_coords_and_chr %>% 
      dplyr::group_split(chr)
    names(list_of_tibbles_genome_relative_coords_by_chr) <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$chr %>% unique, .progress = TRUE) %>% unlist
    # unlist each element and make unique
    list_of_tibbles_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unlist %>% unique %>% sort, .progress = TRUE)
    # re-tibblise and rbind for 1:1 chromosome marker to position mapping
    list_of_tibbles_genome_relative_coords_by_chr <- purrr::map2(.x = list_of_tibbles_genome_relative_coords_by_chr,
                                                                 .y = names(list_of_tibbles_genome_relative_coords_by_chr),
                                                                 .f = ~.x %>% tibble::enframe(name = NULL, value = "position") %>% 
                                                                   add_column("chr" = .y))
    
    tibble_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% rbindlist(use.names = TRUE) %>% as_tibble
    
    # convert tibble of chr and position to simple ranges
    tibble_simple_ranges <- convert_vector.of.positions_to_simple.ranges(
      input_vector = tibble_genome_relative_coords_by_chr$position, 
      metadata_vector = tibble_genome_relative_coords_by_chr$chr) %>% 
      # rename metadata column)
      dplyr::rename("chr" = "value") %>% 
      # filter out non-1:22/X/Y chromosome entries
      dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
      return
                    
  }, .progress = TRUE)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# recast the continuous genome-relative biomart ranges onto the CDS.
# L1: different biomart annotations
# L2: split by chromosome
list_of_tibbles_biomart_regions_cast_onto_exome_simple_ranges <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_biomart_regions_cast_onto_genome_simple_ranges[[1]]
    ###########
    
    # split by chromosome
    list_tibbles_biomart_regions_split_by_chromosome <- a1 %>% 
      dplyr::group_split(chr) %>%
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
    
    # get chromosomes in common with the CDS-relative mapping
    chr_in_common <- intersect(
      names(list_tibbles_biomart_regions_split_by_chromosome),
      names(list_exonic_GTF_entries_genome_to_exon_relative_mapping)
    )
    
    ## map2 over exonic and non-exonic GTF entries, per chromosome
    list_of_tibbles_biomart_regions_exome_relative_coords_single_annotation <- future_map2(
      .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common],
      .y = list_tibbles_biomart_regions_split_by_chromosome[chr_in_common],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common] %>% .[[1]]
        # b2 <- list_tibbles_biomart_regions_split_by_chromosome[chr_in_common] %>% .[[1]]
        ###########
        
        # list-ify the biomart entries, one element per row.
        list_biomart_subset <- b2 %>% array_tree
        # loop thru each element, find overlapping exonic interval, subtract 
        list_biomart_subset_exome_relative_coords <- future_map(
          .x = list_biomart_subset,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_biomart_subset[[1]]
            ###########
            
            tibble_matching_exome_entry <- b1[which(b1$start <= c1$start %>% type.convert & b1$end >= c1$end %>% type.convert), ]
            
            # based on shift (start)g - (start)t, we splice in the the CDS-relative coords of this genome-relative biomart element.
            shift <- tibble_matching_exome_entry$start - tibble_matching_exome_entry$transcript_relative_start
            transcript_relative_start <- (c1$start %>% type.convert) - shift
            transcript_relative_end <- (c1$end %>% type.convert) - shift
            
            output_tibble <- splice(
              c1,
              "transcript_relative_start" = transcript_relative_start %>% list,
              "transcript_relative_end" = transcript_relative_end %>% list
            ) %>% as_tibble
            
            return(output_tibble)
            
          }, .progress = TRUE, .options = future_options(globals = c("b1")) )
        
        # rbindlist and tibblise
        tibble_biomart_subset_exome_relative_coords <- list_biomart_subset_exome_relative_coords %>% rbindlist %>% as_tibble
        
        return(tibble_biomart_subset_exome_relative_coords)
        
      }, .progress = TRUE)
    
    # rbind and tibblise
    tibble_biomart_regions_exome_relative_coords_single_annotation <- list_of_tibbles_biomart_regions_exome_relative_coords_single_annotation %>% 
      rbindlist %>% as_tibble %>% type_convert
    
    return(tibble_biomart_regions_exome_relative_coords_single_annotation)
    
  }, .progress = TRUE )

# finally convert the CDS relative biomart regions into granges
list_granges_biomart_regions_exome_relative <- future_map(
  .x = list_of_tibbles_biomart_regions_cast_onto_exome_simple_ranges,
  .f = function(a1) {
    
    granges_biomart_region <- toGRanges(a1[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                          # turn chr column into chr1 chr2 etc...
                                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                          type_convert %>% 
                                          # data frame is absolutele necessary for regioneR.
                                          as.data.frame)
    
    return(granges_biomart_region)
    
  }, .progress = TRUE )

```

#### cast dbPTM sites onto the genome, convert to exon*-relative topology, then convert to granges.

```{r}

# get ENSP to uniprotkb_entry mapping
# tibble_ENSP_to_uniprotkb <- biomaRt::getBM(attributes = c("ensembl_peptide_id", "uniprotsptrembl"), mart = ensembl_mart) %>% setNames(c("ensembl_peptide_id", "uniprotkb_entry")) %>% 
# type_convert %>% 
# as_tibble %>%
# na.omit

tibble_ENSP_to_uniprotkb <- read.delim(file = paste(reference_data_dir, "table_ENSP_to_uniprot_entry_mapping_38.98.txt", sep = ""), sep = "\t", stringsAsFactors = FALSE, header = TRUE, row.names = NULL) %>% as_tibble

# convert uniprotkb_entry into ENSP
tibble_dbPTM_allhuman_annotations_with_ENSP <- dplyr::left_join(tibble_dbPTM_allhuman_annotations, tibble_ENSP_to_uniprotkb, by = "uniprotkb_entry") %>% 
  dplyr::filter(is.na(ensembl_peptide_id) != TRUE) %>% type_convert

# cast onto genome.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_with_ENSP %>% 
  add_column("CDS_relative_coords_start" = ((3*.$modified_residue_position) - 2), "CDS_relative_coords_end" = (3*.$modified_residue_position)) %>% 
  dplyr::mutate("vec_all_CDS_relative_positions" = purrr::map2(.x = `CDS_relative_coords_start`, .y = `CDS_relative_coords_end`, .f = ~.x:.y)) %>%
  dplyr::left_join(., tibble_ENSP_to_genome_relative_CDS_positions %>% dplyr::rename("ensembl_peptide_id" = "protein_id"), by = "ensembl_peptide_id") %>%
  # some ENSP ids from interpro are not in ensembl.
  dplyr::filter(is.na(chr) != TRUE) %>%
  # the parent ENSP CDS positions are sorted already. we just retrieve the genome-relative positions using the CDS-relative positions. 
  # these are the regions casted onto the genome.
  dplyr::mutate("vec_all_genome_relative_coords_of_item" = purrr::map2(.x = .$vec_all_CDS_relative_positions, .y = .$vec_all_parent_ENSP_CDS_positions_sorted, .f = ~.y %>% unlist %>% .[.x], .progress = TRUE, .options = future_options(globals = FALSE))) %>%
  dplyr::mutate("nucleotide_width" = purrr::map(.x = .$vec_all_genome_relative_coords_of_item, .f = ~length(.x)) %>% unlist)

# drop the columns of all ENSP positions. we dont need them anymore.
tibble_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>% dplyr::select(-vec_all_parent_ENSP_CDS_positions_sorted)
# save(tibble_dbPTM_allhuman_annotations_cast_onto_genome, file = paste(results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.Rlist", sep = ""))

# load(file = paste(results_dir, "tibble_dbPTM_allhuman_annotations_cast_onto_genome.Rlist", sep = ""))

# split by PTM type
list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome <- tibble_dbPTM_allhuman_annotations_cast_onto_genome %>%
  dplyr::group_split(PTM_type) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$PTM_type %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

## convert vector of discontinuous sites into chr, start, end.
list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges <- future_map(
  .x = list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_tibbles_dbPTM_allhuman_annotations_cast_onto_genome[[1]]
    ###########
    
    # make a tibble which maps the genome-relative coords of item with the corresponding chromosome
    tibble_genome_relative_coords_and_chr <- a1[, c("chr", "vec_all_genome_relative_coords_of_item")]
    # group split by chromosome
    list_of_tibbles_genome_relative_coords_by_chr <- tibble_genome_relative_coords_and_chr %>% 
      dplyr::group_split(chr)
    names(list_of_tibbles_genome_relative_coords_by_chr) <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$chr %>% unique, .progress = TRUE) %>% unlist
    # unlist each element and make unique
    list_of_tibbles_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% future_map(.f = ~.x$vec_all_genome_relative_coords_of_item %>% unlist %>% unlist %>% unique %>% sort, .progress = TRUE)
    # re-tibblise and rbind for 1:1 chromosome marker to position mapping
    list_of_tibbles_genome_relative_coords_by_chr <- purrr::map2(.x = list_of_tibbles_genome_relative_coords_by_chr,
                                                                 .y = names(list_of_tibbles_genome_relative_coords_by_chr),
                                                                 .f = ~.x %>% tibble::enframe(name = NULL, value = "position") %>% 
                                                                   add_column("chr" = .y))
    
    tibble_genome_relative_coords_by_chr <- list_of_tibbles_genome_relative_coords_by_chr %>% rbindlist(use.names = TRUE) %>% as_tibble
    
    # convert tibble of chr and position to simple ranges
    tibble_simple_ranges <- convert_vector.of.positions_to_simple.ranges(
      input_vector = tibble_genome_relative_coords_by_chr$position, 
      metadata_vector = tibble_genome_relative_coords_by_chr$chr) %>% 
      # rename metadata column)
      dplyr::rename("chr" = "value") %>% 
      # filter out non-1:22/X/Y chromosome entries
      dplyr::filter(chr %in% c(1:22, "X", "Y")) %>%
      return
                    
  }, .progress = TRUE)

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 4))
)

# recast the continuous genome-relative biomart ranges onto the *exome
# L1: different biomart annotations
# L2: split by chromosome
list_of_tibbles_PTM_sites_cast_onto_exome_simple_ranges <- future_map(
  .x = list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_of_tibbles_PTM_sites_cast_onto_genome_simple_ranges[[1]]
    ###########
    
    # split by chromosome
    list_tibbles_regions_split_by_chromosome <- a1 %>% 
      dplyr::group_split(chr) %>%
      set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
    
    # get chromosomes in common with the CDS-relative mapping
    chr_in_common <- intersect(
      names(list_tibbles_regions_split_by_chromosome),
      names(list_exonic_GTF_entries_genome_to_exon_relative_mapping)
    )
    
    ## map2 over exonic and non-exonic GTF entries, per chromosome
    list_of_tibbles_PTM_sites_exome_relative_coords_single_annotation <- future_map2(
      .x = list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common],
      .y = list_tibbles_regions_split_by_chromosome[chr_in_common],
      .f = function(b1, b2) {
        
        # DEBUG ###
        # b1 <- list_exonic_GTF_entries_genome_to_exon_relative_mapping[chr_in_common] %>% .[[1]]
        # b2 <- list_tibbles_regions_split_by_chromosome[chr_in_common] %>% .[[1]]
        ###########
        
        # list-ify the entries, one element per row.
        list_subset <- b2 %>% array_tree
        # loop thru each element, find overlapping CDS interval, subtract 
        list_PTM_subset_exome_relative_coords <- future_map(
          .x = list_subset,
          .f = function(c1) {
            
            # DEBUG ###
            # c1 <- list_subset[[1]]
            ###########
            
            tibble_matching_CDS_entry <- b1[which(b1$start <= c1$start %>% type.convert & b1$end >= c1$end %>% type.convert), ]
            
            # based on shift (start)g - (start)t, we splice in the the CDS-relative coords of this genome-relative biomart element.
            shift <- tibble_matching_CDS_entry$start - tibble_matching_CDS_entry$transcript_relative_start
            transcript_relative_start <- (c1$start %>% type.convert) - shift
            transcript_relative_end <- (c1$end %>% type.convert) - shift
            
            output_tibble <- splice(
              c1,
              "transcript_relative_start" = transcript_relative_start %>% list,
              "transcript_relative_end" = transcript_relative_end %>% list
            ) %>% as_tibble
            
            return(output_tibble)
            
          }, .progress = TRUE, .options = future_options(globals = c("b1")) )
        
        # rbindlist and tibblise
        tibble_PTM_subset_exome_relative_coords <- list_PTM_subset_exome_relative_coords %>% rbindlist %>% as_tibble
        
        return(tibble_PTM_subset_exome_relative_coords)
        
      }, .progress = TRUE)
    
    # rbind and tibblise
    tibble_PTM_sites_exome_relative_coords_single_annotation <- list_of_tibbles_PTM_sites_exome_relative_coords_single_annotation %>% 
      rbindlist %>% as_tibble %>% type_convert
    
    return(tibble_PTM_sites_exome_relative_coords_single_annotation)
    
  }, .progress = TRUE )

# finally convert the CDS relative PTM sites into granges
list_granges_PTM_sites_exome_relative <- future_map(
  .x = list_of_tibbles_PTM_sites_cast_onto_exome_simple_ranges,
  .f = function(a1) {
    
    granges_PTM_sites <- toGRanges(a1[, c("chr", "transcript_relative_start", "transcript_relative_end")] %>% 
                                          # turn chr column into chr1 chr2 etc...
                                          dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                          type_convert %>% 
                                          # data frame is absolutely necessary for regioneR.
                                          as.data.frame)
    
    return(granges_PTM_sites)
    
  }, .progress = TRUE )

```

### Permutation test

#### Set up all source lists

```{r}

# granges_effective_CDSome
# granges_effective_exome 

# list_granges_ensembl_transcript_types
# list_granges_biomart_regions_CDS_relative 
# list_granges_PTM_sites_CDS_relative

list_granges_transcriptomic_VSR_positions <- list(
  "JUM_differential_VSR" = granges_JUM_differential_VSR_transcriptome_relative_coords,
  "PSIsigma_differential_VSR" = granges_PSIsigma_differential_VSR_transcriptome_relative_coords,
  "JUM_constitutive_VSR" = granges_JUM_constitutive_VSR_transcriptome_relative_coords,
  "PSIsigma_constitutive_VSR" = granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords
)

list_granges_exonic_differential_positions <- list(
  "JUM_exonic_unfiltered" = granges_JUM_differential_exonic_regions_all.RNA,
  "PSIsigma_exonic_unfiltered" = granges_PSIsigma_differential_exonic_regions_all.RNA,
  "JUM_exonic_proteome_filtered" = granges_JUM_differential_exonic_regions_proteome.filtered.RNA,
  "PSIsigma_exonic_proteome_filtered" = granges_PSIsigma_differential_exonic_regions_proteome.filtered.RNA)

list_granges_CDS_differential_positions <- list(
  "JUM_CDS_unfiltered" = granges_JUM_differential_CDS_regions_all.RNA,
  "PSIsigma_CDS_unfiltered" = granges_PSIsigma_differential_CDS_regions_all.RNA,
  "JUM_CDS_proteome_filtered" = granges_JUM_differential_CDS_regions_proteome.filtered.RNA,
  "PSIsigma_CDS_proteome_filtered" = granges_PSIsigma_differential_CDS_regions_proteome.filtered.RNA)

```

#### JUM/PSI-SIgma VSRs and CLIP-seq regions - **TRANSCRIPTOME**

```{r}

plan(list(tweak(multisession, workers = 2),
          tweak(multisession, workers = 8),
          tweak(multisession, workers = 8))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: transcript type
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_transcript_types <- future_map(
  .x = list_granges_transcriptomic_VSR_positions[c("JUM_differential_VSR", "PSIsigma_differential_VSR")], 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_transcriptomic_VSR_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_clipseq_binding_sites_separated_by_sample,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_clipseq_binding_sites_separated_by_sample[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        # NOTE!!!!! WE ARE MOVING THE *CLIP-SEQ* REGIONS, NOT THE DIFFERENTIAL JUM/PSI-SIGMA REGIONS!!
        # THIS IS BECAUSE WE WANT TO FIND OUT WHETHER THE CLIP-SEQ REGIONS ARE DISTINGUISHABLE FROM PURELY RANDOM POSITIONS!!!
        regioneR::permTest(A = b1,
                           B = a1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_transcriptome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 8) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_transcript_types, file = paste(results_dir, "list_permtest_JUM_PSIsigma_VSR_vs_clipseq_binding_sites.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_transcript_types_pvalues <- list_permtest_exonic_transcript_types %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

# plot the perm tests
purrr::map_depth(.x = list_permtest_exonic_transcript_types, .depth = 2, .f = ~.x %>% plot)

```

#### ensembl transcript-level regions - loop thru each type of region - **EXOME**

- we use random shuffle permutations at the level of the exome or CDS. This is because contiguity is achieved in the exome and CDS.

```{r}

plan(list(tweak(multiprocess, workers = 2),
          tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: transcript type
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_transcript_types <- future_map(
  .x = list_granges_exonic_differential_positions[c("JUM_exonic_unfiltered", "PSIsigma_exonic_unfiltered")], 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_ensembl_transcript_types,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_ensembl_transcript_types[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 8) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_transcript_types, file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_transcript_types.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_transcript_types_pvalues <- list_permtest_exonic_transcript_types %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

```

#### biomarts regions - loop thru each type of region - **EXOME (revised)**

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 7),
          tweak(multiprocess, workers = 4))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: biomart region
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_biomart_regions <- future_map(
  .x = list_granges_exonic_differential_positions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_biomart_regions_exome_relative,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_biomart_regions_exome_relative[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 4) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_biomart_regions, file = paste(results_dir, "list_permtest_exonic_biomart_regions.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_biomart_regions.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_biomart_regions_pvalues <- list_permtest_exonic_biomart_regions %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))

```

#### PTMs - loop thru each type of PTM - **EXOME (revised)**

```{r}

plan(list(tweak(multiprocess, workers = 4),
          tweak(multiprocess, workers = 12),
          tweak(multiprocess, workers = 4))
)

# permtests
## L1: JUM/PSI-Sigma, filtered/unfiltered
## L2: biomart region
## NOTE: we do not need to filter by proteome for the exome.
list_permtest_exonic_PTMs <- future_map(
  .x = list_granges_exonic_differential_positions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_granges_exonic_differential_positions[[1]]
    ###########
    
    list_result <- future_map(
      .x = list_granges_PTM_sites_exome_relative,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_granges_PTM_sites_exome_relative[[1]]
        ###########
        
        # 4 cores for 1,000 iterations; 8 cores for 10,000
        
        regioneR::permTest(A = a1,
                           B = b1,
                           randomize.function = randomizeRegions,
                           non.overlapping = TRUE,
                           per.chromosome = FALSE,
                           evaluate.function = numOverlaps,
                           ntimes = 10000,
                           genome = granges_effective_exome,
                           # min.parallel = 8,
                           alternative = "greater",
                           force.parallel = TRUE,
                           verbose = TRUE,
                           mc.cores = 4) %>%
          return
        
      }, .progress = TRUE )
    
  }, .progress = TRUE )

                                                      
save(list_permtest_exonic_PTMs, file = paste(results_dir, "list_permtest_exonic_PTMs.Rlist", sep = ""))
# load(file = paste(results_dir, "list_permtest_exonic_PTMs.Rlist", sep = ""))

# extract the pvalues
list_permtest_exonic_PTMs_pvalues <- list_permtest_exonic_PTMs %>% purrr::map(.f = ~purrr::map(.x = .x, .f = ~.x$numOverlaps$pval))


```

```{r}

# optional: save workspace for debugging because i'm going to run this overnight and go to sleep.
save.image(file = "/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/multiomic_synthesis/source/22092020_topology_conversion_bootstrapping.RData")

stop("Proteome section finished")

```

# benchmark performance of NMD flagger

comparisons are done at the level of transcripts.

```{r}

tibble_ref_gtf_with_NMD_flagged_unique_transcripts <- tibble_ref_gtf_with_NMD_flagged_E2 %>% .[-which(is.na(.$transcript_id)), c("transcript_id", "seqnames", "strand", "start", "end", "transcript_biotype", "NMD_candidate")] %>% dplyr::distinct(transcript_id, .keep_all = TRUE) %>% add_column("identifier" = paste(.$seqnames, ":", .$start, "-", .$end, sep = ""))

# get row indices of those transcripts with ref. annotated NMD
row.indices_ref_NMD <- which(tibble_ref_gtf_with_NMD_flagged_unique_transcripts$transcript_biotype == "nonsense_mediated_decay")

# get row indices of those transcripts flagged as NMD
row.indices_flagged_NMD <- grep(x = tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate, pattern = "TRUE")

message("number of reference transcripts with reference NMD annotation: ", row.indices_ref_NMD %>% length, " (", (row.indices_ref_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of reference transcripts flagged as NMD: ", row.indices_flagged_NMD %>% length, " (", (row.indices_flagged_NMD %>% length * 100 / tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% nrow), "%)")
message("number of transcripts flagged as NMD in common with annotation: ", intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)
message("jaccard: ", (intersect(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length)/(union(row.indices_ref_NMD, row.indices_flagged_NMD) %>% length))

# ggplot of the transcript_biotype of NMD candidates

## neat descending order of x-axis
tibble_frequency_distribution <- tibble_ref_gtf_with_NMD_flagged_unique_transcripts %>% 
  dplyr::filter(NMD_candidate == "TRUE") %>% 
  dplyr::group_by(transcript_biotype) %>% 
  dplyr::summarise("count_per_transcript_biotype" = n()) %>% 
  dplyr::arrange(desc(count_per_transcript_biotype))

message("percent protein_coding of total: ", (tibble_frequency_distribution[tibble_frequency_distribution$transcript_biotype == "protein_coding", "count_per_transcript_biotype"] %>% paste %>% as.numeric)*100/sum(tibble_frequency_distribution$count_per_transcript_biotype), "%")

x_axis_order <- tibble_frequency_distribution %>% .$transcript_biotype %>% unique

ggplot(data = tibble_ref_gtf_with_NMD_flagged_unique_transcripts[tibble_ref_gtf_with_NMD_flagged_unique_transcripts$NMD_candidate == "TRUE", ]) +
  geom_bar(mapping = aes(x = transcript_biotype, y = ..count..)) +
  geom_label(stat = "count", aes(x = transcript_biotype, label = ..count..)) +
  scale_x_discrete(breaks = x_axis_order, limits = x_axis_order) +
  ggtitle("Common Ensembl transcript_biotype annotations associated with flagged NMD transcripts
          (minimum 5 exons)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), text = element_text(family = "Helvetica")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, colour = "black"), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.pdf", sep = ""), device = "pdf", dpi = 600, width = 25, height = 15, units = "cm") +
  ggsave(filename = paste(results_dir, "frequency_of_ensembl_transcript_biotype_flagged_as_NMD_E5.svg", sep = ""), device = "svg", dpi = 600, width = 25, height = 15, units = "cm") 

```

# sQTL and disease ontology - JUM and PSI-Sigma

## Cross reference SNPs from the GWAS catalog

### find SNPs which lie in AS regions

#### prepare bootstrapping tools - bootstrap for SNP regions.

```{r}

library(regioneR)

library(BSgenome.Hsapiens.UCSC.hg38)

set.seed(7)

options(mc.cores = 16)

```

At the present time, we are looking for SNPs in whole LSV regions for both JUM and PSI-Sigma. This is because mutations can occur at the cis-ESS/ESE/ISS/ISEs, which are not always in the exons/introns of interest.

#### calculate overlap

##### JUM differential

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end_differential <- tibble(
  "AS_event_ID" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_differential_array.tree <- tibble_AS.event.IDs_chr_start_end_differential %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_differential <- future_map(.x = list_JUM_AS.event.IDs_differential_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_differential_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                CHR_POS >= .x$start %>% as.numeric &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .x$AS_event_ID,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end,
                                                  "AS_event_ID_splicemode" = .x$splicemode)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_JUM_differential_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_differential %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

# get a tally of traits
tibble_JUM_differential_AS.event.ID_snps_summary_by_trait <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_JUM_differential" = n()) %>% dplyr::arrange(desc(trait_tally_JUM_differential))
# get a tally of context e.g. intron or coding sequence variant
tibble_JUM_differential_AS.event.ID_snps_summary_by_context <- tibble_JUM_differential_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_JUM_differential" = n()) %>% dplyr::arrange(desc(context_tally_JUM_differential))

```

##### JUM constitutive

```{r}

# extract chr, start and end from AS_event_IDs
tibble_AS.event.IDs_chr_start_end_constitutive <- tibble(
  "AS_event_ID" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID,
  "chr" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\1"),
  "start" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\3"),
  "end" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\5"),
  "strand" = gsub(x = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$AS_event_ID, pattern = "^([^_]+)_(\\+|\\-)_([0-9]{1,10})(.*{0,1})_([0-9]{1,10}$)", replacement = "\\2"),
  "splicemode" = tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_JUM_AS.event.IDs_constitutive_array.tree <- tibble_AS.event.IDs_chr_start_end_constitutive %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_constitutive <- future_map(.x = list_JUM_AS.event.IDs_constitutive_array.tree, .f = function(.x) {
    
    # DEBUG ###
    # .x <- list_JUM_AS.event.IDs_differential_array.tree[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                CHR_POS >= .x$start %>% as.numeric &
                                                CHR_POS <= .x$end %>% as.numeric)
    
    subset_tibble <- subset_tibble %>% add_column("AS_event_ID" = .x$AS_event_ID,
                                                  "AS_event_ID_start" = .x$start,
                                                  "AS_event_ID_end" = .x$end,
                                                  "AS_event_ID_splicemode" = .x$splicemode)
    
    return(subset_tibble)

    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_with_AS.event.IDs_constitutive %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT) %>% dplyr::distinct(AS_event_ID_start, AS_event_ID_end, .keep_all = TRUE)

tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_JUM_constitutive" = n()) %>% dplyr::arrange(desc(trait_tally_JUM_constitutive))
# get a tally of context e.g. intron or coding sequence variant
tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context <- tibble_JUM_constitutive_AS.event.ID_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_JUM_constitutive" = n()) %>% dplyr::arrange(desc(context_tally_JUM_constitutive))

```

##### psi-sigma differential

```{r}

# extract chr, start and end from diff_exon_coords
tibble_psisigma_differential_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_psisigma_differential_chr_start_end_array.tree <- tibble_psisigma_differential_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_differential <- future_map(.x = list_psisigma_differential_chr_start_end_array.tree, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                               CHR_POS >= .x$start %>% as.numeric &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("event_region_coords" = .x$event_region_coords,
                                                "event_region_start" = .x$start,
                                                "event_region_end" = .x$end,
                                                "event_region_splicemode" = .x$splicemode)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_psisigma_differential_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_differential %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_differential_all_overlapping_snps_filtered <- tibble_psisigma_differential_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_psisigma_differential_snps_summary_by_trait <- tibble_psisigma_differential_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`DISEASE/TRAIT`) %>% dplyr::summarise("trait_tally_PSIsigma_differential" = n()) %>% dplyr::arrange(desc(trait_tally_PSIsigma_differential))
# get a tally of context e.g. intron or coding sequence variant
tibble_psisigma_differential_snps_summary_by_context <- tibble_psisigma_differential_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_PSIsigma_differential" = n()) %>% dplyr::arrange(desc(context_tally_PSIsigma_differential))

```

##### psi-sigma constitutive

```{r}

# extract chr, start and end from diff_exon_coords
tibble_psisigma_constitutive_chr_start_end <- tibble(
  "event_region_coords" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords,
  "chr" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\1"),
  "start" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\2"),
  "end" = gsub(x = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$event_region_coords, pattern = "^([^:]+):([^\\-]+)\\-([^:]+)$", replacement = "\\3"),
  "splicemode" = tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na$splicemode) %>%
  unique

# list-ify the AS_event_IDs
list_psisigma_constitutive_chr_start_end_array.tree <- tibble_psisigma_constitutive_chr_start_end %>% array_tree

# match each AS_event_ID with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_constitutive <- future_map(.x = list_psisigma_constitutive_chr_start_end_array.tree, .f = function(.x) {
  
  # DEBUG ###
  # .x <- list_JUM_AS.event.IDs_array.tree[[1]]
  ###########
  
  # cat("now processing: ", .y, "\n")
  
  subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == .x$chr &
                                                               CHR_POS >= .x$start %>% as.numeric &
                                                               CHR_POS <= .x$end %>% as.numeric)
  
  subset_tibble <- subset_tibble %>% add_column("event_region_coords" = .x$event_region_coords,
                                                "event_region_start" = .x$start,
                                                "event_region_end" = .x$end,
                                                "event_region_splicemode" = .x$splicemode)
  
  return(subset_tibble)
  
  
}, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column")))

tibble_psisigma_constitutive_all_overlapping_snps <- list_of_gwas_catalog_entries_overlapped_constitutive %>% rbindlist %>% as_tibble %>% dplyr::arrange(MAPPED_TRAIT)

tibble_psisigma_constitutive_all_overlapping_snps_filtered <- tibble_psisigma_constitutive_all_overlapping_snps %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  dplyr::group_by(`DISEASE/TRAIT`)

tibble_psisigma_constitutive_snps_summary_by_trait <- tibble_psisigma_constitutive_all_overlapping_snps_filtered %>% dplyr::summarise("trait_tally_PSIsigma_constitutive" = n()) %>% dplyr::arrange(desc(trait_tally_PSIsigma_constitutive))
# get a tally of context e.g. intron or coding sequence variant
tibble_psisigma_constitutive_snps_summary_by_context <- tibble_psisigma_constitutive_all_overlapping_snps_filtered %>% dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% dplyr::group_by(`CONTEXT`) %>% dplyr::summarise("context_tally_PSIsigma_constitutive" = n()) %>% dplyr::arrange(desc(context_tally_PSIsigma_constitutive))

```

#### combine overlap data

```{r}

# merge trait and context tally tables together for all data series and melt
long_tibble_combined_overlap_traits <- list(tibble_JUM_differential_AS.event.ID_snps_summary_by_trait, 
                                    tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait, 
                                    tibble_psisigma_differential_snps_summary_by_trait,
                                    tibble_psisigma_constitutive_snps_summary_by_trait) %>% 
  purrr::reduce(dplyr::left_join, by = "DISEASE/TRAIT") %>%
  # arrange in descending order of geometric mean
  dplyr::arrange((trait_tally_JUM_differential * trait_tally_JUM_constitutive * trait_tally_PSIsigma_differential * trait_tally_PSIsigma_constitutive) ^ (1/4)) %>%
  na.omit %>%
  tail(n = 8) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = "DISEASE/TRAIT", .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "DISEASE/TRAIT", variable.name = "tool_diff.cons", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {column <- factor(x = x, levels = c("trait_tally_PSIsigma_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_JUM_constitutive", "trait_tally_JUM_differential")); return(column)} )

long_tibble_combined_overlap_contexts <- list(tibble_JUM_differential_AS.event.ID_snps_summary_by_context, 
                                      tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context, 
                                      tibble_psisigma_differential_snps_summary_by_context,
                                      tibble_psisigma_constitutive_snps_summary_by_context) %>% 
  purrr::reduce(dplyr::left_join, by = "CONTEXT") %>%
  # arrange in descending order of geometric mean
  dplyr::arrange(((context_tally_JUM_differential) ^ (1/4)) * 
                   ((context_tally_JUM_constitutive) ^ (1/4)) * 
                   ((context_tally_PSIsigma_differential) ^ (1/4)) * 
                   ((context_tally_PSIsigma_constitutive) ^ (1/4))) %>%
  # reorder factors for correct plotting order
  dplyr::mutate_at(.vars = "CONTEXT", .funs = as_factor) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "CONTEXT", variable.name = "tool_diff.cons", value.name = "tally") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {column <- factor(x = x, levels = c("context_tally_PSIsigma_constitutive", "context_tally_PSIsigma_differential", "context_tally_JUM_constitutive", "context_tally_JUM_differential")) ; return(column)} )

```

#### bootstrapping to calculate p-value of region overlapping with SNP

##### Filter for SNPs only in transcript regions, cast onto effective transcriptome

We have to replace the "CHR_POS" values in the ebi gwas table with the corresponding transcriptome-relative coords.

```{r}

plan(list(tweak(multiprocess, workers = 25),
          tweak(multiprocess, workers = 8))
)

## convert to transcriptome-relative coords ###
## group-split the input entries to be converted by chromosome so we can map2 over it and the mapping list.
list_of_tibbles_input_chr_start_end_by_chr <- tibble_ebi_gwas_catalog_deduped %>% 
  dplyr::mutate_at(.vars = "CHR_ID", .funs = trimws) %>%
  dplyr::group_split(CHR_ID) %>%
  set_names(x = ., nm = purrr::map(.x = ., .f = ~.x$`CHR_ID` %>% unique) %>% unlist)

## map2 over transcriptome-mapping file
list_ebi_gwas_catalog_deduped_transcriptome_relative <- future_map2(
  .x = list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names],
  .y = list_of_tibbles_input_chr_start_end_by_chr,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_transcriptomic_GTF_entries_genome_to_transcriptome_relative_mapping[list_of_tibbles_input_chr_start_end_by_chr %>% names] %>% .[[1]]
    # a2 <- list_of_tibbles_input_chr_start_end_by_chr[[1]]
    ###########
    
    # list-ify the raw co-ords to be converted
    list_raw_coords_subset <- a2 %>% array_tree
    # loop thru each element, find overlapping exonic interval, subtract 
    list_transcript_relative_coords <- future_map(
      .x = list_raw_coords_subset,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_raw_coords_subset[[1]]
        ###########
        
        tibble_matching_transcriptomic_entry <- a1[which(a1$start <= b1$CHR_POS %>% type.convert & a1$end >= b1$CHR_POS %>% type.convert), ]
        
        # based on shift (start)g - (start)t, we splice in the the transcript-relative coords of this non-exonic element.
        shift <- tibble_matching_transcriptomic_entry$start - tibble_matching_transcriptomic_entry$transcriptome_relative_start
        transcriptome_relative_position <- (b1$CHR_POS %>% type.convert) - shift
        
        # update list
        updated_list <- b1
        
        if (tibble_matching_transcriptomic_entry %>% nrow > 0) {
          
          updated_list$CHR_POS <- transcriptome_relative_position
          
        } else {
          
          updated_list$CHR_POS <- NA
          
        }
        
        suppressMessages(suppressWarnings(
          return(updated_list %>% as_tibble)
        ))
          
      }, .options = future_options(globals = c("a1")) )
      
      return(list_transcript_relative_coords)
      
  }, .progress = TRUE) 


tibble_ebi_gwas_catalog_deduped_transcriptome_relative <- list_ebi_gwas_catalog_deduped_transcriptome_relative %>% flatten %>% rbindlist %>% as_tibble

```

##### JUM differential
###### traits

```{r}

plan(list(tweak(multiprocess, workers = 8),
          tweak(multiprocess, workers = 8))
)

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_differential_traits <- future_map(.x = tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[tibble_JUM_differential_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
  # DEBUG ###
  # .x <- tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[tibble_JUM_differential_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT` %>% .[[1]]
  ###########
  
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>% 
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(granges_JUM_differential_VSR_transcriptome_relative_coords[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                                                         
                                             permtest_result <- permTest(A = granges_JUM_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_differential_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_differential_traits <- list_permtest_results_JUM_differential_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_JUM_differential"))

save(list_permtest_results_JUM_differential_traits, file = paste(results_dir, "list_permtest_results_JUM_differential_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_differential_contexts <- future_map(.x = tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
  # DEBUG ###
  # .x <- tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT` %>% .[[10]]
  ###########
  
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutely necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_differential[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_JUM_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_differential_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_differential_contexts <- list_permtest_results_JUM_differential_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_JUM_differential"))

save(list_permtest_results_JUM_differential_contexts, file = paste(results_dir, "list_permtest_results_JUM_differential_contexts.Rlist", sep = ""))

```

##### JUM constitutive
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_constitutive_traits <- future_map(.x = tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait[tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_constitutive[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_JUM_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = FALSE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_constitutive_AS.event.ID_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_constitutive_traits <- list_permtest_results_JUM_constitutive_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_JUM_constitutive"))

save(list_permtest_results_JUM_constitutive_traits, file = paste(results_dir, "list_permtest_results_JUM_constitutive_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_JUM_constitutive_contexts <- future_map(.x = tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_AS.event.IDs_chr_start_end_constitutive[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             # 
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 10000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             # 
                                             permtest_result <- permTest(A = granges_JUM_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_JUM_constitutive_AS.event.ID_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_JUM_constitutive_contexts <- list_permtest_results_JUM_constitutive_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_JUM_constitutive"))

save(list_permtest_results_JUM_constitutive_contexts, file = paste(results_dir, "list_permtest_results_JUM_constitutive_contexts.Rlist", sep = ""))

```

##### PSI-Sigma differential
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_differential_traits <- future_map(.x = tibble_psisigma_differential_snps_summary_by_trait[tibble_psisigma_differential_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             # granges_items_chr_start_end <- toGRanges(tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% 
                                             #                                            # remove MT ranges
                                             #                                            dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                             #                                            # turn chr column into chr1 chr2 etc...
                                             #                                            dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                             #                                            type_convert %>% 
                                             #                                            # data frame is absolutele necessary for regioneR.
                                             #                                            as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_differential_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_differential_traits <- list_permtest_results_PSIsigma_differential_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_PSIsigma_differential"))

save(list_permtest_results_PSIsigma_differential_traits, file = paste(results_dir, "list_permtest_results_PSIsigma_differential_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_differential_contexts <- future_map(.x = tibble_psisigma_differential_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_differential_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_differential_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_differential_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_differential_contexts <- list_permtest_results_PSIsigma_differential_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_PSIsigma_differential"))

save(list_permtest_results_PSIsigma_differential_contexts, file = paste(results_dir, "list_permtest_results_PSIsigma_differential_contexts.Rlist", sep = ""))

```

##### PSI-Sigma constitutive
###### traits

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_constitutive_traits <- future_map(.x = tibble_psisigma_constitutive_snps_summary_by_trait[tibble_psisigma_constitutive_snps_summary_by_trait$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% .$`DISEASE/TRAIT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`DISEASE/TRAIT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_constitutive_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_constitutive_snps_summary_by_trait[1:8, ] %>% .$`DISEASE/TRAIT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_constitutive_traits <- list_permtest_results_PSIsigma_constitutive_traits %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "DISEASE/TRAIT", .name_repair = "unique") %>% setNames(c("DISEASE/TRAIT", "significant_PSIsigma_constitutive"))

save(list_permtest_results_PSIsigma_constitutive_traits, file = paste(results_dir, "list_permtest_results_PSIsigma_constitutive_traits.Rlist", sep = ""))

```

###### contexts

```{r}

# use purrr to test significance of all traits simultaneously
list_permtest_results_PSIsigma_constitutive_contexts <- future_map(.x = tibble_psisigma_constitutive_snps_summary_by_context %>% .$`CONTEXT`, .f = function(.x) {
                                             
                                             # TURN THE SNP POSITIONS INTO GRANGES OBJECT
                                             granges_gwas_catalog <- toGRanges(tibble_ebi_gwas_catalog_deduped_transcriptome_relative %>% 
                                                                                 # filter for phenotype
                                                                                 dplyr::filter(`CONTEXT` == .x & grepl(x = `INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), .preserve = TRUE) %>%
                                                                                 .[, c("CHR_ID", "CHR_POS", "CHR_POS")] %>% 
                                                                                 na.omit %>%
                                                                                 setNames(c("chr", "start", "end")) %>%
                                                                                 # add_column("width" = 1) %>%
                                                                                 # remove MT ranges
                                                                                 dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                 # turn chr column into chr1 chr2 etc...
                                                                                 dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                 type_convert %>% 
                                                                                 # data frame is absolutele necessary for regioneR.
                                                                                 as.data.frame)
                                             
                                             # grange-ify 
                                             granges_items_chr_start_end <- toGRanges(tibble_psisigma_constitutive_chr_start_end[, c("chr", "start", "end")] %>% 
                                                                                        # remove MT ranges
                                                                                        dplyr::filter(chr != "MT", .preserve = TRUE) %>%
                                                                                        # turn chr column into chr1 chr2 etc...
                                                                                        dplyr::mutate_at(.vars = "chr", .funs = function(x) {paste("chr", x, sep = "")} ) %>%
                                                                                        type_convert %>% 
                                                                                        # data frame is absolutele necessary for regioneR.
                                                                                        as.data.frame)
                                             
                                             # randomise regions based on the input template0
                                             # granges_randomised_regions <- regioneR::randomizeRegions(granges_items_chr_start_end,
                                             # genome = "hg38", 
                                             # allow.overlaps = FALSE, 
                                             # per.chromosome = FALSE)
                                             
                                             # permtest_result <- overlapPermTest(A = granges_items_chr_start_end, B = granges_gwas_catalog, 
                                             #                                    ntimes = 1000, 
                                             #                                    genome = BSgenome.Hsapiens.UCSC.hg38, 
                                             #                                    # min.parallel = 8,
                                             #                                    allow.overlaps = FALSE, 
                                             #                                    per.chromosome = FALSE, 
                                             #                                    alternative = "greater", 
                                             #                                    force.parallel = FALSE, 
                                             #                                    verbose = TRUE,
                                             #                                    mc.cores = 8)
                                             
                                             permtest_result <- permTest(A = granges_PSIsigma_constitutive_VSR_transcriptome_relative_coords, 
                                                                         B = granges_gwas_catalog, 
                                                                         randomize.function = randomizeRegions,
                                                                         evaluate.function = numOverlaps,
                                                                         allow.overlaps = FALSE, 
                                                                         ntimes = 1000, 
                                                                         genome = BSgenome.Hsapiens.UCSC.hg38, 
                                                                         # min.parallel = 8,
                                                                         per.chromosome = FALSE, 
                                                                         alternative = "greater", 
                                                                         force.parallel = TRUE, 
                                                                         verbose = TRUE,
                                                                         mc.cores = 8)
                                             
                                             
                                             # plot(permtest_result)
                                             
                                             return(permtest_result %>% flatten)
                                             
                                           }, .progress = TRUE) %>% set_names(tibble_psisigma_constitutive_snps_summary_by_context %>% .$`CONTEXT`)

# tibblise into a logical 
tibble_significance_logical_test_PSIsigma_constitutive_contexts <- list_permtest_results_PSIsigma_constitutive_contexts %>% purrr::map(~.x$pval < 0.05) %>% as_tibble(.name_repair = "unique") %>% t %>% as_tibble(rownames = "CONTEXT", .name_repair = "unique") %>% setNames(c("CONTEXT", "significant_PSIsigma_constitutive"))

save(list_permtest_results_PSIsigma_constitutive_contexts, file = paste(results_dir, "list_permtest_results_PSIsigma_constitutive_contexts.Rlist", sep = ""))

```

##### combine bootstrap significance tibbles

```{r}

long_tibble_combined_significance_traits <- list(tibble_significance_logical_test_JUM_differential_traits, 
                                                 tibble_significance_logical_test_JUM_constitutive_traits, 
                                                 tibble_significance_logical_test_PSIsigma_differential_traits,
                                                 tibble_significance_logical_test_PSIsigma_constitutive_traits) %>% 
  purrr::reduce(dplyr::full_join, by = "DISEASE/TRAIT") %>%
  (function(x) {y <- x; y[is.na(y)] <- FALSE; return(y)} ) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "DISEASE/TRAIT", variable.name = "tool_diff.cons", value.name = "significant") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {gsub(x = x, pattern = "significant_", replacement = "trait_tally_")} )

long_tibble_combined_significance_contexts <- list(tibble_significance_logical_test_JUM_differential_contexts, 
                                                 tibble_significance_logical_test_JUM_constitutive_contexts, 
                                                 tibble_significance_logical_test_PSIsigma_differential_contexts,
                                                 tibble_significance_logical_test_PSIsigma_constitutive_contexts) %>% 
  purrr::reduce(dplyr::full_join, by = "CONTEXT") %>%
  (function(x) {y <- x; y[is.na(y)] <- FALSE; return(y)} ) %>%
  # melt for simultaneous plot
  reshape2::melt(id.vars = "CONTEXT", variable.name = "tool_diff.cons", value.name = "significant") %>%
  as_tibble %>%
  dplyr::mutate_at(.vars = "tool_diff.cons", .funs = function(x) {gsub(x = x, pattern = "significant_", replacement = "context_tally_")} )

```

#### combine the traits and significance tables and plot on the same graph

```{r}

long_tibble_combined_overlap_and_significance_traits <- dplyr::left_join(long_tibble_combined_overlap_traits, long_tibble_combined_significance_traits, by = c("DISEASE/TRAIT", "tool_diff.cons")) %>% dplyr::mutate_at(.vars = c("DISEASE/TRAIT", "tool_diff.cons"), .funs = as_factor) %>% (function(x) {y <- x; y$`DISEASE/TRAIT` <- factor(x = x$`DISEASE/TRAIT`, levels = long_tibble_combined_overlap_traits$`DISEASE/TRAIT` %>% levels); y$`tool_diff.cons` <- factor(x = x$`tool_diff.cons`, levels = long_tibble_combined_overlap_traits$tool_diff.cons %>% levels); return(y)} )
long_tibble_combined_overlap_and_significance_contexts <- dplyr::left_join(long_tibble_combined_overlap_contexts, long_tibble_combined_significance_contexts, by = c("CONTEXT", "tool_diff.cons")) %>% dplyr::mutate_at(.vars = c("CONTEXT", "tool_diff.cons"), .funs = as_factor) %>% (function(x) {y <- x; y$`CONTEXT` <- factor(x = x$`CONTEXT`, levels = long_tibble_combined_overlap_contexts$CONTEXT %>% levels); y$`tool_diff.cons` <- factor(x = x$`tool_diff.cons`, levels = long_tibble_combined_overlap_contexts$tool_diff.cons %>% levels); return(y)} )

# combined tally plot, traits
ggplot(data = long_tibble_combined_overlap_and_significance_traits, aes(x = `DISEASE/TRAIT`, y = tally, fill = tool_diff.cons)) +
  geom_col_pattern(position = "dodge", aes(pattern = tool_diff.cons), pattern_spacing = 0.01, pattern_density = 0.1, pattern_colour = "white", size = 0.2, colour = "black") +
  scale_pattern_discrete(name = "Data series", 
                         breaks = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                         limits = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                         labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                         choices = c("none", "stripe", "none", "stripe")) +
  scale_fill_manual(name = "Tool", 
                    breaks = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                    limits = c("trait_tally_JUM_differential", "trait_tally_JUM_constitutive", "trait_tally_PSIsigma_differential", "trait_tally_PSIsigma_constitutive"), 
                    labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                    values = c("purple3", "purple3", "firebrick4", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  geom_text(stat = "identity", aes(y = tally + 30 + ((floor(tally %>% log10) + 1) * 20), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 25)) +
  ylim(c(0, long_tibble_combined_overlap_and_significance_traits$tally %>% max * 1.2)) +
  ggtitle("Top 8 traits, JUM and PSI-Sigma, differential and constitutive") +
  ylab("# Overlapping SNPs") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_SNPs_traits_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 14, height = 16, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_SNPs_traits_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 14, height = 16, units = "cm")

# combined tally plot, contexts
ggplot(data = long_tibble_combined_overlap_and_significance_contexts, aes(x = `CONTEXT`, y = tally, fill = tool_diff.cons)) +
  geom_col_pattern(position = "dodge", aes(pattern = tool_diff.cons), pattern_spacing = 0.01, pattern_density = 0.1, pattern_colour = "white", size = 0.2, colour = "black") +
  scale_pattern_discrete(name = "Data series", 
                         breaks = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                         limits = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                         labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                         choices = c("none", "stripe", "none", "stripe")) +
  scale_fill_manual(name = "Tool", 
                    breaks = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                    limits = c("context_tally_JUM_differential", "context_tally_JUM_constitutive", "context_tally_PSIsigma_differential", "context_tally_PSIsigma_constitutive"), 
                    labels = c("JUM (differential)", "JUM (constitutive)", "PSI-Sigma (differential)", "PSI-Sigma (constitutive)"), 
                    values = c("purple3", "purple3", "firebrick4", "firebrick4")) +
  geom_text(stat = "identity", aes(label = tally), position = position_dodge(width = 1), hjust = -0.1) +
  geom_text(stat = "identity", aes(y = tally + 150 + ((floor(tally %>% log10) + 1) * 250), label = significant %>% (function(x) {y <- x; y[y == TRUE] <- "*"; y[y == FALSE] <- ""; return(y) } )) , position = position_dodge(width = 1), vjust = 0.8, size = 8, colour = "forestgreen") +
  scale_x_discrete(labels = function(x) str_wrap(x, width = 30)) +
  ylim(c(0, long_tibble_combined_overlap_and_significance_contexts$tally %>% max * 1.4)) +
  ggtitle("SNP Contexts tally, JUM and PSI-Sigma, differential and constitutive") +
  ylab("# Overlapping SNPs") +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 1, colour = "black", angle = 45), legend.title.align = 0.5, legend.background = element_rect(size = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica")) +
  ggsave(filename = paste(results_dir, "tally_SNPs_contexts_combined_JUM_PSIsigma.pdf", sep = ""), device = "pdf", dpi = 600, width = 16, height = 16, units = "cm") +
  ggsave(filename = paste(results_dir, "tally_SNPs_contexts_combined_JUM_PSIsigma.svg", sep = ""), device = "svg", dpi = 600, width = 16, height = 16, units = "cm")

stop("GWAS done")

```

### Plot distances from junc/exon boundaries to SNPs

STRATEGY: 
1. loop thru ALL SNPs
2. find nearest flanking upstream/downstream boundary, append to table.
3. compute distance which is SNP - boundary.

junc boundaries: sub_junc_coor for differential/const.
exon boundaries: all diff or all const

```{r}

# subset by chr for more efficient looping
list_JUM_junc_diff_subset_by_chr <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("AS_event_chr", "sub_junction_start_coor", "sub_junction_end_coor")] %>% dplyr::add_row("AS_event_chr" = "Y", "sub_junction_start_coor" = NA, "sub_junction_end_coor" = NA) %>% dplyr::group_split(AS_event_chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$AS_event_chr %>% unique) %>% unlist)
list_JUM_junc_const_subset_by_chr <- tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na[, c("AS_event_chr", "sub_junction_start_coor", "sub_junction_end_coor")] %>% dplyr::group_split(AS_event_chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$AS_event_chr %>% unique) %>% unlist)

list_PSIsigma_exon_diff_subset_by_chr <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na[, c("chr", "diff_exon_start", "diff_exon_end")] %>% dplyr::group_split(chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)
list_PSIsigma_exon_const_subset_by_chr <- tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na[, c("chr", "diff_exon_start", "diff_exon_end")] %>% dplyr::group_split(chr) %>% set_names(nm = purrr::map(.x = ., .f = ~.x$chr %>% unique) %>% unlist)

plan(list(tweak(multiprocess, workers = 30),
          tweak(multiprocess, workers = 4))
)

list_gwas_catalog_with_junc.exon_boundary_info <- furrr::future_pmap(
  .l = list("a1" = list_tibble_ebi_gwas_catalog_by_chr,
            "a2" = list_JUM_junc_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)],
            "a3" = list_JUM_junc_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)],
            "a4" = list_PSIsigma_exon_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)],
            "a5" = list_PSIsigma_exon_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)]),
  .f = function(a1, a2, a3, a4, a5) {
    
    # DEBUG ###
    # a1 <- list_tibble_ebi_gwas_catalog_by_chr[[1]]
    # a2 <- list_JUM_junc_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    # a3 <- list_JUM_junc_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    # a4 <- list_PSIsigma_exon_diff_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    # a5 <- list_PSIsigma_exon_const_subset_by_chr[names(list_tibble_ebi_gwas_catalog_by_chr)] %>% .[[1]]
    ###########
    
    # get all the junc/exon start/end's
        vector_sub_junc_diff_starts <- a2$sub_junction_start_coor
        vector_sub_junc_diff_ends <- a2$sub_junction_end_coor
        
        vector_sub_junc_const_starts <- a3$sub_junction_start_coor
        vector_sub_junc_const_ends <- a3$sub_junction_end_coor
        
        vector_exon_diff_starts <- a4$diff_exon_start
        vector_exon_diff_ends <- a4$diff_exon_end
        
        vector_exon_const_starts <- a5$diff_exon_start
        vector_exon_const_ends <- a5$diff_exon_end
    
    furrr::future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[1]]
        ###########
        
        # find nearest match to all junc/exon boundaries
        purrr::splice(
          b1, 
          "nearest_JUM.junc.diff_start" = vector_sub_junc_diff_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_starts)))] %>% unique,
          "nearest_JUM.junc.diff_end" = vector_sub_junc_diff_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_diff_ends)))] %>% unique,
          
          "nearest_JUM.junc.const_start" = vector_sub_junc_const_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_starts)))] %>% unique,
          "nearest_JUM.junc.const_end" = vector_sub_junc_const_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_sub_junc_const_ends)))] %>% unique,
          
          "nearest_PSIsigma.exon.diff_start" = vector_exon_diff_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_starts)))] %>% unique,
          "nearest_PSIsigma.exon.diff_end" = vector_exon_diff_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_diff_ends)))] %>% unique,
          
          "nearest_PSIsigma.exon.const_start" = vector_exon_const_starts[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_starts) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_starts)))] %>% unique,
          "nearest_PSIsigma.exon.const_end" = vector_exon_const_ends[which(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_ends) == min(abs((b1$CHR_POS %>% type.convert) - vector_exon_const_ends)))] %>% unique
        ) %>% 
          # ... and also the differences.
          # should be SNP - boundary so that the SNP distances from boundary can be read from 5' to 3'.
          purrr::splice(
            "difference_JUM.junc.diff_start" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.diff_start,
            "difference_JUM.junc.diff_end" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.diff_end,
            
            "difference_JUM.junc.const_start" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.const_start,
            "difference_JUM.junc.const_end" = (b1$CHR_POS %>% type.convert) - .$nearest_JUM.junc.const_end,
            
            "difference_PSIsigma.exon.diff_start" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.diff_start,
            "difference_PSIsigma.exon.diff_end" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.diff_end,
            
            "difference_PSIsigma.exon.const_start" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.const_start,
            "difference_PSIsigma.exon.const_end" = (b1$CHR_POS %>% type.convert) - .$nearest_PSIsigma.exon.const_end
          ) %>% 
          flatten %>%
          as_tibble %>%
          return
        
      }, .progress = TRUE ) %>% # L2
      return
    
  }, .progress = TRUE)

# rbind and tibblise
tibble_gwas_catalog_with_junc.exon_boundary_info <- list_gwas_catalog_with_junc.exon_boundary_info %>% flatten %>% rbindlist(fill = TRUE) %>% as_tibble

# plot

difference_JUM.junc.diff_start
difference_JUM.junc.diff_end
difference_JUM.junc.const_start
difference_JUM.junc.const_end
difference_PSIsigma.exon.diff_start
difference_PSIsigma.exon.diff_end
difference_PSIsigma.exon.const_start
difference_PSIsigma.exon.const_end 

vector_differences_to_plot <- tibble_gwas_catalog_with_junc.exon_boundary_info[tibble_gwas_catalog_with_junc.exon_boundary_info$`DISEASE/TRAIT` %in% levels(long_tibble_combined_overlap_traits$`DISEASE/TRAIT`), ] %>% 
  dplyr::distinct(CHR_ID, CHR_POS, .keep_all = TRUE) %>% 
  # .[grep(x = .$`INITIAL SAMPLE SIZE`, pattern = "europ", ignore.case = TRUE), ] %>% 
  .$difference_JUM.junc.diff_end %>% 
  na.omit

vector_differences_to_plot <- vector_differences_to_plot[vector_differences_to_plot < 400 & vector_differences_to_plot > -400]

plot(
  density(vector_differences_to_plot, bw = 3, freq = TRUE),
  ylab = "Frequency"
)

ggplot(tibble("vector_differences_to_plot" = vector_differences_to_plot)) +
  geom_histogram(aes(x = `vector_differences_to_plot`), binwidth = 10) 

```

### look for coordinate-level overlap between matched SNPs and CLIP-Seq sites

#### retrieve the clip-seq entries that definitively regulate VSRs.

- we first have to extract the list of tibbles describing clip-seq regions that overlapped VSRs.
- then we have to filter by targeted entries (because targets in other clusters don't count)
- then we have to find the overlap with SNPs

```{r}

# list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries

# extract the overlapping clip-seq regions
list_clip_seq_entries_overlapping_VSRs_diff <- list_overlaps_clipseq_peakfiles_x_jum_psisigma[grep(x = names(list_overlaps_clipseq_peakfiles_x_jum_psisigma), pattern = "differential.*tibble_VSRs_with_overlap_with_matched_clipseq_regions$")]
list_clip_seq_entries_overlapping_VSRs_diff <- list_clip_seq_entries_overlapping_VSRs_diff[!grepl(x = list_clip_seq_entries_overlapping_VSRs_diff %>% names, pattern = "(SRSF2 HITS-CLIP GSE111900)|(SRSF4)|(SRSF7)|(SRSF9)")]

# map together to filter by the confirmed target entries.
list_clip_seq_entries_overlapping_VSRs_diff_confirmed_binding_regions <- future_map2(
  .x = list_clip_seq_entries_overlapping_VSRs_diff,
  .y = list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries,                                      
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_clip_seq_entries_overlapping_VSRs_diff[[1]]
    # a2 <- list_JUM_PSIsigma_combined_diff_coordinate_level_clip_seq_target_entries[[1]]
    ###########
    
    tibble_filtered_clipseq_targets <- a1[a1$VSR_AS_event_ID %in% (a2$AS_event_ID %>% na.omit) | a1$VSR_event_region_coords %in% (a2$event_region_coords %>% na.omit), ]
    
    return(tibble_filtered_clipseq_targets)
    
  }, .progress = TRUE)

```

#### calculate overlap

```{r}

plan(list(tweak(multiprocess, workers = 32),
          tweak(multiprocess, workers = 4)))

# match each chr start end with the GWAS catalog
list_of_gwas_catalog_entries_overlapped_with_public_CLIP_seq_entries_differential <- future_map(
  .x = list_clip_seq_entries_overlapping_VSRs_diff_confirmed_binding_regions, 
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_clip_seq_entries_overlapping_VSRs_diff_confirmed_binding_regions[[5]]
    ###########
    
    # cat("now processing: ", .y, "\n")
    
    list_of_subset_tibbles <- future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[5]]
        ###########
        
        subset_tibble <- tibble_ebi_gwas_catalog_deduped %>% dplyr::filter(CHR_ID == b1$clipseq_chr &
                                                                     CHR_POS %>% type.convert >= b1$clipseq_start %>% type.convert - 2  &
                                                                     CHR_POS %>% type.convert <= b1$clipseq_end %>% type.convert + 2)
        
        subset_tibble <- subset_tibble %>% add_column("CLIP_start" = b1$clipseq_start %>% type.convert,
                                                      "CLIP_end" = b1$clipseq_end %>% type.convert,
                                                      "VSR_AS_event_ID" = b1$VSR_AS_event_ID,
                                                      "VSR_event_region_coords" = b1$VSR_event_region_coords)
        
        return(subset_tibble)
        
      }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "add_column", "dplyr")) )
    
    # rbind and tibblise
    
    return(list_of_subset_tibbles %>% rbindlist %>% as_tibble)
    
  }, .progress = TRUE, .options = future_options(globals = c("tibble_ebi_gwas_catalog_deduped", "dplyr", "data.table", "tibble")))

save(list_of_gwas_catalog_entries_overlapped_with_public_CLIP_seq_entries_differential, file = paste(results_dir, "list_of_gwas_catalog_entries_overlapped_with_confirmed_public_CLIP_seq_binding_sites_VSR_differential.Rlist", sep = ""))
# load(file = paste(results_dir, "list_of_gwas_catalog_entries_overlapped_with_confirmed_public_CLIP_seq_binding_sites_VSR_differential.Rlist", sep = ""))

```

## Assess whether SNPs lie in Ago2 CLIP binding sites

### Append SNP information to the Ago2 CLIP table

```{r}

# map over the Ago2 tibble and the GWAS catalog tibble by chromosome
## but first, we have to find which chromosomes the lists have in common
chr_in_common <- intersect(list_tibble_ebi_gwas_catalog_by_chr %>% names, list_ago2_iclip_binding_sites_by_chr %>% names)

tibble_ago2_iclip_binding_sites_with_SNP_info <- future_map2(
  .x = list_ago2_iclip_binding_sites_by_chr[chr_in_common],
  .y = list_tibble_ebi_gwas_catalog_by_chr[chr_in_common],
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_ago2_iclip_binding_sites_by_chr[chr_in_common][[1]]
    # a2 <- list_tibble_ebi_gwas_catalog_by_chr[chr_in_common][[1]]
    ###########
    
    list_ago2_iclip_per_element_with_snp <- future_map(
      .x = a1 %>% array_tree,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- a1 %>% array_tree %>% .[[1]]
        ###########
        
        # create NA otherwise the original iclip data will be erased upon dplyr::bind_cols
        tibble_matching_SNP_entries_na <- a2[1, ]
        tibble_matching_SNP_entries_na[1, ] <- NA
        
        # get SNP entries which fall within the binding site
        tibble_matching_SNP_entries <- a2[which(a2$CHR_POS >= b1$start %>% type.convert &
                                                  a2$CHR_POS <= b1$stop %>% type.convert), ]
        
        # dplyr join the matching SNP entries back onto the binding site entry
        if (tibble_matching_SNP_entries %>% nrow > 0) {
          tibble_binding_site_entry_with_SNP_entry <- dplyr::bind_cols(b1 %>% as_tibble, tibble_matching_SNP_entries)
        } else if (tibble_matching_SNP_entries %>% nrow == 0) {
          tibble_binding_site_entry_with_SNP_entry <- dplyr::bind_cols(b1 %>% as_tibble, tibble_matching_SNP_entries_na)
        }
        
        return(tibble_binding_site_entry_with_SNP_entry)
        
      } )
    
    return(list_ago2_iclip_per_element_with_snp)
    
  }, .progress = TRUE) %>% flatten %>% rbindlist(use.names = TRUE, fill = TRUE) %>% as_tibble


## create list of vectors of differential positions (genomic coords)
list_of_vectors_JUM_differential_exon_positions <- tibble_JUM_junction_ontology_supp_info$vector_genomic_coords_of_all_differential_exon_positions %>% 
  strsplit(split = ",")
## find matching iCLIP entries for each element
list_matched_iCLIP_entries_per_differential_region_JUM <- future_map2(.x = list_of_vectors_JUM_differential_exon_positions,
                                                                  .y = tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree,
                                                                  .f = function(a1, a2) {
                                                                    
                                                                    # DEBUG ###
                                                                    # a1 <- list_of_vectors_JUM_differential_exon_positions[[1]]
                                                                    # a2 <- tibble_JUM_junction_ontology_supp_info[, c("AS_event_ID", "splicemode", "Gene")] %>% array_tree %>% .[[1]]
                                                                    ###########
                                                                    
                                                                    # get chromosome
                                                                    current_chr <- gsub(x = a2$AS_event_ID, pattern = "^([^\\_]+)\\_.*", replacement = "\\1")
                                                                    
                                                                    # intersect each entry of the iCLIP list to see which ones are overlapped.
                                                                    vector_logical_iclip_binding_site_overlaps_differential_region <- list_of_vectors_iclip_binding_site_genome_coords[[current_chr]] %>% future_map(.f = ~intersect(a1 %>% type.convert, .x %>% type.convert) %>% length > 0) %>% unlist
                                                                    
                                                                    # retrieve iCLIP entries based on logical index
                                                                    tibble_matched_iclip_entries <- list_ago2_iclip_binding_sites_by_chr[[current_chr]][which(vector_logical_iclip_binding_site_overlaps_differential_region == TRUE), ]
                                                                    
                                                                    return(purrr::splice(a2,
                                                                                         "tibble_matched_iclip_entries" = tibble_matched_iclip_entries %>% list))
                                                                  }, .progress = TRUE)

# prune elements with no match to the iclip dataset
list_matched_iCLIP_entries_per_differential_region_JUM_pruned <- list_matched_iCLIP_entries_per_differential_region_JUM %>% purrr::discard(.p = ~.x$tibble_matched_iclip_entries %>% nrow == 0)

# percolate and tibblise
tibble_differential_region_JUM_with_iclip_ago2 <- list_matched_iCLIP_entries_per_differential_region_JUM_pruned %>% purrr::map(~dplyr::bind_cols(.x[c("AS_event_ID", "splicemode", "Gene")], .x$tibble_matched_iclip_entries)) %>% rbindlist(use.names = TRUE) %>% as_tibble

```

```{r}

stop("SNP section done")

```

# Bulk JUM, PSI-Sigma and scRNA-Seq Sierra !!! WARNING: TEMPORARILY ON HOLD !!!

## Find extent of genes with differential AS in common between Sierra and JUM/PSI-Sigma

```{r}

vector_sierra_genes_clusterwise <- tibble_sierra_DTU_clusterwise_all_simplified$gene_name %>% unique %>% mixedsort %>% na.omit

vector_JUM_diff_genes <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na$Gene %>% unique %>% mixedsort %>% na.omit

vector_PSIsigma_diff_genes <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na$matched_gene_names %>% unique %>% mixedsort %>% na.omit

cat("\nSierra total DS genes: ", vector_sierra_genes_clusterwise %>% length)
cat("\nJUM total DS genes: ", vector_JUM_diff_genes %>% length)
cat("\nPSI-Sigma total DS genes: ", vector_PSIsigma_diff_genes %>% length)

cat("\nSierra and JUM DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_JUM_diff_genes) %>% length)
cat("\nSierra and PSI-Sigma DS genes overlap: ", intersect(vector_sierra_genes_clusterwise, vector_PSIsigma_diff_genes) %>% length)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_JUM_diff_genes),
  category.names = c("Sierra" , "JUM"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_JUM.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "mediumorchid4")
)

venn.diagram(
  x = list(vector_sierra_genes_clusterwise, 
           vector_PSIsigma_diff_genes),
  category.names = c("Sierra" , "PSI-Sigma"),
  imagetype = "png",
  filename = paste(results_dir, "venndiagram_DS_genes_overlap_sierra_vs_PSIsigma.png", sep = ""),
  output = TRUE,
  # circles
  lty = 'blank',
  fill = c("goldenrod3", "brown4")
)

```

## Find the extent of overlap between the Sierra differential peaks and JUM/PSI-Sigma

```{r}

# list-ify the JUM contributing junctions using array_tree then unpack using strsplit
list_JUM_diff_junctions_array.tree <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na[, c("contributing_junction_IDs", "chr", "start", "end", "strand")] %>% 
  array_tree %>% 
  purrr::map_depth(.depth = 2, .f = ~strsplit(.x, split = ";")) %>%
  purrr::map(~.x %>% flatten %>% as_tibble)

# match to Sierra's differential junctions

```

# ONT long read analysis

## Import files

```{r}

sapply(list.files("/mnt/LTS/tools/angel_suite/source/", pattern = "\\.R", full.names = TRUE), source)

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na <- read.delim("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_PSIsigma/results/run_1.9g_in_parallel_with_denominator_sorted_GTF/R_processing_results/long_tibble_of_psisigma_results_allcomparisons_differential_info_LIV1854_dpsi15_DEXSeq_padj0.01_anysig_with_na.txt", sep = "\t", row.names = NULL, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE) %>% as_tibble

# tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na
# 
# tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na
# tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na
# 
# tibble_majiq_differential_with_na
# tibble_majiq_constitutive

list_2023_hmsc_ob_ont_gtf <- furrr::future_map2(
  .x = list.files("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_NMD_classifier/results/", pattern = "2023\\_hmsc\\_ob\\_ont\\_barcode0.\\_NMD\\_PTC\\_E4\\.gtf", full.names = TRUE),
  .y = c("MSC", "6h", "1d", "3d", "9d", "12d"),
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list.files("/mnt/LTS/projects/2019_hmsc_spliceome/Kassem_OB/analysis_NMD_classifier/results/", pattern = "2023\\_hmsc\\_ob\\_ont\\_barcode0.\\_NMD\\_PTC\\_E4\\.gtf", full.names = TRUE) %>% .[[1]]
    # a2 <- "MSC"
    ###########
    
    tibble_gtf <- rtracklayer::import(con = a1) %>% tibble::as_tibble() %>% dplyr::mutate_if(is.factor, as.character) %>% dplyr::mutate("timepoint" = a2) %>% readr::type_convert()
    
  }, .progress = TRUE ) 

tibble_2023_hmsc_ob_ont_gtf <- list_2023_hmsc_ob_ont_gtf %>% data.table::rbindlist(use.names = TRUE) %>% tibble::as_tibble() %>% dplyr::rename("transcript_id_original" = "transcript_id") %>% dplyr::mutate("transcript_id" = paste(transcript_id_original, "|", timepoint, sep = ""), .after = "transcript_id_original")

```

## Match/filter DS events with the ONT data

### match psi-sigma differential events to ONT

```{r}

listified_tibble <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% dplyr::distinct(chr, alternative_exon_starts, alternative_exon_ends, .keep_all = TRUE) %>% dplyr::rowwise() %>% dplyr::group_split()

list_psisigma_differential_with_na_matched_to_ont <- round_robin_pmap_callr(
  .l = list(
    "a1" = listified_tibble,
    "a2" = 1:length(listified_tibble)
  ), 
  .num_workers = 16,
  .no_chunks = 99,
  .f = function(a1, a2) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    # DEBUG ###
    # a1 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[2]]
    ###########
    
    cat(a2, "\n")
    
    # print("ls")
    # print(ls(envir = .GlobalEnv))
    # 
    # print("frame")
    # print(sys.nframe())
    # 
    # for (tempframe in 0:sys.nframe()) {
    #   print(tempframe)
    #   print(sys.function(which = tempframe))
    #   
    #   print("variables in frame:")
    #   print(ls(envir = sys.frame(which = tempframe)))
    # }
    
    if (a1$splicemode %>% grepl(pattern = "IR")) {
      
      # match the junction
      list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$diff_exon_start, a1$diff_exon_end)), query_end = max(c(a1$diff_exon_start, a1$diff_exon_end)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
      
      list_matched_ont_exclusion_transcript_entries <- purrr::map(.x = names(list_matched_ont_junction_entries), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
        purrr::set_names(nm = names(list_matched_ont_junction_entries))
      
      if (length(list_matched_ont_junction_entries) > 0) {
        
        # if junction match exists, then find all transcripts with completely overlapping exon
        list_matched_ont_exon_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(a1$diff_exon_start, a1$diff_exon_end)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(a1$diff_exon_start, a1$diff_exon_end)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% 
          dplyr::group_by(transcript_id) %>% 
          dplyr::group_split() %>% 
          purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
        
        list_matched_ont_transcript_entries <- purrr::map(.x = names(list_matched_ont_exon_entries), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
          purrr::set_names(nm = names(list_matched_ont_exon_entries))
        
        list_L1_result <- list(
          "splicing_data" = a1,
          "list_matched_ont_inclusion_entries" = list_matched_ont_exon_entries,
          "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_transcript_entries,
          "list_matched_ont_exclusion_entries" = list_matched_ont_junction_entries,
          "list_matched_ont_exclusion_transcript_entries" = list_matched_ont_exclusion_transcript_entries
        )
        
      } else {
        list_L1_result <- list(
          "splicing_data" = a1,
          "list_matched_ont_inclusion_entries" = list(),
          "list_matched_ont_inclusion_transcript_entries" = list(),
          "list_matched_ont_exclusion_entries" = list(),
          "list_matched_ont_exclusion_transcript_entries" = list()
        )
      }
      
    } else if (a1$splicemode %>% grepl(pattern = "A.SS")) {
      
      # match event region
      list_matched_event_region <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$event_region_start, a1$event_region_end)), query_end = max(c(a1$event_region_start, a1$event_region_end)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
      
      list_matched_ont_exclusion_transcript_entries <- purrr::map(.x = names(list_matched_event_region), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
        purrr::set_names(nm = names(list_matched_event_region))
      
      # match alternative bit
      # ENHANCED EXON EXTENSION MATCHING
      # Strategy: 
      # 1. Determine the common VSR and exon coord.
      # 2. Calculate the genomic coord of the DR + 1 nucleotide.
      # This is done using the equation: genome_coord_first_nucleotide_extending_into_common_region = common + (common_coord-VSR_only_coord)/(abs(common_coord-VSR_only_coord))
      # 3. Find the CONSTITUTIVE (native, non-extended) exon by requiring no overlap with the DR but has either the start or end coord = the DR + 1 nucleotide.
      # 4. The exonic matches are any exon which overlaps the region of the constitutive span AND contains the WHOLE DR on the same strand.
      common_coord <- intersect(c(a1$event_region_start %>% type.convert(as.is = TRUE), a1$event_region_end %>% type.convert(as.is = TRUE)), 
                                c(a1$diff_exon_start %>% type.convert(as.is = TRUE), a1$diff_exon_end %>% type.convert(as.is = TRUE)))
      event_region_only_coord <- setdiff(c(a1$event_region_start %>% type.convert(as.is = TRUE), a1$event_region_end %>% type.convert(as.is = TRUE)), common_coord)
      exon_only_coord <- setdiff(c(a1$diff_exon_start %>% type.convert(as.is = TRUE), a1$diff_exon_end %>% type.convert(as.is = TRUE)), common_coord)
      genome_coord_second_nucleotide_extending_into_junction = exon_only_coord - 2*((common_coord - event_region_only_coord)/(abs(common_coord - event_region_only_coord)))
      genome_coord_second_nucleotide_extending_into_common_region = common_coord + 2*((common_coord - event_region_only_coord)/(abs(common_coord - event_region_only_coord)))
      
      tibble_GTF_exons_with_DR_extended_into_junction <- extract_overlapping_features(query_chr = a1$chr, query_start = min(c(common_coord, genome_coord_second_nucleotide_extending_into_junction)), query_end = max(c(common_coord, genome_coord_second_nucleotide_extending_into_junction)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 0, right_tolerance = 0, return_type = "exon", complete_overlap = TRUE)
      
      tibble_GTF_exons_with_DR_extended_into_constitutive_region <- extract_overlapping_features(query_chr = a1$chr, query_start = min(c(exon_only_coord, genome_coord_second_nucleotide_extending_into_common_region)), query_end = max(c(exon_only_coord, genome_coord_second_nucleotide_extending_into_common_region)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, return_type = "exon", complete_overlap = TRUE)
      
      list_matched_ont_exon_entries <- dplyr::anti_join(tibble_GTF_exons_with_DR_extended_into_constitutive_region, tibble_GTF_exons_with_DR_extended_into_junction, by = c("transcript_id", "timepoint")) %>% 
        dplyr::group_by(transcript_id) %>% 
        dplyr::group_split() %>% 
        purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
      
      list_matched_ont_transcript_entries <- purrr::map(.x = names(list_matched_ont_exon_entries), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
        purrr::set_names(nm = names(list_matched_ont_exon_entries))
      
      list_L1_result <- list(
        "splicing_data" = a1,
        "list_matched_ont_inclusion_entries" = list_matched_ont_exon_entries,
        "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_transcript_entries,
        "list_matched_ont_exclusion_entries" = list_matched_event_region,
        "list_matched_ont_exclusion_transcript_entries" = list_matched_ont_exclusion_transcript_entries
      )
      
    } else {
      
      list_matched_event_region <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$event_region_start, a1$event_region_end)), query_end = max(c(a1$event_region_start, a1$event_region_end)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
      
      list_matched_ont_exclusion_transcript_entries <- purrr::map(.x = names(list_matched_event_region), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
        purrr::set_names(nm = names(list_matched_event_region))
      
      list_matched_ont_exon_entries <- purrr::map2(
        .x = a1$alternative_exon_starts %>% strsplit(split = ";") %>% unlist,
        .y = a1$alternative_exon_ends %>% strsplit(split = ";") %>% unlist, 
        .f = ~extract_matching.exons(query_chr = a1$chr, query_start = min(c(.x, .y)), query_end = max(c(.x, .y)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, return_type = "exon"))
      
      # to account for multiple matches from MES exons, we need to find the transcripts with all matching exons.
      tibble_transcripts_with_all_matched_exons <- list_matched_ont_exon_entries %>% purrr::map(~.x[, c("transcript_id", "timepoint")]) %>% purrr::reduce(dplyr::inner_join, by = c("transcript_id", "timepoint"))
      
      # filter matched exon entries by transcripts containing all exons
      list_matched_ont_exon_entries_filtered_by_correct_transcripts <- list_matched_ont_exon_entries %>% purrr::map(~dplyr::inner_join(.x, tibble_transcripts_with_all_matched_exons, by = c("transcript_id", "timepoint"))) %>% 
        data.table::rbindlist() %>%
        tibble::as_tibble() %>%
        dplyr::group_by(transcript_id) %>% 
        dplyr::group_split() %>% 
        purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
      
      list_matched_ont_transcript_entries <- purrr::map(.x = names(list_matched_ont_exon_entries_filtered_by_correct_transcripts), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
        purrr::set_names(nm = names(list_matched_ont_exon_entries_filtered_by_correct_transcripts))
      
      list_L1_result <- list(
        "splicing_data" = a1,
        "list_matched_ont_inclusion_entries" = list_matched_ont_exon_entries_filtered_by_correct_transcripts,
        "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_transcript_entries,
        "list_matched_ont_exclusion_entries" = list_matched_event_region,
        "list_matched_ont_exclusion_transcript_entries" = list_matched_ont_exclusion_transcript_entries
      )
      
    }
    
    return(list_L1_result)
    
  } )

qs::qsave(x = list_psisigma_differential_with_na_matched_to_ont, file = paste(results_dir, "list_psisigma_differential_with_na_matched_to_ont.qs", sep = ""))

list_psisigma_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_differential_with_na_matched_to_ont.rds", sep = ""))

```

### match psi-sigma constitutive events to ONT

```{r}

listified_tibble <- tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na %>% dplyr::distinct(chr, alternative_exon_starts, alternative_exon_ends, .keep_all = TRUE) %>% dplyr::rowwise() %>% dplyr::group_split()

list_psisigma_constitutive_matched_to_ont <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/PEF_2019_multiomic_synthesis_list_psisigma_constitutive_matched_to_ont.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_2023_hmsc_ob_ont_gtf"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "PEF_2019_multiomic_synthesis_list_psisigma_constitutive_matched_to_ont",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    list_L0_result <- purrr::imap(
      .x = `_a1`,
      .f = function(a1, a2) {
        
        # DEBUG ###
        # a1 <- tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[3]]
        ###########
        
        cat(a2, "\n")
        
        if (a1$splicemode %>% grepl(pattern = "IR")) {
          
          # match the junction
          list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$diff_exon_start, a1$diff_exon_end)), query_end = max(c(a1$diff_exon_start, a1$diff_exon_end)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          if (length(list_matched_ont_junction_entries) > 0) {
            
            # if junction match exists, then find all transcripts with completely overlapping exon
            list_matched_ont_exon_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(a1$diff_exon_start, a1$diff_exon_end)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(a1$diff_exon_start, a1$diff_exon_end)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% 
              dplyr::group_by(transcript_id) %>% 
              dplyr::group_split() %>% 
              purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            
            list_matched_ont_transcript_entries <- purrr::map(.x = names(list_matched_ont_exon_entries), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
              purrr::set_names(nm = names(list_matched_ont_exon_entries))
            
            list_L1_result <- list(
              "splicing_data" = a1,
              "list_matched_ont_inclusion_entries" = list_matched_ont_exon_entries,
              "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_transcript_entries,
              "list_matched_ont_exclusion_entries" = list_matched_ont_junction_entries
            )
            
          } else {
            list_L1_result <- list(
              "splicing_data" = a1,
              "list_matched_ont_inclusion_entries" = list(),
              "list_matched_ont_inclusion_transcript_entries" = list(),
              "list_matched_ont_exclusion_entries" = list()
            )
          }
          
        } else if (a1$splicemode %>% grepl(pattern = "A.SS")) {
          
          # match event region
          list_matched_event_region <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$event_region_start, a1$event_region_end)), query_end = max(c(a1$event_region_start, a1$event_region_end)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          # match alternative bit
          # ENHANCED EXON EXTENSION MATCHING
          # Strategy: 
          # 1. Determine the common VSR and exon coord.
          # 2. Calculate the genomic coord of the DR + 1 nucleotide.
          # This is done using the equation: genome_coord_first_nucleotide_extending_into_common_region = common + (common_coord-VSR_only_coord)/(abs(common_coord-VSR_only_coord))
          # 3. Find the CONSTITUTIVE (native, non-extended) exon by requiring no overlap with the DR but has either the start or end coord = the DR + 1 nucleotide.
          # 4. The exonic matches are any exon which overlaps the region of the constitutive span AND contains the WHOLE DR on the same strand.
          common_coord <- intersect(c(a1$event_region_start %>% type.convert(as.is = TRUE), a1$event_region_end %>% type.convert(as.is = TRUE)), 
                                    c(a1$diff_exon_start %>% type.convert(as.is = TRUE), a1$diff_exon_end %>% type.convert(as.is = TRUE)))
          event_region_only_coord <- setdiff(c(a1$event_region_start %>% type.convert(as.is = TRUE), a1$event_region_end %>% type.convert(as.is = TRUE)), common_coord)
          exon_only_coord <- setdiff(c(a1$diff_exon_start %>% type.convert(as.is = TRUE), a1$diff_exon_end %>% type.convert(as.is = TRUE)), common_coord)
          genome_coord_second_nucleotide_extending_into_junction = exon_only_coord - 2*((common_coord - event_region_only_coord)/(abs(common_coord - event_region_only_coord)))
          genome_coord_second_nucleotide_extending_into_common_region = common_coord + 2*((common_coord - event_region_only_coord)/(abs(common_coord - event_region_only_coord)))
          
          tibble_GTF_exons_with_DR_extended_into_junction <- extract_overlapping_features(query_chr = a1$chr, query_start = min(c(common_coord, genome_coord_second_nucleotide_extending_into_junction)), query_end = max(c(common_coord, genome_coord_second_nucleotide_extending_into_junction)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 0, right_tolerance = 0, return_type = "exon", complete_overlap = TRUE)
          
          tibble_GTF_exons_with_DR_extended_into_constitutive_region <- extract_overlapping_features(query_chr = a1$chr, query_start = min(c(exon_only_coord, genome_coord_second_nucleotide_extending_into_common_region)), query_end = max(c(exon_only_coord, genome_coord_second_nucleotide_extending_into_common_region)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, return_type = "exon", complete_overlap = TRUE)
          
          list_matched_ont_exon_entries <- dplyr::anti_join(tibble_GTF_exons_with_DR_extended_into_constitutive_region, tibble_GTF_exons_with_DR_extended_into_junction, by = c("transcript_id", "timepoint")) %>% 
            dplyr::group_by(transcript_id) %>% 
            dplyr::group_split() %>% 
            purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          
          list_matched_ont_transcript_entries <- purrr::map(.x = names(list_matched_ont_exon_entries), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
            purrr::set_names(nm = names(list_matched_ont_exon_entries))
          
          list_L1_result <- list(
            "splicing_data" = a1,
            "list_matched_ont_inclusion_entries" = list_matched_ont_exon_entries,
            "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_transcript_entries,
            "list_matched_ont_exclusion_entries" = list_matched_event_region
          )
          
        } else {
          
          list_matched_event_region <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$event_region_start, a1$event_region_end)), query_end = max(c(a1$event_region_start, a1$event_region_end)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_exon_entries <- purrr::map2(
            .x = a1$alternative_exon_starts %>% strsplit(split = ";") %>% unlist,
            .y = a1$alternative_exon_ends %>% strsplit(split = ";") %>% unlist, 
            .f = ~extract_matching.exons(query_chr = a1$chr, query_start = min(c(.x, .y)), query_end = max(c(.x, .y)), query_strand = a1$matched_strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, return_type = "exon"))
          
          # to account for multiple matches from MES exons, we need to find the transcripts with all matching exons.
          tibble_transcripts_with_all_matched_exons <- list_matched_ont_exon_entries %>% purrr::map(~.x[, c("transcript_id", "timepoint")]) %>% purrr::reduce(dplyr::inner_join, by = c("transcript_id", "timepoint"))
          
          # filter matched exon entries by transcripts containing all exons
          list_matched_ont_exon_entries_filtered_by_correct_transcripts <- list_matched_ont_exon_entries %>% purrr::map(~dplyr::inner_join(.x, tibble_transcripts_with_all_matched_exons, by = c("transcript_id", "timepoint"))) %>% 
            data.table::rbindlist() %>%
            tibble::as_tibble() %>%
            dplyr::group_by(transcript_id) %>% 
            dplyr::group_split() %>% 
            purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          
          list_matched_ont_transcript_entries <- purrr::map(.x = names(list_matched_ont_exon_entries_filtered_by_correct_transcripts), .f = ~tibble_2023_hmsc_ob_ont_gtf[tibble_2023_hmsc_ob_ont_gtf$transcript_id == .x, ] ) %>% 
            purrr::set_names(nm = names(list_matched_ont_exon_entries_filtered_by_correct_transcripts))
          
          list_L1_result <- list(
            "splicing_data" = a1,
            "list_matched_ont_inclusion_entries" = list_matched_ont_exon_entries_filtered_by_correct_transcripts,
            "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_transcript_entries,
            "list_matched_ont_exclusion_entries" = list_matched_event_region
          )
          
        }
        
        return(list_L1_result)
        
      } )
    
    return(list_L0_result)
    
  } ) %>% purrr::flatten()

saveRDS(object = list_psisigma_constitutive_matched_to_ont, file = paste(results_dir, "list_psisigma_constitutive_matched_to_ont.rds", sep = ""))

```

### match jum differential events to ONT

```{r}

listified_tibble <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::distinct(AS_event_ID, splicemode, AS_event_chr, sub_junction_start_coor, sub_junction_end_coor, .keep_all = TRUE) %>% dplyr::rowwise() %>% dplyr::group_split()

list_jum_differential_with_na_matched_to_ont <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 96), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 96,
  .temp_path = "/mnt/scratch/temp/PEF_2019_multiomic_synthesis_list_jum_differential_with_na_matched_to_ont.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_2023_hmsc_ob_ont_gtf"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "PEF_2019_multiomic_synthesis_list_jum_differential_with_na_matched_to_ont",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    list_result <- purrr::map2(
      .x = `_a1`,
      .y = 1:length(`_a1`),
      .f = function(a1, a2) {
        
        # DEBUG ###
        # a1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[1]]
        # a1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[14]]
        ###########
        
        if (a1$splicemode == "intron_retention") {
          
          list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = min(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_end = max(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          if (length(list_matched_ont_junction_entries) > 0) {
            
            # if junction match exists, then find all transcripts with completely overlapping exon
            list_matched_ont_inclusion_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% dplyr::group_by(transcript_id) %>% dplyr::group_split() %>% purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            
            list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)) & (tibble_2023_hmsc_ob_ont_gtf$type == "transcript"), ]
            
          } else {
            list_matched_ont_inclusion_entries <- list()
            list_matched_ont_inclusion_transcript_entries <- list()
          }
          
        } else if (a1$splicemode == "cassette_exon_events") {
          
          list_matched_ont_inclusion_entries_left_junc <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\1") %>% type.convert(as.is = TRUE), query_end = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\2") %>% type.convert(as.is = TRUE), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_inclusion_entries_right_junc <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\3") %>% type.convert(as.is = TRUE), query_end = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\4") %>% type.convert(as.is = TRUE), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          vector_common_transcript_id <- intersect(names(list_matched_ont_inclusion_entries_left_junc), names(list_matched_ont_inclusion_entries_right_junc))
          
          if (length(vector_common_transcript_id) > 0) {
            
            tibble_matched_ont_inclusion_entries_left_junc <- list_matched_ont_inclusion_entries_left_junc[vector_common_transcript_id] %>% dplyr::bind_rows()
          tibble_matched_ont_inclusion_entries_right_junc <- list_matched_ont_inclusion_entries_right_junc[vector_common_transcript_id] %>% dplyr::bind_rows()
          
          list_matched_ont_inclusion_entries <- dplyr::inner_join(
            tibble_matched_ont_inclusion_entries_left_junc,
            tibble_matched_ont_inclusion_entries_right_junc,
            by = intersect(colnames(tibble_matched_ont_inclusion_entries_left_junc), colnames(tibble_matched_ont_inclusion_entries_right_junc))
          ) %>% 
            dplyr::group_by(transcript_id) %>% 
            dplyr::group_split() %>% 
            purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          
          list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
            
          } else {
            list_matched_ont_inclusion_entries <- list()
            list_matched_ont_inclusion_transcript_entries <- list()
          }
          
        } else {
          
          list_matched_ont_inclusion_entries <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = min(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_end = max(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
          
        }
        
        list_L1_result <- list(
          "splicing_data" = a1,
          "list_matched_ont_inclusion_entries" = list_matched_ont_inclusion_entries,
          "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_inclusion_transcript_entries
        )
        
        return(list_L1_result)
        
      } )
    
    return(list_result)
    
  } ) %>% purrr::flatten()

saveRDS(object = list_jum_differential_with_na_matched_to_ont, file = paste(results_dir, "list_jum_differential_with_na_matched_to_ont.rds", sep = ""))

list_jum_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_differential_with_na_matched_to_ont.rds", sep = ""))

```

### match jum constitutive events to ONT

```{r}

listified_tibble <- tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na %>% dplyr::distinct(AS_event_ID, splicemode, AS_event_chr, sub_junction_start_coor, sub_junction_end_coor, .keep_all = TRUE) %>% dplyr::rowwise() %>% dplyr::group_split()

list_jum_constitutive_no_na_matched_to_ont <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/PEF_2019_multiomic_synthesis_list_jum_constitutive_no_na_matched_to_ont.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_2023_hmsc_ob_ont_gtf"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "PEF_2019_multiomic_synthesis_list_jum_constitutive_no_na_matched_to_ont",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    list_result <- purrr::map2(
      .x = `_a1`,
      .y = 1:length(`_a1`),
      .f = function(a1, a2) {
        
        # DEBUG ###
        # a1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[1]]
        # a1 <- tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[14]]
        ###########
        
        if (a1$splicemode == "intron_retention") {
          
          list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = min(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_end = max(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          if (length(list_matched_ont_junction_entries) > 0) {
            
            # if junction match exists, then find all transcripts with completely overlapping exon
            list_matched_ont_inclusion_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% dplyr::group_by(transcript_id) %>% dplyr::group_split() %>% purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            
            list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)) & (tibble_2023_hmsc_ob_ont_gtf$type == "transcript"), ]
            
          } else {
            list_matched_ont_inclusion_entries <- list()
            list_matched_ont_inclusion_transcript_entries <- list()
          }
          
        } else if (a1$splicemode == "cassette_exon_events") {
          
          list_matched_ont_inclusion_entries_left_junc <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\1") %>% type.convert(as.is = TRUE), query_end = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\2") %>% type.convert(as.is = TRUE), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_inclusion_entries_right_junc <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\3") %>% type.convert(as.is = TRUE), query_end = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_.\\_(\\d+)\\_(\\d+)\\_(\\d+)\\_(\\d+)", replacement = "\\4") %>% type.convert(as.is = TRUE), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          vector_common_transcript_id <- intersect(names(list_matched_ont_inclusion_entries_left_junc), names(list_matched_ont_inclusion_entries_right_junc))
          
          if (length(vector_common_transcript_id) > 0) {
            
            tibble_matched_ont_inclusion_entries_left_junc <- list_matched_ont_inclusion_entries_left_junc[vector_common_transcript_id] %>% dplyr::bind_rows()
          tibble_matched_ont_inclusion_entries_right_junc <- list_matched_ont_inclusion_entries_right_junc[vector_common_transcript_id] %>% dplyr::bind_rows()
          
          list_matched_ont_inclusion_entries <- dplyr::inner_join(
            tibble_matched_ont_inclusion_entries_left_junc,
            tibble_matched_ont_inclusion_entries_right_junc,
            by = intersect(colnames(tibble_matched_ont_inclusion_entries_left_junc), colnames(tibble_matched_ont_inclusion_entries_right_junc))
          ) %>% 
            dplyr::group_by(transcript_id) %>% 
            dplyr::group_split() %>% 
            purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
          
          list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
            
          } else {
            list_matched_ont_inclusion_entries <- list()
            list_matched_ont_inclusion_transcript_entries <- list()
          }
          
        } else {
          
          list_matched_ont_inclusion_entries <- extract_junction.flanking.exons(query_chr = a1$AS_event_chr, query_start = min(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_end = max(c(a1$sub_junction_start_coor, a1$sub_junction_end_coor)), query_strand = a1$AS_event_ID %>% gsub(pattern = "^[^\\_]+\\_(.)\\_.*", replacement = "\\1"), tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
          
        }
        
        list_L1_result <- list(
          "splicing_data" = a1,
          "list_matched_ont_inclusion_entries" = list_matched_ont_inclusion_entries,
          "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_inclusion_transcript_entries
        )
        
        return(list_L1_result)
        
      } )
    
    return(list_result)
    
  } ) %>% purrr::flatten()

saveRDS(object = list_jum_constitutive_no_na_matched_to_ont, file = paste(results_dir, "list_jum_constitutive_no_na_matched_to_ont.rds", sep = ""))

```

### match majiq differential events to ONT

```{r}

listified_tibble <- tibble_majiq_differential_with_na %>% dplyr::distinct(`LSV ID`, chr, junc_IR_coords, junc_or_IR, .keep_all = TRUE) %>% dplyr::rowwise() %>% dplyr::group_split()

list_majiq_differential_with_na_matched_to_ont <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/PEF_2019_multiomic_synthesis_list_majiq_differential_with_na_matched_to_ont.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_2023_hmsc_ob_ont_gtf", "tibble_majiq_all_lsvs_with_na"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "PEF_2019_multiomic_synthesis_list_majiq_differential_with_na_matched_to_ont",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    list_result <- purrr::map2(
      .x = `_a1`,
      .y = 1:length(`_a1`),
      .f = function(a1, a2) {
        
        # DEBUG ###
        # a1 <- tibble_majiq_differential_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[1]]
        # a1 <- tibble_majiq_differential_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[14]]
        ###########
        
        if (a1$junc_or_IR == "junc") {
          
          list_matched_ont_inclusion_entries <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_end = max(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_strand = a1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
          
        } else if (a1$junc_or_IR == "IR") {
          
          list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_end = max(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_strand = a1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          if (length(list_matched_ont_junction_entries) > 0) {
            
            # if junction match exists, then find all transcripts with completely overlapping exon
            list_matched_ont_inclusion_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% dplyr::group_by(transcript_id) %>% dplyr::group_split() %>% purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            
            list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)) & (tibble_2023_hmsc_ob_ont_gtf$type == "transcript"), ]
            
          } else {
            list_matched_ont_inclusion_entries <- list()
            list_matched_ont_inclusion_transcript_entries <- list()
          }
          
        }
        
        # DEAL WITH EXCLUSION ENTRIES
        
        ## fetch the other remaining members of the LSV
        tibble_exclusion_entries <- tibble_majiq_all_lsvs_with_na[tibble_majiq_all_lsvs_with_na$lsv_id == a1$`LSV ID`, ] %>% dplyr::anti_join(., a1, by = c("junc_IR_coords", "junc_or_IR"))
        
        ## same matching process
        list_matched_ont_exclusion_entries <- purrr::map(
          .x = tibble_exclusion_entries %>% dplyr::rowwise() %>% dplyr::group_split(),
          .f = function(b1) {
            
            if (b1$junc_or_IR == "junc") {
              
              list_matched_ont_inclusion_entries <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = min(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_end = max(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_strand = b1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
              
              list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
              
            } else if (b1$junc_or_IR == "IR") {
              
              list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = min(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_end = max(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_strand = b1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
              
              if (length(list_matched_ont_junction_entries) > 0) {
                
                # if junction match exists, then find all transcripts with completely overlapping exon
                list_matched_ont_inclusion_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% dplyr::group_by(transcript_id) %>% dplyr::group_split() %>% purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
                
                list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)) & (tibble_2023_hmsc_ob_ont_gtf$type == "transcript"), ]
                
              } else {
                list_matched_ont_inclusion_entries <- list()
                list_matched_ont_inclusion_transcript_entries <- list()
              }
              
            }
            
          } )
        
        list_L1_result <- list(
          "splicing_data" = a1,
          "list_matched_ont_inclusion_entries" = list_matched_ont_inclusion_entries,
          "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_inclusion_transcript_entries,
          "list_matched_ont_exclusion_entries" = list_matched_ont_exclusion_entries
        )
        
        return(list_L1_result)
        
      } )
    
    return(list_result)
    
  } ) %>% purrr::flatten()

saveRDS(object = list_majiq_differential_with_na_matched_to_ont, file = paste(results_dir, "list_majiq_differential_with_na_matched_to_ont.rds", sep = ""))

```

### match majiq constitutive events to ONT

```{r}

listified_tibble <- tibble_majiq_constitutive %>% dplyr::distinct(`LSV ID`, chr, junc_IR_coords, junc_or_IR, .keep_all = TRUE) %>% dplyr::rowwise() %>% dplyr::group_split()

list_majiq_constitutive_matched_to_ont <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/PEF_2019_multiomic_synthesis_list_majiq_constitutive_matched_to_ont.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_2023_hmsc_ob_ont_gtf", "tibble_majiq_all_lsvs_with_na"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "PEF_2019_multiomic_synthesis_list_majiq_constitutive_matched_to_ont",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    list_result <- purrr::map2(
      .x = `_a1`,
      .y = 1:length(`_a1`),
      .f = function(a1, a2) {
        
        # DEBUG ###
        # a1 <- tibble_majiq_differential_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[1]]
        # a1 <- tibble_majiq_differential_with_na %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[14]]
        ###########
        
        if (a1$junc_or_IR == "junc") {
          
          list_matched_ont_inclusion_entries <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_end = max(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_strand = a1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
          
        } else if (a1$junc_or_IR == "IR") {
          
          list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = a1$chr, query_start = min(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_end = max(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)), query_strand = a1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
          
          if (length(list_matched_ont_junction_entries) > 0) {
            
            # if junction match exists, then find all transcripts with completely overlapping exon
            list_matched_ont_inclusion_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(a1$junc_IR_coords_start, a1$junc_IR_coords_end)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% dplyr::group_by(transcript_id) %>% dplyr::group_split() %>% purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
            
            list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)) & (tibble_2023_hmsc_ob_ont_gtf$type == "transcript"), ]
            
          } else {
            list_matched_ont_inclusion_entries <- list()
            list_matched_ont_inclusion_transcript_entries <- list()
          }
          
        }
        
        # DEAL WITH EXCLUSION ENTRIES
        
        ## fetch the other remaining members of the LSV
        tibble_exclusion_entries <- tibble_majiq_all_lsvs_with_na[tibble_majiq_all_lsvs_with_na$lsv_id == a1$`LSV ID`, ] %>% dplyr::anti_join(., a1, by = c("junc_IR_coords", "junc_or_IR"))
        
        ## same matching process
        list_matched_ont_exclusion_entries <- purrr::map(
          .x = tibble_exclusion_entries %>% dplyr::rowwise() %>% dplyr::group_split(),
          .f = function(b1) {
            
            if (b1$junc_or_IR == "junc") {
              
              list_matched_ont_inclusion_entries <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = min(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_end = max(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_strand = b1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
              
              list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)), ]
              
            } else if (b1$junc_or_IR == "IR") {
              
              list_matched_ont_junction_entries <- extract_junction.flanking.exons(query_chr = b1$chr, query_start = min(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_end = max(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)), query_strand = b1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 1, right_tolerance = 1, match_consecutive = TRUE, match_inside_same_transcript = TRUE, return_type = "exon")
              
              if (length(list_matched_ont_junction_entries) > 0) {
                
                # if junction match exists, then find all transcripts with completely overlapping exon
                list_matched_ont_inclusion_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$start <= (min(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)) - 1)) & (tibble_2023_hmsc_ob_ont_gtf$end >= (max(c(b1$junc_IR_coords_start, b1$junc_IR_coords_end)) + 1)) & tibble_2023_hmsc_ob_ont_gtf$type == "exon", ] %>% dplyr::group_by(transcript_id) %>% dplyr::group_split() %>% purrr::set_names(nm = purrr::map(.x = ., .f = ~.x$transcript_id %>% unique) %>% unlist)
                
                list_matched_ont_inclusion_transcript_entries <- tibble_2023_hmsc_ob_ont_gtf[(tibble_2023_hmsc_ob_ont_gtf$transcript_id %in% names(list_matched_ont_inclusion_entries)) & (tibble_2023_hmsc_ob_ont_gtf$type == "transcript"), ]
                
              } else {
                list_matched_ont_inclusion_entries <- list()
                list_matched_ont_inclusion_transcript_entries <- list()
              }
              
            }
            
          } )
        
        list_L1_result <- list(
          "splicing_data" = a1,
          "list_matched_ont_inclusion_entries" = list_matched_ont_inclusion_entries,
          "list_matched_ont_inclusion_transcript_entries" = list_matched_ont_inclusion_transcript_entries,
          "list_matched_ont_exclusion_entries" = list_matched_ont_exclusion_entries
        )
        
        return(list_L1_result)
        
      } )
    
    return(list_result)
    
  } ) %>% purrr::flatten()

saveRDS(object = list_majiq_constitutive_matched_to_ont, file = paste(results_dir, "list_majiq_constitutive_matched_to_ont.rds", sep = ""))

```

### re-read

```{r}

list_psisigma_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_differential_with_na_matched_to_ont.rds", sep = ""))
list_psisigma_constitutive_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_constitutive_matched_to_ont.rds", sep = ""))
list_jum_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_differential_with_na_matched_to_ont.rds", sep = ""))
list_jum_constitutive_no_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_constitutive_no_na_matched_to_ont.rds", sep = ""))
# list_majiq_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_majiq_differential_with_na_matched_to_ont.rds", sep = ""))
# list_majiq_constitutive_matched_to_ont <- readRDS(file = paste(results_dir, "list_majiq_constitutive_matched_to_ont.rds", sep = ""))

```

### simplify into table

```{r}

tibble_psisigma_differential_with_na_matched_to_ont <- list_psisigma_differential_with_na_matched_to_ont %>% 
  purrr::keep(.p = ~length(.x[[2]]) > 0) %>% 
  purrr::map(~.x$splicing_data) %>%
  data.table::rbindlist() %>%
  tibble::as_tibble()

tibble_jum_differential_with_na_matched_to_ont <- list_jum_differential_with_na_matched_to_ont %>% 
  purrr::keep(.p = ~length(.x[[2]]) > 0) %>% 
  purrr::map(~.x$splicing_data) %>%
  data.table::rbindlist() %>%
  tibble::as_tibble()

```


## High level analyses between short read and ONT

### Total count matches

```{r}

print("psisigma differential matched in ONT - total") 
print(paste(
  list_psisigma_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist %>% which %>% length, 
  "/", 
  length(list_psisigma_differential_with_na_matched_to_ont), sep = ""))

print("psisigma constitutive matched in ONT - total")
print(paste(
  list_psisigma_constitutive_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist %>% which %>% length, 
  "/", 
  length(list_psisigma_constitutive_matched_to_ont), sep = ""))

print("jum differential matched in ONT - total")
print(paste(
  list_jum_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist %>% which %>% length, 
  "/", 
  length(list_jum_differential_with_na_matched_to_ont), sep = ""))


print("jum constitutive matched in ONT - total")
print(paste(
  list_jum_constitutive_no_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist %>% which %>% length, 
  "/", 
  length(list_jum_constitutive_no_na_matched_to_ont), sep = ""))

# print("majiq differential matched in ONT - total")
# print(paste(
#   list_majiq_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist %>% which %>% length, 
#   "/", 
#   length(list_majiq_differential_with_na_matched_to_ont), sep = ""))
# 
# print("majiq constitutive matched in ONT - total")
# print(paste(
#   list_majiq_constitutive_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist %>% which %>% length, 
#   "/", 
#   length(list_majiq_constitutive_matched_to_ont), sep = ""))

```

### Count by splicemode

#### psisigma differential x ONT

```{r}

tibble_psisigma_differential_with_na_matched_to_ont_unfiltered_count <- list_psisigma_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_unfiltered"))

tibble_psisigma_differential_with_na_matched_to_ont_filtered_count <- list_psisigma_differential_with_na_matched_to_ont[list_psisigma_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_filtered"))

tibble_psisigma_differential_with_na_matched_to_ont_joined_count <- dplyr::left_join(tibble_psisigma_differential_with_na_matched_to_ont_unfiltered_count, tibble_psisigma_differential_with_na_matched_to_ont_filtered_count, by = "splicemode") %>% 
  dplyr::mutate("percentage" = n_filtered * 100/n_unfiltered)

ggplot_psisigma_differential_with_na_matched_to_ont_joined_count <- ggplot(data = tibble_psisigma_differential_with_na_matched_to_ont_joined_count, aes(x = `splicemode`, y = `percentage`)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black", fill = "black") +
  geom_text(stat = "identity", aes(label = paste(`percentage` %>% round(digits = 1), "%", sep = "")), position = position_dodge(width = 1), vjust = -1, size = 3) +
  ylim(c(0, 110)) +
  xlab("Splicemode") +
  ylab("Events validated in ONT") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black", angle = 0), legend.title.align = 0.5, legend.background = element_rect(linewidth = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_psisigma_differential_with_na_matched_to_ont_joined_count, filename = paste(results_dir, "ggplot_psisigma_differential_with_na_matched_to_ont_joined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm")

```

#### psisigma constitutive x ONT

```{r}

tibble_psisigma_constitutive_matched_to_ont_unfiltered_count <- list_psisigma_constitutive_matched_to_ont %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_unfiltered"))

tibble_psisigma_constitutive_matched_to_ont_filtered_count <- list_psisigma_constitutive_matched_to_ont[list_psisigma_constitutive_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_filtered"))

tibble_psisigma_constitutive_matched_to_ont_joined_count <- dplyr::left_join(tibble_psisigma_constitutive_matched_to_ont_unfiltered_count, tibble_psisigma_constitutive_matched_to_ont_filtered_count, by = "splicemode") %>% 
  dplyr::mutate("percentage" = n_filtered * 100/n_unfiltered)

ggplot_psisigma_constitutive_matched_to_ont_joined_count <- ggplot(data = tibble_psisigma_constitutive_matched_to_ont_joined_count, aes(x = `splicemode`, y = `percentage`)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black", fill = "black") +
  geom_text(stat = "identity", aes(label = paste(`percentage` %>% round(digits = 1), "%", sep = "")), position = position_dodge(width = 1), vjust = -1, size = 3) +
  ylim(c(0, 110)) +
  xlab("Splicemode") +
  ylab("Events validated in ONT") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black", angle = 0), legend.title.align = 0.5, legend.background = element_rect(linewidth = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_psisigma_constitutive_matched_to_ont_joined_count, filename = paste(results_dir, "ggplot_psisigma_constitutive_matched_to_ont_joined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm")

```

#### jum differential x ONT

```{r}

tibble_jum_differential_with_na_matched_to_ont_unfiltered_count <- list_jum_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_unfiltered"))

tibble_jum_differential_with_na_matched_to_ont_filtered_count <- list_jum_differential_with_na_matched_to_ont[list_jum_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_filtered"))

tibble_jum_differential_with_na_matched_to_ont_joined_count <- dplyr::left_join(tibble_jum_differential_with_na_matched_to_ont_unfiltered_count, tibble_jum_differential_with_na_matched_to_ont_filtered_count, by = "splicemode") %>% 
  dplyr::mutate("percentage" = n_filtered * 100/n_unfiltered)

ggplot_jum_differential_with_na_matched_to_ont_joined_count <- ggplot(data = tibble_jum_differential_with_na_matched_to_ont_joined_count, aes(x = `splicemode`, y = `percentage`)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black", fill = "black") +
  geom_text(stat = "identity", aes(label = paste(`percentage` %>% round(digits = 1), "%", sep = "")), position = position_dodge(width = 1), vjust = -1, size = 3) +
  ylim(c(0, 110)) +
  scale_x_discrete(limits = c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention"), labels = c("A3SS", "A5SS", "SES", "comp", "IR")) +
  xlab("Splicemode") +
  ylab("Events validated in ONT") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black", angle = 0), legend.title.align = 0.5, legend.background = element_rect(linewidth = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_jum_differential_with_na_matched_to_ont_joined_count, filename = paste(results_dir, "ggplot_jum_differential_with_na_matched_to_ont_joined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm")

```

#### jum constitutive x ONT

```{r}

tibble_jum_constitutive_no_na_matched_to_ont_unfiltered_count <- list_jum_constitutive_no_na_matched_to_ont %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_unfiltered"))

tibble_jum_constitutive_no_na_matched_to_ont_filtered_count <- list_jum_constitutive_no_na_matched_to_ont[list_jum_constitutive_no_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% purrr::map(.f = ~.x$splicing_data$splicemode) %>% unlist %>% gsub(pattern = "IR.*", replacement = "IR") %>% gsub(pattern = ".*(A.SS)", replacement = "\\1") %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_filtered"))

tibble_jum_constitutive_no_na_matched_to_ont_joined_count <- dplyr::left_join(tibble_jum_constitutive_no_na_matched_to_ont_unfiltered_count, tibble_jum_constitutive_no_na_matched_to_ont_filtered_count, by = "splicemode") %>% 
  dplyr::mutate("percentage" = n_filtered * 100/n_unfiltered)

ggplot_jum_constitutive_no_na_matched_to_ont_joined_count <- ggplot(data = tibble_jum_constitutive_no_na_matched_to_ont_joined_count, aes(x = `splicemode`, y = `percentage`)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black", fill = "black") +
  geom_text(stat = "identity", aes(label = paste(`percentage` %>% round(digits = 1), "%", sep = "")), position = position_dodge(width = 1), vjust = -1, size = 3) +
  ylim(c(0, 110)) +
  scale_x_discrete(limits = c("A3SS_events", "A5SS_events", "cassette_exon_events", "composite_events", "intron_retention"), labels = c("A3SS", "A5SS", "SES", "comp", "IR")) +
  xlab("Splicemode") +
  ylab("Events validated in ONT") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black", angle = 0), legend.title.align = 0.5, legend.background = element_rect(linewidth = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_jum_constitutive_no_na_matched_to_ont_joined_count, filename = paste(results_dir, "ggplot_jum_constitutive_no_na_matched_to_ont_joined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm")

```

#### majiq differential x ONT

```{r}

tibble_majiq_differential_with_na_matched_to_ont_unfiltered_count <- list_majiq_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$splicing_data$junc_or_IR) %>% unlist %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_unfiltered"))

tibble_majiq_differential_with_na_matched_to_ont_filtered_count <- list_majiq_differential_with_na_matched_to_ont[list_majiq_differential_with_na_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% purrr::map(.f = ~.x$splicing_data$junc_or_IR) %>% unlist %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_filtered"))

tibble_majiq_differential_with_na_matched_to_ont_joined_count <- dplyr::left_join(tibble_majiq_differential_with_na_matched_to_ont_unfiltered_count, tibble_majiq_differential_with_na_matched_to_ont_filtered_count, by = "splicemode") %>% 
  dplyr::mutate("percentage" = n_filtered * 100/n_unfiltered)

ggplot_majiq_differential_with_na_matched_to_ont_joined_count <- ggplot(data = tibble_majiq_differential_with_na_matched_to_ont_joined_count, aes(x = `splicemode`, y = `percentage`)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black", fill = "black") +
  geom_text(stat = "identity", aes(label = paste(`percentage` %>% round(digits = 1), "%", sep = "")), position = position_dodge(width = 1), vjust = -1, size = 3) +
  ylim(c(0, 110)) +
  xlab("Splicemode") +
  ylab("Events validated in ONT") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black", angle = 0), legend.title.align = 0.5, legend.background = element_rect(linewidth = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_majiq_differential_with_na_matched_to_ont_joined_count, filename = paste(results_dir, "ggplot_majiq_differential_with_na_matched_to_ont_joined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm")

```

#### majiq constitutive x ONT

```{r}

tibble_majiq_constitutive_matched_to_ont_unfiltered_count <- list_majiq_constitutive_matched_to_ont %>% purrr::map(.f = ~.x$splicing_data$junc_or_IR) %>% unlist %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_unfiltered"))

tibble_majiq_constitutive_matched_to_ont_filtered_count <- list_majiq_constitutive_matched_to_ont[list_majiq_constitutive_matched_to_ont %>% purrr::map(.f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% purrr::map(.f = ~.x$splicing_data$junc_or_IR) %>% unlist %>% table %>% tibble::as_tibble() %>% setNames(nm = c("splicemode", "n_filtered"))

tibble_majiq_constitutive_matched_to_ont_joined_count <- dplyr::left_join(tibble_majiq_constitutive_matched_to_ont_unfiltered_count, tibble_majiq_constitutive_matched_to_ont_filtered_count, by = "splicemode") %>% 
  dplyr::mutate("percentage" = n_filtered * 100/n_unfiltered)

ggplot_majiq_constitutive_matched_to_ont_joined_count <- ggplot(data = tibble_majiq_constitutive_matched_to_ont_joined_count, aes(x = `splicemode`, y = `percentage`)) +
  geom_bar(stat = "identity", position = "dodge", size = 0.2, colour = "black", fill = "black") +
  geom_text(stat = "identity", aes(label = paste(`percentage` %>% round(digits = 1), "%", sep = "")), position = position_dodge(width = 1), vjust = -1, size = 3) +
  ylim(c(0, 110)) +
  xlab("Splicemode") +
  ylab("Events validated in ONT") +
  theme_bw() +
  theme(axis.text.x = element_text(hjust = 0.5, colour = "black", angle = 0), legend.title.align = 0.5, legend.background = element_rect(linewidth = 0.5, linetype = "solid", colour = "black"), axis.title.y = element_text(margin = margin(r = 20)), text = element_text(family = "Helvetica"))

ggsave(plot = ggplot_majiq_constitutive_matched_to_ont_joined_count, filename = paste(results_dir, "ggplot_majiq_constitutive_matched_to_ont_joined_count.pdf", sep = ""), device = "pdf", dpi = 600, width = 10, height = 10, units = "cm")

```

#### plot all

```{r}

ggplot_psisigma_differential_with_na_matched_to_ont_joined_count
ggplot_psisigma_constitutive_matched_to_ont_joined_count
ggplot_jum_differential_with_na_matched_to_ont_joined_count
ggplot_jum_constitutive_no_na_matched_to_ont_joined_count
ggplot_majiq_differential_with_na_matched_to_ont_joined_count
ggplot_majiq_constitutive_matched_to_ont_joined_count

```

## match ONT exons to reference
derive stats pertaining to number of exons sharing 0, 1 or 2 vertices with the reference

remove first and last exons from the reference 

```{r}

tibble_ref_gtf <- rtracklayer::import("/mnt/LTS/reference_data/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMD_PTC_E4.gtf") %>% tibble::as_tibble()

list_2023_hmsc_ob_ont_gtf

```

### match exact, followed by one-sided match

```{r}

list_ont_vs_ref_vertex_match_results <- callr_map(
  .x = list_2023_hmsc_ob_ont_gtf,
  .no_workers = 6, .no_chunks = 6,
  .f = function(a1) {
    
    a1 <- a1 %>% .[(.$strand != "*") & (.$type == "exon"), ]
    
    ### EXACT MATCH
    # exact match of each alternative exon to the reference GTF
    # if an exact match is found, regardless of whether it is the first/last exon in ONT or reference, we count it as a real match
    list_matched_GTF_exon_entries <- mc_pmap(
      .l = list(
        "b1" = a1$seqnames,
        "b2" = a1$start %>% type.convert(as.is = TRUE),
        "b3" = a1$end %>% type.convert(as.is = TRUE),
        "b4" = a1$strand,
        "b5" = a1$first_or_last_exon
      ),
      .no_workers = 32, .no_chunks = 32,
      .f = function(b1, b2, b3, b4, b5) {
        
        # DEBUG ###
        # b1 <- a1$seqnames %>% .[[29]]
        # b2 <- a1$start %>% type.convert(as.is = TRUE) %>% .[[29]]
        # b3 <- a1$end %>% type.convert(as.is = TRUE) %>% .[[29]]
        # b4 <- a1$strand %>% .[[29]]
        # b5 <- a1$first_or_last_exon %>% .[[29]]
        ###########
        
         tibble_exactmatch <- extract_matching.exons(query_chr = b1, query_start = b2, query_end = b3, query_strand = b4, tibble_gtf_table = tibble_ref_gtf, return_type = "exon") 
        
        logical_match_found_in_ref <- nrow(tibble_exactmatch) > 0
        
        if (logical_match_found_in_ref == TRUE) {
          logical_match_found_in_ref <- "exactmatch"
          if (any(unique(tibble_exactmatch$first_or_last_exon) != "NA")) {
            logical_match_found_in_ref <- paste(logical_match_found_in_ref, "_", paste(paste("ref_", sort(unique(tibble_exactmatch$first_or_last_exon) %>% .[. != "NA"]), sep = ""), collapse = "_"), sep = "")
          }
          
          if (b5 != "NA") {
            logical_match_found_in_ref <- paste("ont_", b5, "_", logical_match_found_in_ref, sep = "")
          }
          
        }
        
        if (logical_match_found_in_ref == FALSE) {
          
          tibble_singlesided_match_starts <- magnetise_genome_position_to_ref_starts(query_chr = b1, query_coord = b2, query_strand = b4, tibble_gtf_table = tibble_ref_gtf, query_tolerance = 1, return_type = "exon")$tibble_ref_starts_matched_to_query_coord
          
          tibble_singlesided_match_ends <- magnetise_genome_position_to_ref_end(query_chr = b1, query_coord = b3, query_strand = b4, tibble_gtf_table = tibble_ref_gtf, query_tolerance = 1, return_type = "exon")$tibble_ref_ends_matched_to_query_coord
          
          logical_onesided_match_in_ref <- (nrow(tibble_singlesided_match_starts) > 0) | (nrow(tibble_singlesided_match_ends) > 0)
          
          if (logical_onesided_match_in_ref == TRUE) {
            logical_onesided_match_in_ref <- "onesided"
            if (any(unique(dplyr::bind_rows(tibble_singlesided_match_starts, tibble_singlesided_match_ends)$first_or_last_exon) != "NA")) {
              logical_onesided_match_in_ref <- paste(logical_onesided_match_in_ref, "_", paste(paste("ref_", sort(unique(dplyr::bind_rows(tibble_singlesided_match_starts, tibble_singlesided_match_ends)$first_or_last_exon) %>% .[. != "NA"]), sep = ""), collapse = "_"), sep = "")
            }
          }
          
          if (logical_onesided_match_in_ref == FALSE) {
            logical_onesided_match_in_ref <- "nomatch"
          }
          
          if (b5 != "NA") {
            logical_onesided_match_in_ref <- paste("ont_", b5, "_", logical_onesided_match_in_ref, sep = "")
          }
         
          logical_match_found_in_ref <- logical_onesided_match_in_ref
           
        }
        
        return(logical_match_found_in_ref)
        
      }, .progress = TRUE )
    
    return(list_matched_GTF_exon_entries %>% unlist)
    
  } )

qsave(x = list_ont_vs_ref_vertex_match_results, file = paste(results_dir, "list_ont_vs_ref_vertex_match_results.qs"))

```

### get match stats

```{r}

percentage_of_ref_covered_by_ont <- (purrr::map2(
  .x = list_2023_hmsc_ob_ont_gtf,
  .y = list_ont_vs_ref_vertex_match_results,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_2023_hmsc_ob_ont_gtf[[1]]
    # a2 <- list_ont_vs_ref_vertex_match_results[[1]]
    ###########
    
    a1 <- a1 %>% .[(.$strand != "*") & (.$type == "exon"), ]
    
    return(a1[grep(x = a2, pattern = "exactmatch"), ])
    
  } ) %>% data.table::rbindlist(use.names = TRUE) %>% tibble::as_tibble() %>% dplyr::distinct(seqnames, start, end, .keep_all = TRUE) %>% .$width %>% sum) /
  (tibble_ref_gtf %>% .[.$type == "exon", ] %>% dplyr::distinct(seqnames, start, end, .keep_all = TRUE) %>% .$width %>% sum)

list_ont_to_ref_matching_scores <- callr_map2(
  .x = list_2023_hmsc_ob_ont_gtf,
  .y = list_ont_vs_ref_vertex_match_results,
  .no_workers = 6, .no_chunks = 6,
  .f = function(a1, a2) {
    
    # DEBUG ###
    # a1 <- list_2023_hmsc_ob_ont_gtf[[1]]
    # a2 <- list_ont_vs_ref_vertex_match_results[[1]]
    ###########
    
    # number of transcripts in ONT
    tibble_transcript_id_max_exon_number <- a1[a1$type == "exon", ] %>% 
      dplyr::group_by(transcript_id) %>% 
      dplyr::summarise("max_exon_number" = max(exon_number)) 
    
    # transcripts with at least 2 exons
    number_of_transcripts_in_ont <- nrow(tibble_transcript_id_max_exon_number %>% .[.$max_exon_number > 1, ])
    
    # join ref exon matching info onto ONT GTF table
    tibble_ont_gtf_with_ref_matching_results <- dplyr::left_join(
      a1,
      a1 %>% .[(.$strand != "*") & (.$type == "exon"), ] %>% dplyr::mutate("ref_matching_result" = a2)
    )
    
    # count matching exons and transcripts
    list_ont_exon_match <- mc_pmap(
      .l = list(
        "b1" = tibble_ont_gtf_with_ref_matching_results %>% 
        .[.$type == "exon", ] %>%
        dplyr::group_split(transcript_id) %>%
        purrr::keep(.p = ~max(.x$exon_number) > 1)
      ),
      .no_workers = 8, .no_chunks = 8,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- tibble_ont_gtf_with_ref_matching_results %>% 
        #   .[.$type == "exon", ] %>%
        #   dplyr::group_split(transcript_id) %>%
        #   purrr::keep(.p = ~max(.x$exon_number) > 1) %>% .[[43]]
        ###########
        
        if (any(is.na(b1$ref_matching_result))) {
          stop("shouldn't be missing matching info")
        }
        
        # exactmatch|onesided|nomatch
        regular_exon_exactmatch_count <- sum(as.numeric(grepl(x = b1[which(!b1$first_or_last_exon %in% c("first_exon", "last_exon")), ]$ref_matching_result, pattern = "exactmatch")))
        regular_exon_onesided_count <- sum(as.numeric(grepl(x = b1[which(!b1$first_or_last_exon %in% c("first_exon", "last_exon")), ]$ref_matching_result, pattern = "onesided")))
        regular_exon_nomatch_count <- sum(as.numeric(grepl(x = b1[which(!b1$first_or_last_exon %in% c("first_exon", "last_exon")), ]$ref_matching_result, pattern = "nomatch")))
        
        firstlast_exon_exactmatch_count <- sum(as.numeric(grepl(x = b1[which(b1$first_or_last_exon %in% c("first_exon", "last_exon")), ]$ref_matching_result, pattern = "exactmatch")))
        firstlast_exon_onesided_count <- sum(as.numeric(grepl(x = b1[which(b1$first_or_last_exon %in% c("first_exon", "last_exon")), ]$ref_matching_result, pattern = "onesided")))
        firstlast_exon_nomatch_count <- sum(as.numeric(grepl(x = b1[which(b1$first_or_last_exon %in% c("first_exon", "last_exon")), ]$ref_matching_result, pattern = "nomatch")))
        
        return(
          data.table::data.table(
            "transcript_id" = b1$transcript_id %>% unique,
            "regular_exon_exactmatch_count" = regular_exon_exactmatch_count,
            "regular_exon_onesided_count" = regular_exon_onesided_count,
            "regular_exon_nomatch_count" = regular_exon_nomatch_count,
            
            "firstlast_exon_exactmatch_count" = firstlast_exon_exactmatch_count,
            "firstlast_exon_onesided_count" = firstlast_exon_onesided_count,
            "firstlast_exon_nomatch_count" = firstlast_exon_nomatch_count
          ) )
        
      }, .progress = TRUE)
    
    tibble_ont_exon_match <- list_ont_exon_match %>% 
      data.table::rbindlist() %>% tibble::as_tibble()
    
    return(tibble_ont_exon_match)
    
  } )

list_transcript_exon_match_summary <- purrr::map(
  .x = list_ont_to_ref_matching_scores,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_ont_to_ref_matching_scores[[4]]
    ###########
    
    number_of_transcripts_all_match <- which(
      (a1$regular_exon_onesided_count == 0) & 
        (a1$regular_exon_nomatch_count == 0) &
        (a1$firstlast_exon_onesided_count == 0) &
        (a1$firstlast_exon_nomatch_count == 0)
    ) %>% length
    
    number_of_transcripts_onesided_boundary_match <- which(
      (a1$regular_exon_onesided_count == 0) & 
        (a1$regular_exon_nomatch_count == 0) &
        (a1$firstlast_exon_onesided_count > 0) &
        (a1$firstlast_exon_nomatch_count == 0)
    ) %>% length
    
    number_of_ont_transcripts <- nrow(a1)
    
    number_of_matched_exons_total <- sum(a1$regular_exon_exactmatch_count) + sum(a1$firstlast_exon_exactmatch_count)
    
    number_of_onesided_matches_total <- sum(a1$regular_exon_onesided_count) + sum(a1$firstlast_exon_onesided_count)
    
    number_of_ont_exons <- a1 %>% dplyr::select(contains("count")) %>% unlist %>% sum
    
    return(
      list(
        "number_of_transcripts_all_match" = number_of_transcripts_all_match,
        "number_of_transcripts_onesided_boundary_match" = number_of_transcripts_onesided_boundary_match,
        "number_of_ont_transcripts" = number_of_ont_transcripts,
        "number_of_matched_exons_total" = number_of_matched_exons_total,
        "number_of_onesided_matches_total" = number_of_onesided_matches_total
      )
    )
    
  } )

qsave(x = list_transcript_exon_match_summary, file = paste(results_dir, "list_transcript_exon_match_summary.qs"))

purrr::pmap(
  .l = list_transcript_exon_match_summary %>% purrr::set_names(nm = c("a1", "a2", "a3", "a4", "a5", "a6")),
  .f = function(a1, a2, a3, a4, a5, a6) {
    
    return(mean(c(a1, a2, a3, a4, a5, a6)))
    
  } )

```

## Get quantitative correlations between short read and ONT

### d

```{r}

# add in the short read timeseries data
list_psisigma_differential_with_na_matched_to_ont_timeseries <- purrr::map(
  .x = list_psisigma_differential_with_na_matched_to_ont,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_psisigma_differential_with_na_matched_to_ont[[2]]
    ###########
    
    tibble_sr_timeseries_data <- tibble_PSIsigma_scaled_PSI_timeseries_wide[tibble_PSIsigma_scaled_PSI_timeseries_wide$database_ID %in% a1$splicing_data$database_ID, ] %>% .[, colnames(.) %in% c("MSC", "6h", "1d", "3d", "9d", "12d")] %>% reshape2::melt(value.name = "scaled_value_sr", variable.name = "timepoint") %>% tibble::as_tibble() %>% dplyr::mutate_if(is.factor, as.character) %>% suppressMessages()
    
    tibble_ont_inclusion_timeseries_data <- purrr::map(
      .x = c("MSC", "6h", "1d", "3d", "9d", "12d"),
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- "MSC"
        ###########
        
        list_matched_ont_entries <- a1$list_matched_ont_inclusion_transcript_entries %>% .[grepl(x = names(.), pattern = paste("\\|", b1, sep = ""))]
        
        if (length(list_matched_ont_entries) > 0) {
          tibble_ont_timeseries_onetimepoint <- list_matched_ont_entries %>% dplyr::bind_rows() %>% dplyr::rename("TPM_inclusion" = "TPM") %>% .[.$type == "transcript", c("transcript_id_original", "TPM_inclusion")] %>% dplyr::mutate("timepoint" = b1)
        } else {
          tibble_ont_timeseries_onetimepoint <- tibble("transcript_id_original" = character(0), "TPM_inclusion" = character(0), "timepoint" = character(0))
        }
        
        return(tibble_ont_timeseries_onetimepoint)
        
      } ) %>% purrr::reduce(dplyr::bind_rows)
    
    tibble_ont_exclusion_timeseries_data <- purrr::map(
      .x = c("MSC", "6h", "1d", "3d", "9d", "12d"),
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- "MSC"
        ###########
        
        list_matched_ont_entries <- a1$list_matched_ont_exclusion_transcript_entries %>% .[grepl(x = names(.), pattern = paste("\\|", b1, sep = ""))]
        
        if (length(list_matched_ont_entries) > 0) {
          tibble_ont_timeseries_onetimepoint <- list_matched_ont_entries %>% dplyr::bind_rows() %>% dplyr::rename("TPM_exclusion" = "TPM") %>% .[.$type == "transcript", c("transcript_id_original", "TPM_exclusion")] %>% dplyr::mutate("timepoint" = b1)
        } else {
          tibble_ont_timeseries_onetimepoint <- tibble("transcript_id_original" = character(0), "TPM_exclusion" = character(0), "timepoint" = character(0))
        }
        
        return(tibble_ont_timeseries_onetimepoint)
        
      } ) %>% purrr::reduce(dplyr::bind_rows)
    
    tibble_average_timeseries_inclusion <- tibble_ont_inclusion_timeseries_data %>%
      dplyr::group_by(timepoint) %>%
      dplyr::summarise("average_value_inclusion" = mean(TPM_inclusion %>% type.convert(as.is = TRUE))) %>%
      dplyr::left_join(tibble("timepoint" = c("MSC", "6h", "1d", "3d", "9d", "12d")), ., by = "timepoint")
    
    tibble_average_timeseries_exclusion <- tibble_ont_exclusion_timeseries_data %>%
      dplyr::group_by(timepoint) %>%
      dplyr::summarise("average_value_exclusion" = mean(TPM_exclusion %>% type.convert(as.is = TRUE))) %>%
      dplyr::left_join(tibble("timepoint" = c("MSC", "6h", "1d", "3d", "9d", "12d")), ., by = "timepoint")
    
    tibble_timeseries_data_merged <- dplyr::full_join(tibble_average_timeseries_inclusion, tibble_average_timeseries_exclusion, by = "timepoint") %>% 
      dplyr::full_join(., tibble_sr_timeseries_data, by = "timepoint") %>%
      dplyr::mutate("id" = a1$splicing_data$id %>% unique)
    
    tibble_timeseries_data_merged[is.na(tibble_timeseries_data_merged)] <- 0
    
    tibble_timeseries_data_merged <- tibble_timeseries_data_merged %>%
      dplyr::mutate("psi" = average_value_inclusion/(average_value_inclusion + average_value_exclusion)) %>%
      dplyr::mutate("scaled_value_ont_psi" = genefilter::genescale(m = `psi`, method = "Z")) %>%
      dplyr::select(-psi)
      
    return(purrr::splice(
      a1,
      "tibble_sr_timeseries_data" = tibble_sr_timeseries_data,
      "tibble_ont_inclusion_timeseries_data" = tibble_ont_inclusion_timeseries_data,
      "tibble_timeseries_data_merged" = tibble_timeseries_data_merged))
    
  } ) %>% purrr::discard(.p = ~(.x$tibble_sr_timeseries_data %>% nrow == 0) | (.x$tibble_ont_inclusion_timeseries_data %>% nrow == 0))

tibble_matched_timeseries_data_for_plot <- list_psisigma_differential_with_na_matched_to_ont_timeseries[purrr::map(.x = list_psisigma_differential_with_na_matched_to_ont_timeseries, .f = ~grepl(x = .x$splicing_data$splicemode, pattern = ".*")) %>% unlist] %>% 
  purrr::map(.f = ~.x$tibble_timeseries_data_merged) %>%
  data.table::rbindlist() %>%
  tibble::as_tibble()

ggplot() +
  geom_point(mapping = aes(x = tibble_matched_timeseries_data_for_plot$scaled_value_sr, y = tibble_matched_timeseries_data_for_plot$scaled_value_ont_psi))

cor(x = tibble_matched_timeseries_data_for_plot %>% na.omit %>% .$scaled_value_sr, y = tibble_matched_timeseries_data_for_plot %>% na.omit %>% .$scaled_value_ont_psi, method = "pearson")

```

## Do NMD analysis - reference-guided
use the start and stop codons in reference to do the in-silico translation

### transfer start and stop codons from ref GTF to ONT GTF

```{r}

tibble_ref_gtf <- rtracklayer::import("/mnt/LTS/reference_data/hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMD_PTC_E4.gtf") %>% tibble::as_tibble()

# map start/stops onto the transcript_ids of the ONT GTF
tibble_ref_gtf_startstop_codons <- tibble_ref_gtf[tibble_ref_gtf$type %in% c("start_codon", "stop_codon"), ] %>% 
  dplyr::distinct(seqnames, start, end, strand, type, .keep_all = TRUE)

list_startop_entries_for_insertion <- callr_insulator(.f = quote(mc_pmap(
  .l = list(
    "a1" = 1:nrow(tibble_ref_gtf_startstop_codons)
  ),
  .no_workers = 192, .no_chunks = 192,
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- 2343
    ###########
    
    L1_row_tibble_ref_gtf_startstop_codons <- tibble_ref_gtf_startstop_codons[a1, ]
    
    list_additional_exon_entries_ref_startstop_ont <- purrr::map(
      .x = list_2023_hmsc_ob_ont_gtf,
      .f = function(b1) {
        
        # DEBUG ###
        # b1 <- list_2023_hmsc_ob_ont_gtf[[1]]
        ###########
        
        L2_tibble_fully_overlapped_exons_in_ont <- b1[(b1$seqnames == L1_row_tibble_ref_gtf_startstop_codons$seqnames) & (b1$start <= L1_row_tibble_ref_gtf_startstop_codons$start + 0) & (b1$end >= L1_row_tibble_ref_gtf_startstop_codons$end - 0) & (b1$strand == L1_row_tibble_ref_gtf_startstop_codons$strand) & (b1$type == "exon"), ]
        
        tibble_startstop_entries_for_insertion <- L2_tibble_fully_overlapped_exons_in_ont[, c("seqnames", "start", "end", "width", "strand", "source", "type", "gene_id", "transcript_id", "timepoint", "exon_number")]
        
        if (nrow(L2_tibble_fully_overlapped_exons_in_ont) > 0) {
          tibble_startstop_entries_for_insertion[, "seqnames"] <- L1_row_tibble_ref_gtf_startstop_codons$seqnames
          tibble_startstop_entries_for_insertion[, "start"] <- L1_row_tibble_ref_gtf_startstop_codons$start
          tibble_startstop_entries_for_insertion[, "end"] <- L1_row_tibble_ref_gtf_startstop_codons$end
          tibble_startstop_entries_for_insertion[, "width"] <- L1_row_tibble_ref_gtf_startstop_codons$width
          tibble_startstop_entries_for_insertion[, "strand"] <- L1_row_tibble_ref_gtf_startstop_codons$strand
          tibble_startstop_entries_for_insertion[, "type"] <- L1_row_tibble_ref_gtf_startstop_codons$type
        }
        
        return(tibble_startstop_entries_for_insertion)
        
      } )
    
    return(list_additional_exon_entries_ref_startstop_ont)
    
  }, .progress = TRUE ) ))

list_2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries <- purrr::map(
  .x = 1:length(list_2023_hmsc_ob_ont_gtf),
  .f = function(a1) {
    
    dplyr::bind_rows(
      list_2023_hmsc_ob_ont_gtf[[a1]],
      purrr::map(
        .x = list_startop_entries_for_insertion,
        .f = ~.x[[a1]] ) %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::as_tibble()
    ) %>% return
    
  }, .progress = TRUE ) 

# some transcripts may have gotten more than one start or stop codon. only keep the earliest or latest one respectively.
list_2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries <- purrr::pmap(
  .l = list(
    "a1" = list_2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries
  ),
  .f = function(a1) {
    
    # DEBUG ###
    # a1 <- list_2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries[[1]]
    ###########
    
    if (is.numeric(a1$exon_number) == FALSE) {
      stop("exon_number column needs to be numeric")
    }
    
    tibble_filtered_gtf <- list(
      a1 %>% .[!.$type %in% c("start_codon", "stop_codon"), ],
      a1[a1$type == "start_codon", ] %>% dplyr::group_split(transcript_id) %>% purrr::map(.f = ~.x[.x$exon_number == min(.x$exon_number), ] %>% .[1, ]),
      a1[a1$type == "stop_codon", ] %>% dplyr::group_split(transcript_id) %>% purrr::map(.f = ~.x[.x$exon_number == min(.x$exon_number), ] %>% .[nrow(.), ])
    ) %>%
      purrr::reduce(dplyr::bind_rows)
    
    # only keep transcripts that have annotated start/stop codons
    tibble_filtered_gtf <- tibble_filtered_gtf %>% .[.$transcript_id %in% (tibble_filtered_gtf %>% .[.$type %in% c("start_codon", "stop_codon"), ] %>% .$transcript_id %>% unique), ]
    
    return(tibble_filtered_gtf)
    
  }, .progress = TRUE )

purrr::map2(
  .x = list_2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries,
  .y = purrr::map(.x = list_2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries, .f = ~.x$timepoint %>% unique) %>% unlist,
  .f = ~rtracklayer::export(object = .x %>% dplyr::select(-contains("frame"), -contains("first_or_last")), con = paste(results_dir, "2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries_", .y, ".gtf", sep = ""), format = "gtf"), 
    # data.table::fwrite(x = .x, file = paste(results_dir, "2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries_", .y, ".gtf", sep = ""), quote = FALSE, row.names = FALSE, col.names = TRUE)
  .progress = TRUE
)

```

### retrieve annotations for NMD

```{r}

list_2023_hmsc_ob_ont_gtf_annotated_nmd <- purrr::map(
  .x = vector_2023_ont_timepoints_edited,
  .f = ~rtracklayer::import(con = paste(nmd_classifier_dir, "2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries_", .x, ".gtf", sep = ""), format = "gtf") %>% tibble::as_tibble(), 
    # data.table::fwrite(x = .x, file = paste(results_dir, "2023_hmsc_ob_ont_gtf_with_ref_inserted_startstop_entries_", .y, ".gtf", sep = ""), quote = FALSE, row.names = FALSE, col.names = TRUE)
  .progress = TRUE
)

tibble_2023_hmsc_ob_ont_gtf_annotated_nmd <- list_2023_hmsc_ob_ont_gtf_annotated_nmd %>% data.table::rbindlist(use.names = TRUE) %>% tibble::as_tibble()

list_psisigma_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_differential_with_na_matched_to_ont.rds", sep = ""))
list_psisigma_constitutive_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_constitutive_matched_to_ont.rds", sep = ""))
list_jum_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_differential_with_na_matched_to_ont.rds", sep = ""))
list_jum_constitutive_no_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_constitutive_no_na_matched_to_ont.rds", sep = ""))

# get an NMD annotation for all matched splice events

tibble_psisigma_differential_with_na_nmd_referenceguided <- purrr::map(
  .x = list_psisigma_differential_with_na_matched_to_ont,
  .f = function(a1) {
    
    if (length(a1$list_matched_ont_inclusion_entries) > 0) {
      
      return(
        dplyr::bind_cols(
          a1$splicing_data,
          a1$list_matched_ont_inclusion_entries %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% .[, c("transcript_id_original", "timepoint")] %>% dplyr::rename("ont_matched_transcript_id" = "transcript_id_original", "ont_matched_timepoint" = "timepoint")
        )
      )
      
    } else {
      return(a1$splicing_data[0,])
      }
      
  } ) %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::as_tibble()

tibble_psisigma_differential_with_na_nmd_referenceguided[which(tibble_psisigma_differential_with_na_nmd_referenceguided$introduces_PTC_for_any_matched_transcripts == TRUE), ] %>% dplyr::distinct(id, .keep_all = TRUE) %>% .$splicemode %>% table

tibble_psisigma_constitutive_nmd_referenceguided <- purrr::map(
  .x = list_psisigma_constitutive_matched_to_ont,
  .f = function(a1) {
    
    if (length(a1$list_matched_ont_inclusion_entries) > 0) {
      
      return(
        dplyr::bind_cols(
          a1$splicing_data,
          a1$list_matched_ont_inclusion_entries %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% .[, c("transcript_id_original", "timepoint")] %>% dplyr::rename("ont_matched_transcript_id" = "transcript_id_original", "ont_matched_timepoint" = "timepoint")
        )
      )
      
    } else {
      return(a1$splicing_data[0,])
      }
      
  } ) %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::as_tibble()

tibble_psisigma_constitutive_nmd_referenceguided[which(tibble_psisigma_constitutive_nmd_referenceguided$introduces_PTC_for_any_matched_transcripts == TRUE), ] %>% dplyr::distinct(id, .keep_all = TRUE) %>% .$splicemode %>% table

tibble_jum_differential_with_na_nmd_referenceguided <- purrr::map(
  .x = list_jum_differential_with_na_matched_to_ont,
  .f = function(a1) {
    
    if (length(a1$list_matched_ont_inclusion_entries) > 0) {
      
      return(
        dplyr::bind_cols(
          a1$splicing_data,
          a1$list_matched_ont_inclusion_entries %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% .[, c("transcript_id_original", "timepoint")] %>% dplyr::rename("ont_matched_transcript_id" = "transcript_id_original", "ont_matched_timepoint" = "timepoint")
        )
      )
      
    } else {
      return(a1$splicing_data[0,])
      }
      
  } ) %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::as_tibble()

tibble_jum_differential_with_na_nmd_referenceguided[which(tibble_jum_differential_with_na_nmd_referenceguided$any_NMD == TRUE), ] %>% dplyr::distinct(AS_event_ID, sub_junction_start_coor, sub_junction_end_coor, .keep_all = TRUE) %>% .$splicemode %>% table

tibble_jum_constitutive_nmd_referenceguided <- purrr::map(
  .x = list_jum_constitutive_no_na_matched_to_ont,
  .f = function(a1) {
    
    if (length(a1$list_matched_ont_inclusion_entries) > 0) {
      
      return(
        dplyr::bind_cols(
          a1$splicing_data,
          a1$list_matched_ont_inclusion_entries %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% .[, c("transcript_id_original", "timepoint")] %>% dplyr::rename("ont_matched_transcript_id" = "transcript_id_original", "ont_matched_timepoint" = "timepoint")
        )
      )
      
    } else {
      return(a1$splicing_data[0,])
      }
      
  } ) %>% data.table::rbindlist(use.names = TRUE, fill = TRUE) %>% tibble::as_tibble()

tibble_jum_constitutive_nmd_referenceguided[which(tibble_jum_constitutive_nmd_referenceguided$any_NMD == TRUE), ] %>% dplyr::distinct(AS_event_ID, sub_junction_start_coor, sub_junction_end_coor, .keep_all = TRUE) %>% .$splicemode %>% table

```

## Do NMD analysis - de novo

### Validation of translation fidelity against reference GTF

```{r}

tibble_ref_gtf <- rtracklayer::import(con = paste(reference_data_dir, "hg38_ensembl_reference/gtf/Homo_sapiens.GRCh38.98_NMD_PTC_E4.gtf", sep = ""), format = "gtf") %>%
  tibble::as_tibble()

tibble_2023_hmsc_ob_ont_gtf_summarised_for_nmd <- tibble_2023_hmsc_ob_ont_gtf %>%
  .[.$strand %in% c("+", "-") & .$type == "transcript", ] %>%
  .[!is.na(.$genome_relative_start_coding_sequence_frame0_ATGonly) & !is.na(.$genome_relative_start_coding_sequence_frame1_ATGonly) & !is.na(.$genome_relative_start_coding_sequence_frame2_ATGonly), ] %>%
  dplyr::mutate_at(vars(contains("length_longest_coding_sequence")), .funs = function(x) {x[is.na(x)] <- 0; return(x)} ) %>%
  dplyr::rowwise() %>%
  dplyr::mutate(
                 "ATGonly_longest_coding_frame_genome_relative_start_position" = if (length_longest_coding_sequence_frame0_ATGonly > length_longest_coding_sequence_frame1_ATGonly & length_longest_coding_sequence_frame0_ATGonly > length_longest_coding_sequence_frame2_ATGonly) {
                   genome_relative_start_coding_sequence_frame0_ATGonly
                 } else if (length_longest_coding_sequence_frame1_ATGonly > length_longest_coding_sequence_frame0_ATGonly & length_longest_coding_sequence_frame1_ATGonly > length_longest_coding_sequence_frame2_ATGonly) {
                   genome_relative_start_coding_sequence_frame1_ATGonly
                 } else if (length_longest_coding_sequence_frame2_ATGonly > length_longest_coding_sequence_frame0_ATGonly & length_longest_coding_sequence_frame2_ATGonly > length_longest_coding_sequence_frame1_ATGonly) {
                   genome_relative_start_coding_sequence_frame2_ATGonly
                 } else {
                   NA
                 },
                 "ATGonly_longest_coding_frame_genome_relative_end_codon_position" = if (length_longest_coding_sequence_frame0_ATGonly > length_longest_coding_sequence_frame1_ATGonly & length_longest_coding_sequence_frame0_ATGonly > length_longest_coding_sequence_frame2_ATGonly) {
                   genome_relative_stop_codon_frame0_ATGonly
                 } else if (length_longest_coding_sequence_frame1_ATGonly > length_longest_coding_sequence_frame0_ATGonly & length_longest_coding_sequence_frame1_ATGonly > length_longest_coding_sequence_frame2_ATGonly) {
                   genome_relative_stop_codon_frame1_ATGonly
                 } else if (length_longest_coding_sequence_frame2_ATGonly > length_longest_coding_sequence_frame0_ATGonly & length_longest_coding_sequence_frame2_ATGonly > length_longest_coding_sequence_frame1_ATGonly) {
                   genome_relative_stop_codon_frame2_ATGonly
                 } else {
                   NA
                 },
                 "ATGonly_longest_coding_frame_has_PTC" = if (length_longest_coding_sequence_frame0_ATGonly > length_longest_coding_sequence_frame1_ATGonly & length_longest_coding_sequence_frame0_ATGonly > length_longest_coding_sequence_frame2_ATGonly) {
                   has_ptc_frame0_ATGonly
                 } else if (length_longest_coding_sequence_frame1_ATGonly > length_longest_coding_sequence_frame0_ATGonly & length_longest_coding_sequence_frame1_ATGonly > length_longest_coding_sequence_frame2_ATGonly) {
                   has_ptc_frame1_ATGonly
                 } else if (length_longest_coding_sequence_frame2_ATGonly > length_longest_coding_sequence_frame0_ATGonly & length_longest_coding_sequence_frame2_ATGonly > length_longest_coding_sequence_frame1_ATGonly) {
                   has_ptc_frame2_ATGonly
                 } else {
                   NA
                 } )

# check stop codons against reference
options(mc.cores = 94)

listified_tibble <- tibble_2023_hmsc_ob_ont_gtf_summarised_for_nmd %>% dplyr::rowwise() %>% dplyr::group_split()

list_frames_with_stop_codon <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/2019_multiomic_synthesis_list_frames_with_stop_codon.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_ref_gtf"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "2019_multiomic_synthesis_list_frames_with_stop_codon",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    purrr::map(
      .x = `_a1`,
      .f = function(a1) {
        
        if (!is.na(a1$ATGonly_longest_coding_frame_genome_relative_end_codon_position)) {
          
          tibble_ref_gtf[(tibble_ref_gtf$type == "stop_codon") & (tibble_ref_gtf$seqnames == a1$seqnames) & (tibble_ref_gtf$start - 1 <= min(a1$ATGonly_longest_coding_frame_genome_relative_end_codon_position %>% strsplit(split = ",") %>% unlist %>% type.convert(as.is = TRUE))) & (tibble_ref_gtf$end + 1 >= max(a1$ATGonly_longest_coding_frame_genome_relative_end_codon_position %>% strsplit(split = ",") %>% unlist %>% type.convert(as.is = TRUE))), ]
          
        } else {
          
          return(tibble())
          
        }
        
      } ) %>% 
      return
    
  } ) %>%
  purrr::flatten()

tibble_2023_hmsc_ob_ont_gtf_summarised_for_nmd[, c("seqnames", "ATGonly_longest_coding_frame_genome_relative_end_codon_position")] %>% unique %>% dim

list_frames_with_stop_codon %>% purrr::map(.f = ~.x %>% nrow > 0) %>% unlist %>% which %>% length

tibble_ref_gtf[tibble_ref_gtf$type == "stop_codon", c("type", "transcript_id")] %>% unique %>% nrow








# try a different way to see which frame is best

tibble_2023_hmsc_ob_ont_gtf_summarised_for_nmd <- tibble_2023_hmsc_ob_ont_gtf %>%
  .[.$strand %in% c("+", "-") & .$type == "transcript", ] 

listified_tibble <- tibble_2023_hmsc_ob_ont_gtf_summarised_for_nmd %>% dplyr::rowwise() %>% dplyr::group_split()

list_frames_with_stop_codon <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/2019_multiomic_synthesis_list_frames_with_stop_codon.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_ref_gtf"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "2019_multiomic_synthesis_list_frames_with_stop_codon",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    purrr::map(
      .x = `_a1`,
      .f = function(a1) {
        
        vector_coords_no_na <- a1 %>% dplyr::select(matches("genome_relative_stop_codon.*ATGonly")) %>% unlist %>% na.omit
        
        if (length(vector_coords_no_na) > 0) {
          
          purrr::map(
          .x = vector_coords_no_na,
          .f = ~tibble_ref_gtf[(tibble_ref_gtf$type == "stop_codon") & (tibble_ref_gtf$seqnames == a1$seqnames) & (tibble_ref_gtf$start - 1 <= min(.x %>% strsplit(split = ",") %>% unlist %>% type.convert(as.is = TRUE))) & (tibble_ref_gtf$end + 1 >= max(.x %>% strsplit(split = ",") %>% unlist %>% type.convert(as.is = TRUE))), ]
        ) %>%
          return
          
        } else {
          
          return(list())
          
        }
        
      } ) %>% 
      return
    
  } ) %>%
  purrr::flatten()

list_frames_with_stop_codon_pruned <- list_frames_with_stop_codon %>% purrr::keep(.p = ~.x %>% length > 0) %>% purrr::map(.f = ~.x %>% purrr::discard(.p = ~.x %>% nrow == 0)) %>% purrr::keep(.p = ~.x %>% length > 0)

length(list_frames_with_stop_codon_pruned)

```

#### check for ONT 5' or 3' sequencing bias

1. map across every reference gene body
2. find all ONT transcripts with at least one exactly matched exon
3. plot avg. and stdev. of transcript starts and ends, amongst other things, including similarity scores (because longer/shorter transcripts can be due to readthroughs/fusions)
* - can assume ref transcript entries overlap with ont transcript entries, since we already have at least one matching exon.

```{r}

listified_tibble <- tibble_ref_gtf %>% dplyr::group_by(transcript_id) %>% dplyr::group_split()

list_ref_vs_ont_transcript_match_statistics <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(listified_tibble), ncl = 94), .f = ~listified_tibble[.x])
  ), 
  .num_workers = 94,
  .temp_path = "/mnt/scratch/temp/2019_multiomic_synthesis_list_ref_vs_ont_check_for_sequencing_bias.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c("tibble_2023_hmsc_ob_ont_gtf"),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "2019_multiomic_synthesis_list_ref_vs_ont_check_for_sequencing_bias",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    purrr::map(
      .x = `_a1`,
      .f = function(a1) {
        
        tibble_ref_gtf_subset_transcript_entries_only <- a1[a1$type == "transcript", ]
        tibble_ref_gtf_subset_exonic_entries_only <- a1[a1$type == "exon", ]
        
        tibble_matched_ont_exons <- purrr::map(
          .x = tibble_ref_gtf_subset_exonic_entries_only %>% dplyr::rowwise() %>% dplyr::group_split(),
          .f = function(b1) {
            
            # DEBUG ###
            # b1 <- tibble_ref_gtf_subset_exonic_entries_only %>% dplyr::rowwise() %>% dplyr::group_split() %>% .[[2]]
            ###########
            
            # match ref exon to ONT exons
            extract_matching.exons(query_chr = b1$seqnames, query_start = min(c(b1$start, b1$end)), query_end = max(c(b1$start, b1$end)), query_strand = b1$strand, tibble_gtf_table = tibble_2023_hmsc_ob_ont_gtf, left_query_shift = 0, right_query_shift = 0, left_tolerance = 2, right_tolerance = 2, return_type = "exon") %>% 
              return
            
          } ) %>%
          dplyr::bind_rows()
        
        if (nrow(tibble_matched_ont_exons) > 0) {
          
          # fetch all ont entries for the matched transcripts
          list_matched_ont_transcript_entries_per_timepoint <- tibble_matched_ont_exons %>% 
            dplyr::distinct(transcript_id, timepoint, .keep_all = FALSE) %>%
            dplyr::right_join(tibble_2023_hmsc_ob_ont_gtf, ., by = c("transcript_id", "timepoint")) %>% 
            dplyr::group_by(transcript_id, timepoint) %>%
            dplyr::group_split() %>%
            purrr::set_names(nm = purrr::map(.x = ., .f = ~paste(.x$transcript_id, "|", .x$timepoint, sep = "") %>% unique) %>% unlist)
          
          # construct a tibble of counts to see how many #MV and #TVD
          
          tibble_similarity_per_matched_ont_transcript_timepoint <- purrr::map(
            .x = list_matched_ont_transcript_entries_per_timepoint,
            .f = function(b1) {
              
              tibble_matched_ont_transcript_entries_single_timepoint_transcript <- b1[b1$type == "transcript", ]
              tibble_matched_ont_transcript_entries_single_timepoint_exonic <- b1[b1$type == "exon", ]
              
              tibble_vertex_distance_counts <- tibble_ref_gtf_subset_exonic_entries_only %>%
                dplyr::mutate(
                  "min_abs_start_difference" = purrr::map(.x = `start`, .f = ~min(abs(.x - tibble_matched_ont_transcript_entries_single_timepoint_exonic$start))) %>% unlist,
                  "min_abs_end_difference" = purrr::map(.x = `end`, .f = ~min(abs(.x - tibble_matched_ont_transcript_entries_single_timepoint_exonic$end))) %>% unlist
                )
              
              tibble_similarity <- tibble(
                "ont_transcript_id" = b1$transcript_id %>% unique,
                "ont_timepoint" = b1$timepoint %>% unique,
                "start_diff" = if (tibble_ref_gtf_subset_transcript_entries_only$strand != "-") {
                  tibble_matched_ont_transcript_entries_single_timepoint_transcript$start - tibble_ref_gtf_subset_transcript_entries_only$start
                } else {
                  tibble_ref_gtf_subset_transcript_entries_only$end - tibble_matched_ont_transcript_entries_single_timepoint_transcript$end
                },
                "end_diff" = if (tibble_ref_gtf_subset_transcript_entries_only$strand != "-") {
                  tibble_matched_ont_transcript_entries_single_timepoint_transcript$end - tibble_ref_gtf_subset_transcript_entries_only$end
                } else {
                  tibble_ref_gtf_subset_transcript_entries_only$start - tibble_matched_ont_transcript_entries_single_timepoint_transcript$start
                },
                "MV" = length(which(tibble_vertex_distance_counts$min_abs_start_difference <= 2)) + length(which(tibble_vertex_distance_counts$min_abs_end_difference <= 2)),
                "TVD" = length(setdiff(
                  union(purrr::map2(.x = tibble_ref_gtf_subset_exonic_entries_only$start, .y = tibble_ref_gtf_subset_exonic_entries_only$end, .f = ~.x:.y) %>% unlist, purrr::map2(.x = tibble_matched_ont_transcript_entries_single_timepoint_exonic$start, .y = tibble_matched_ont_transcript_entries_single_timepoint_exonic$end, .f = ~.x:.y) %>% unlist),
                  intersect(purrr::map2(.x = tibble_ref_gtf_subset_exonic_entries_only$start, .y = tibble_ref_gtf_subset_exonic_entries_only$end, .f = ~.x:.y) %>% unlist, purrr::map2(.x = tibble_matched_ont_transcript_entries_single_timepoint_exonic$start, .y = tibble_matched_ont_transcript_entries_single_timepoint_exonic$end, .f = ~.x:.y) %>% unlist)
                )),
                "ref_transcript_id" = a1$transcript_id %>% unique
              )
              
              return(tibble_similarity)
              
            } ) %>% 
            dplyr::bind_rows()
          
          return(tibble_similarity_per_matched_ont_transcript_timepoint)
          
        } else {
          
          return(tibble())
          
        }
        
      } ) %>% 
      return
    
  } ) %>%
  purrr::flatten()

saveRDS(object = list_ref_vs_ont_transcript_match_statistics, file = paste(results_dir, "list_ref_vs_ont_transcript_match_statistics.rds"), compress = TRUE)

list_ref_vs_ont_transcript_match_statistics <- readRDS(file = paste(results_dir, "list_ref_vs_ont_transcript_match_statistics.rds"))

# tibble_ref_vs_ont_best_transcript_matches <- list_ref_vs_ont_transcript_match_statistics %>%
#   dplyr::bind_rows() %>%
#   dplyr::arrange(ont_transcript_id) %>%
#   dplyr::group_by(ref_transcript_id) %>%
#   dplyr::summarise(
#     "avg_start_diff" = mean(`start_diff` %>% .[which(`MV` == max(`MV`))[which(`TVD`[which(`MV` == max(`MV`))] == min(`TVD`[which(`MV` == max(`MV`))]))]]),
#     "avg_end_diff" = mean(`end_diff` %>% .[which(`MV` == max(`MV`))[which(`TVD`[which(`MV` == max(`MV`))] == min(`TVD`[which(`MV` == max(`MV`))]))]]),
#     "best_match_MV" = unique(`MV` %>% .[which(`MV` == max(`MV`))[which(`TVD`[which(`MV` == max(`MV`))] == min(`TVD`[which(`MV` == max(`MV`))]))]]),
#     "best_match_TVD" = unique(`TVD` %>% .[which(`MV` == max(`MV`))[which(`TVD`[which(`MV` == max(`MV`))] == min(`TVD`[which(`MV` == max(`MV`))]))]]),
#     "best_match_ref_transcript_ids" = paste(`ref_transcript_id` %>% .[which(`MV` == max(`MV`))[which(`TVD`[which(`MV` == max(`MV`))] == min(`TVD`[which(`MV` == max(`MV`))]))]], collapse = ",")
#   )

# summarise for each ref transcript id, take only highest MV scores.
tibble_ref_vs_ont_best_transcript_matches <- list_ref_vs_ont_transcript_match_statistics %>%
  dplyr::bind_rows() %>%
  dplyr::arrange(ont_transcript_id) %>%
  dplyr::group_by(ref_transcript_id) %>%
  dplyr::summarise(
    "avg_start_diff" = mean(`start_diff` %>% .[which(`MV` == max(`MV`))]),
    "stdev_start_diff" = sd(`start_diff` %>% .[which(`MV` == max(`MV`))]),
    "avg_end_diff" = mean(`end_diff` %>% .[which(`MV` == max(`MV`))]),
    "stdev_end_diff" = sd(`end_diff` %>% .[which(`MV` == max(`MV`))]),
    "best_match_MV" = unique(`MV` %>% .[which(`MV` == max(`MV`))]),
    "avg_TVD" = mean(`TVD` %>% .[which(`MV` == max(`MV`))]),
    "stdev_TVD" = sd(`TVD` %>% .[which(`MV` == max(`MV`))]),
    "best_match_ont_transcript_ids" = paste(`ont_transcript_id` %>% .[which(`MV` == max(`MV`))], collapse = ",")
  )

tibble_ref_vs_ont_best_transcript_matches <- tibble_ref_vs_ont_best_transcript_matches %>%
  dplyr::mutate(across(.cols = contains("stdev"), .fns = function(x) {x[is.na(x)] <- 0; return(x)}) )

# plot probability density distributions of average start diff
vector_datapoints_density_distribution_avg_start_diff <- purrr::reduce(
  .x = list(
    list(rep(0, times = length((mean(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff) - 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff)):(mean(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff) + 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff))))), 
    tibble_ref_vs_ont_best_transcript_matches %>% dplyr::rowwise() %>% dplyr::group_split()
  ) %>% purrr::flatten(),
  .f = function(a1, a2, a3) {
    
    vector_sum <- a1 + 
      dnorm(
        x = (mean(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff) - 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff)):(mean(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff) + 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff)), 
        mean = a2$avg_start_diff, 
        sd = a2$stdev_start_diff
      )
    
    return(vector_sum)
    
  } )

ggplot_ref_vs_ont_transcript_start_concordance <- ggplot2::ggplot() +
  ggplot2::geom_line(mapping = aes(x = (mean(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff) - 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff)):(mean(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff) + 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff)), y = vector_datapoints_density_distribution_avg_start_diff)) +
  ggplot2::scale_y_log10() +
  ggtitle("Ensembl vs. ONT transcript start concordance") +
  ggplot2::xlab("Deviation") +
  ggplot2::ylab("Frequency Density")

# plot probability density distributions of average end diff
vector_datapoints_density_distribution_avg_end_diff <- purrr::reduce(
  .x = list(
    list(rep(0, times = length((mean(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff) - 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff)):(mean(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff) + 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff))))), 
    tibble_ref_vs_ont_best_transcript_matches %>% dplyr::rowwise() %>% dplyr::group_split()
  ) %>% purrr::flatten(),
  .f = function(a1, a2, a3) {
    
    vector_sum <- a1 + 
      dnorm(
        x = (mean(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff) - 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff)):(mean(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff) + 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff)), 
        mean = a2$avg_start_diff, 
        sd = a2$stdev_start_diff
      )
    
    return(vector_sum)
    
  } )

ggplot_ref_vs_ont_transcript_end_concordance <- ggplot2::ggplot() +
  ggplot2::geom_line(mapping = aes(x = (mean(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff) - 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff)):(mean(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff) + 3*sd(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff)), y = vector_datapoints_density_distribution_avg_end_diff)) +
  ggplot2::scale_y_log10() +
  ggplot2::ggtitle("Ensembl vs. ONT transcript end concordance") +
  ggplot2::xlab("Deviation") +
  ggplot2::ylab("Frequency Density")

```

#### view the plots

```{r}

ggplot_ref_vs_ont_transcript_start_concordance
ggplot_ref_vs_ont_transcript_end_concordance

plot(density(tibble_ref_vs_ont_best_transcript_matches$avg_start_diff), main = "Ensembl vs. ONT transcript start concordance")
plot(density(tibble_ref_vs_ont_best_transcript_matches$avg_end_diff), main = "Ensembl vs. ONT transcript end concordance")

```


### Apply best strategy for NMD detection

```{r}

list_psisigma_differential_with_na_nmd_results <- purrr::map(
  .x = list_psisigma_differential_with_na_matched_to_ont %>% .[purrr::map(.x = ., .f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist],
  .f = function(a1) {
    
    # DEBUG ###
    a1 <- list_psisigma_differential_with_na_matched_to_ont %>% .[purrr::map(.x = ., .f = ~.x$list_matched_ont_inclusion_entries %>% length > 0) %>% unlist] %>% .[[1]]
    ###########
    
    tibble_inclusion_entries <- a1$list_matched_ont_inclusion_entries %>% purrr::map(.f = ~.x %>% tibble::as_tibble()) %>% dplyr::bind_rows()
    
    # tally of first/last exon
    tibble_tally_first_last_exon <- tibble_inclusion_entries$first_or_last_exon %>% table %>% tibble::as_tibble()
    
    tibble_inclusion_transcript_entries <- a1$list_matched_ont_inclusion_transcript_entries %>% dplyr::bind_rows()
    
    tibble_exclusion_transcript_entries <- a1$list_matched_ont_exclusion_transcript_entries %>% dplyr::bind_rows()
    
  } )

```

### Do relative NMD analysis for each frame

- For all splice events detected by SR, get some statistics on the number of frames which usually undergo simultaneous SWITCHING
- Then apply our conclusions for each splice event if deemed valid

```{r}

list_psisigma_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_differential_with_na_matched_to_ont.rds", sep = ""))
list_psisigma_constitutive_matched_to_ont <- readRDS(file = paste(results_dir, "list_psisigma_constitutive_matched_to_ont.rds", sep = ""))
list_jum_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_differential_with_na_matched_to_ont.rds", sep = ""))
list_jum_constitutive_no_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_jum_constitutive_no_na_matched_to_ont.rds", sep = ""))
list_majiq_differential_with_na_matched_to_ont <- readRDS(file = paste(results_dir, "list_majiq_differential_with_na_matched_to_ont.rds", sep = ""))
list_majiq_constitutive_matched_to_ont <- readRDS(file = paste(results_dir, "list_majiq_constitutive_matched_to_ont.rds", sep = ""))

tibble_PSIsigma_differential_dpsi0.10_pvalue0.01_with_na
tibble_PSIsigma_constitutive_dpsi0.10_pvalue0.01_with_na
tibble_JUM_differential_dpsi0.15_qvalue0.01_with_na
tibble_JUM_constitutive_dpsi0.15_qvalue0.01_no_na
tibble_majiq_differential_with_na
tibble_majiq_constitutive

```

#### psisigma differential

```{r}

list_psisigma_differential_with_na_matched_to_ont_pruned <- list_psisigma_differential_with_na_matched_to_ont %>% 
  purrr::discard(.p = ~.x$list_matched_ont_inclusion_entries %>% length == 0)

list_psisigma_differential_vs_ont_ptc_results_per_frame <- round_robin_pmap_callr(
  .l = list(
    "_a1" = purrr::map(.x = parallel::splitIndices(nx = length(list_psisigma_differential_with_na_matched_to_ont_pruned), ncl = 32), .f = ~list_psisigma_differential_with_na_matched_to_ont_pruned[.x])
  ), 
  .num_workers = 32,
  .temp_path = "/mnt/scratch/temp/2019_multiomic_synthesis_list_psisigma_differential_vs_ont_ptc_results_per_frame.rdata",
  .temp_dir = "/mnt/scratch/temp/",
  .re_export = TRUE,
  .env_flag = "user",
  .objects = c(),
  .status_messages_dir = "/mnt/scratch/temp/",
  .job_name = "2019_multiomic_synthesis_list_psisigma_differential_vs_ont_ptc_results_per_frame",
  .result_mode = "ordered",
  .keep_intermediate_files = FALSE,
  .f = function(`_a1`) {
    
    library(seqinr)
    library(tidyverse)
    library(purrr)
    library(furrr)
    library(dplyr)
    library(rtracklayer)
    library(data.table)
    library(optparse)
    
    library(tictoc)
    
    source("/mnt/LTS/tools/angel_suite/source/main_source.R")
    
    purrr::map(
      .x = `_a1`,
      .f = function(a1) {
        
        # DEBUG ###
        # a1 <- list_psisigma_differential_with_na_matched_to_ont_pruned[[12]]
        ###########
        
        tibble_tally_inclusion_contains_PTC_frame0_ATGonly <- a1$list_matched_ont_inclusion_entries %>% purrr::map(.f = ~.x$contains_PTC_frame0_ATGonly) %>% unlist %>% paste %>% table %>% tibble::as_tibble() %>% dplyr::left_join(tibble(. = c("TRUE", "FALSE", "NA")), .) %>% dplyr::mutate_at(.vars = "n", function(x) {x[is.na(x)] <- 0; x <- x/sum(x); return(x)} )
        tibble_tally_inclusion_contains_PTC_frame1_ATGonly <- a1$list_matched_ont_inclusion_entries %>% purrr::map(.f = ~.x$contains_PTC_frame1_ATGonly) %>% unlist %>% paste %>% table %>% tibble::as_tibble() %>% dplyr::left_join(tibble(. = c("TRUE", "FALSE", "NA")), .) %>% dplyr::mutate_at(.vars = "n", function(x) {x[is.na(x)] <- 0; x <- x/sum(x); return(x)} )
        tibble_tally_inclusion_contains_PTC_frame2_ATGonly <- a1$list_matched_ont_inclusion_entries %>% purrr::map(.f = ~.x$contains_PTC_frame2_ATGonly) %>% unlist %>% paste %>% table %>% tibble::as_tibble() %>% dplyr::left_join(tibble(. = c("TRUE", "FALSE", "NA")), .) %>% dplyr::mutate_at(.vars = "n", function(x) {x[is.na(x)] <- 0; x <- x/sum(x); return(x)} )
        
        if (length(a1$list_matched_ont_exclusion_entries) > 0) {
          
          tibble_tally_exclusion_contains_PTC_frame0_ATGonly <- a1$list_matched_ont_exclusion_entries %>% purrr::map(.f = ~.x$contains_PTC_frame0_ATGonly) %>% unlist %>% paste %>% table %>% tibble::as_tibble() %>% dplyr::left_join(tibble(. = c("TRUE", "FALSE", "NA")), .) %>% dplyr::mutate_at(.vars = "n", function(x) {x[is.na(x)] <- 0; x <- x/sum(x); return(x)} )
          tibble_tally_exclusion_contains_PTC_frame1_ATGonly <- a1$list_matched_ont_exclusion_entries %>% purrr::map(.f = ~.x$contains_PTC_frame1_ATGonly) %>% unlist %>% paste %>% table %>% tibble::as_tibble() %>% dplyr::left_join(tibble(. = c("TRUE", "FALSE", "NA")), .) %>% dplyr::mutate_at(.vars = "n", function(x) {x[is.na(x)] <- 0; x <- x/sum(x); return(x)} )
          tibble_tally_exclusion_contains_PTC_frame2_ATGonly <- a1$list_matched_ont_exclusion_entries %>% purrr::map(.f = ~.x$contains_PTC_frame2_ATGonly) %>% unlist %>% paste %>% table %>% tibble::as_tibble() %>% dplyr::left_join(tibble(. = c("TRUE", "FALSE", "NA")), .) %>% dplyr::mutate_at(.vars = "n", function(x) {x[is.na(x)] <- 0; x <- x/sum(x); return(x)} )
          
        } else {
          tibble_tally_exclusion_contains_PTC_frame0_ATGonly <- "no_exclusion_match"
          tibble_tally_exclusion_contains_PTC_frame1_ATGonly <- "no_exclusion_match"
          tibble_tally_exclusion_contains_PTC_frame2_ATGonly <- "no_exclusion_match"
        }
        
        return(
          list(
            "tibble_tally_inclusion_contains_PTC_frame0_ATGonly" = tibble_tally_inclusion_contains_PTC_frame0_ATGonly,
            "tibble_tally_inclusion_contains_PTC_frame1_ATGonly" = tibble_tally_inclusion_contains_PTC_frame1_ATGonly,
            "tibble_tally_inclusion_contains_PTC_frame2_ATGonly" = tibble_tally_inclusion_contains_PTC_frame2_ATGonly,
            
            "tibble_tally_exclusion_contains_PTC_frame0_ATGonly" = tibble_tally_exclusion_contains_PTC_frame0_ATGonly,
            "tibble_tally_exclusion_contains_PTC_frame1_ATGonly" = tibble_tally_exclusion_contains_PTC_frame1_ATGonly,
            "tibble_tally_exclusion_contains_PTC_frame2_ATGonly" = tibble_tally_exclusion_contains_PTC_frame2_ATGonly
          )
        )
        
      } )
    
  } ) %>% purrr::flatten()

# chi squared test of uniformity
# $n %>% (function(x) {x <- x - (1/3); y <- x^2; csq <- sum(y * 3); return(csq)})

list_psisigma_differential_vs_ont_ptc_results_per_frame_pruned <- list_psisigma_differential_vs_ont_ptc_results_per_frame %>%
  purrr::discard(.p = ~data.class(.x$tibble_tally_exclusion_contains_PTC_frame0_ATGonly) != "tbl_df" | data.class(.x$tibble_tally_exclusion_contains_PTC_frame1_ATGonly) != "tbl_df" | data.class(.x$tibble_tally_exclusion_contains_PTC_frame2_ATGonly) != "tbl_df")

list_psisigma_differential_vs_ont_ptc_results_per_frame_differences <- purrr::map(
  .x = list_psisigma_differential_vs_ont_ptc_results_per_frame_pruned,
  .f = function(a1) {
    
    list(
      "tibble_diff_contains_PTC_frame0_ATGonly" = tibble("." = a1$tibble_tally_inclusion_contains_PTC_frame0_ATGonly$`.`, "n" = a1$tibble_tally_inclusion_contains_PTC_frame0_ATGonly$n - a1$tibble_tally_exclusion_contains_PTC_frame0_ATGonly$n),
      "tibble_diff_contains_PTC_frame1_ATGonly" = tibble("." = a1$tibble_tally_inclusion_contains_PTC_frame1_ATGonly$`.`, "n" = a1$tibble_tally_inclusion_contains_PTC_frame1_ATGonly$n - a1$tibble_tally_exclusion_contains_PTC_frame1_ATGonly$n),
      "tibble_diff_contains_PTC_frame2_ATGonly" = tibble("." = a1$tibble_tally_inclusion_contains_PTC_frame2_ATGonly$`.`, "n" = a1$tibble_tally_inclusion_contains_PTC_frame2_ATGonly$n - a1$tibble_tally_exclusion_contains_PTC_frame2_ATGonly$n)
    ) %>%
      return
    
  } )

list_psisigma_differential_vs_ont_ptc_sigdiff <- purrr::map(
  .x = list_psisigma_differential_vs_ont_ptc_results_per_frame_differences,
  .f = function(a1) {
    tibble(
      "frame0_ptc_sigdiff" = any(abs(a1$tibble_diff_contains_PTC_frame0_ATGonly$n) > (1/3)),
      "frame1_ptc_sigdiff" = any(abs(a1$tibble_diff_contains_PTC_frame1_ATGonly$n) > (1/3)),
      "frame2_ptc_sigdiff" = any(abs(a1$tibble_diff_contains_PTC_frame2_ATGonly$n) > (1/3))
        ) %>%
      return
  }
)

# plot frequency of ptc switching simultaneity across frames
list_psisigma_differential_vs_ont_ptc_sigdiff %>% purrr::map(.f = ~.x %>% t %>% which %>% length) %>% unlist %>% table

```

